<!-- templates/brg_station_slider_enhanced.html - OPTIMIZED FOR LARGE ROTATED DISPLAYS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRG Assembly 40K - Display {{ station.display_number }}</title>
    <style>

body, html {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background-color: #ffffff !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* ENHANCED: Better rotation for portrait monitors */
body {
    transform: rotate(90deg);
    transform-origin: center center;
    width: 100vh;
    height: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    margin-top: -50vw;
    margin-left: -50vh;
    background-color: #ffffff !important;
}

.main-container {
    display: flex;
    flex-direction: column;
    height: 102vw;
    width: 100vh;
    position: relative;
}

/* COMPACT: Reduced header height to maximize content area */
.assembly-header {
    background: #DF2427;
    color: white;
    padding: 18px 30px; /* Increased from 12px 25px */
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 80px; /* Increased from 60px */
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    flex-shrink: 0;
}

.product-info {
    display: flex;
    flex-direction: column;
}

.product-code {
    font-size: 36px; /* Increased from 28px */
    font-weight: bold;
    margin-bottom: 10px; /* Increased from 8px */
    margin-bottom: 8px;
        line-height: 1.2;

}

.process-info {
    font-size: 22px; /* Increased from 18px */
    opacity: 0.9;
        line-height: 1.3;

}

.display-badge {
    background: #DF2427;
    padding: 15px 25px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 24px;
}
.display-badge div {
    font-size: 16px !important; /* Increased from 14px */
    margin-top: 5px !important; /* Increased from 3px */
}

.display-1 { border-left: 5px solid #FF6B6B; }
.display-2 { border-left: 5px solid #4ECDC4; }
.display-3 { border-left: 5px solid #45B7D1; }

/* ENHANCED: Media slider with better flex management */
.slider-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: rgb(255, 255, 255);
    overflow: hidden;
    min-height: 0; /* Important for flex children */
}

.media-element {
    height: 100%;
    width: 100%;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: contain;
    transition: opacity 0.5s ease-in-out;
}

/* COMPLETELY REWRITTEN: PDF styling for large rotated displays */
.media-element.pdf {
    /* MAXIMIZED: Use every pixel available */
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    
    position: absolute;
    top: 62%;
    left: 54%;

    /* ENHANCED: Better PDF rendering */
    object-fit: cover;
    border: none;
    background-color: white;
    
    /* CRITICAL: Force PDF to use full space */
    box-sizing: border-box;
    
    /* ENHANCED: High quality rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    
    /* REMOVE: Any margins or padding that might interfere */
    margin: 0 0 0 0 !important;
    padding: 0 !important;
    /* Centered zoom */
    transform: scale(1.088) translate(-50%, -50%);
    transform-origin: center center;

}

/* ALTERNATIVE: PDF iframe for better control */
.media-element.pdf-iframe {
    width: 100% !important;
    height: 100% !important;
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    border: none;
    background-color: white;
    overflow: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* ENHANCED: PDF controls with better visibility */
.pdf-controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 150;
    display: flex;
    gap: 15px;
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.pdf-controls:hover {
    opacity: 1;
}
.media-element video {
    /* Hardware acceleration */
    transform: translateZ(0);
    will-change: opacity;
    backface-visibility: hidden;
    
    /* Smooth transitions */
    transition: opacity 0.3s ease;
}

.media-element.video-optimized {
    /* Reduce repaints */
    image-rendering: optimizeSpeed;
}
.pdf-control-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.pdf-control-btn:hover {
    background: rgba(0,0,0,1);
    transform: scale(1.1);
}

/* ENHANCED: Fullscreen PDF mode */
.media-element.pdf.fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    z-index: 1000;
    background: white;
    position: fixed !important;
}

.media-element.bom {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
}

.media-element.active {
    display: block;
    opacity: 1;
}

.media-element.fade-out {
    opacity: 0;
}

/* ENHANCED: Better clicker controls for large screens */
.clicker-controls {
    position: absolute;
    bottom: -25px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.clicker-left {
    left: 30px;
}

.clicker-right {
    right: 30px;
}

.clicker-btn {
    background: rgba(52, 152, 219, 0.9);
    border: none;
    border-radius: 50%;
    width: 90px;
    height: 90px;
    color: white;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
}

.clicker-btn:hover {
    background: rgba(52, 152, 219, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.clicker-btn:active {
    transform: scale(0.95);
    background: rgba(41, 128, 185, 1);
}

.clicker-hint {
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    margin-top: 8px;
    white-space: nowrap;
}

.clicker-controls.hidden {
    display: none;
}

/* Enhanced click feedback */
.click-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(46, 204, 113, 0.95);
    color: white;
    padding: 25px 50px;
    border-radius: 30px;
    font-size: 22px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
    transition: all 0.3s ease;
}

.click-alert.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.click-alert.error {
    background: rgba(231, 76, 60, 0.95);
}

/* COMPACT: Reduced status bar height to reclaim space */
.status-bar {
    background: rgba(246, 246, 246, 0.9);
    color: white;
    padding: 4px 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
    flex-shrink: 0;
    font-size: 14px;
}

.loop-indicator {
    background: #f39c12;
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 2s infinite;
}

.loop-indicator.hidden {
    display: none;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.connection-status {
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.connection-status.visible { opacity: 1; }
.connection-status.connected { background-color: #27ae60; color: white; }
.connection-status.disconnected { background-color: #e74c3c; color: white; }
.connection-status.reconnecting { background-color: #f39c12; color: white; }

/* Navigation hints */
.navigation-hints {
    background: rgba(52, 152, 219, 0.2);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.navigation-hints.hidden {
    display: none;
}

/* ENHANCED: Media type indicators */
.media-type-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    backdrop-filter: blur(5px);
}

.bom-indicator { background: rgba(52, 152, 219, 0.8); }
.video-indicator { background: rgba(231, 76, 60, 0.8); }
.doc-indicator { 
    background: rgba(46, 204, 113, 0.8);
    font-size: 18px;
    padding: 15px 25px;
}

/* Error states */
.error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    font-size: 20px;
    z-index: 1000;
}

.error-message.hidden {
    display: none;
}

/* BOM indicator in status bar */
.bom-status {
    background: rgba(52, 152, 219, 0.8);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
}

/* CRITICAL: Responsive scaling for different large monitor sizes */
@media screen and (min-width: 1920px) {
    .product-code { font-size: 42px; }
    .process-info { font-size: 26px; }
    .display-badge { font-size: 28px; padding: 18px 30px; }
    .assembly-header { padding: 20px 35px; min-height: 70px; }
    .status-bar { padding: 10px 30px; font-size: 16px; min-height: 40px; }
    
    .media-element.pdf {
        /* FORCE: Maximum utilization on large screens */
        width: 100% !important;
        height: 100% !important;
    }
}

@media screen and (min-width: 2560px) {
    .product-code { 
        font-size: 50px; /* Increased from 36px */
        margin-bottom: 15px;
    }
    .process-info { font-size: 30px; }
    .display-badge { font-size: 32x; padding: 18px 30px; }
    .assembly-header { padding: 25px 40px; min-height: 100px; }
    .status-bar { padding: 12px 35px; font-size: 18px; min-height: 45px; }
    
    .pdf-control-btn { width: 70px; height: 70px; font-size: 24px; }
    .clicker-btn { width: 100px; height: 100px; font-size: 32px; }
    
    .media-type-indicator { font-size: 18px; padding: 15px 25px; }
    .doc-indicator { font-size: 20px; padding: 18px 30px; }
}

@media screen and (min-width: 3440px) {
    .assembly-header { 
        padding: 30px 45px; 
        min-height: 130px; /* Increased from 90px */
    }
    .product-code { 
        font-size: 58px; /* Increased from 40px */
        margin-bottom: 18px;
    }
    .process-info { 
        font-size: 34px; /* Increased from 24px */
    }
    .display-badge { 
        font-size: 36px; /* Increased from 26px */
        padding: 25px 40px; /* Increased from 20px 35px */
    }

    .status-bar { padding: 15px 40px; font-size: 20px; min-height: 50px; }
    
    .pdf-control-btn { width: 80px; height: 80px; font-size: 28px; }
    .clicker-btn { width: 110px; height: 110px; font-size: 36px; }
    
    .media-type-indicator { font-size: 20px; padding: 18px 30px; }
    .doc-indicator { font-size: 24px; padding: 20px 35px; }
}

/* ULTRA-WIDE: 4K and above optimizations */
@media screen and (min-width: 4096px) {
    .assembly-header { 
        padding: 35px 50px; 
        min-height: 150px; /* Increased from 100px */
    }
    .product-code { 
        font-size: 66px; /* Increased from 44px */
        margin-bottom: 20px;
    }
    .process-info { 
        font-size: 38px; /* Increased from 26px */
    }
    .display-badge { 
        font-size: 40px; /* Increased from 28px */
        padding: 28px 45px; /* Increased from 25px 40px */
    }
    .status-bar { padding: 18px 45px; font-size: 22px; min-height: 55px; }
    
    .pdf-control-btn { width: 90px; height: 90px; font-size: 32px; }
    .clicker-btn { width: 120px; height: 120px; font-size: 40px; }
    
    .media-type-indicator { font-size: 22px; padding: 20px 35px; }
    .doc-indicator { font-size: 26px; padding: 25px 40px; }
}

/* PDF LOADING INDICATOR */
.pdf-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #333;
    font-size: 24px;
    z-index: 50;
    background: rgba(255, 255, 255, 0.9);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.pdf-loading::after {
    content: "...";
    animation: dots 2s infinite;
}

@keyframes dots {
    0%, 20% { content: ""; }
    40% { content: "."; }
    60% { content: ".."; }
    80%, 100% { content: "..."; }
}

/* ZOOM ENHANCEMENT: Better PDF zoom controls */
.pdf-zoom-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 120;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pdf-zoom-info.visible {
    opacity: 1;
}

/* DEBUG: Temporary border to see PDF boundaries (remove in production) */
.media-element.pdf.debug {
    border: 3px solid red !important;
}

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Assembly Header -->
        <div class="assembly-header display-{{ station.display_number }}">
            <div class="product-info">
                <div class="product-code" id="product-code">
                    {% if current_product %}{{ current_product.code }}{% else %}No Product Selected{% endif %}
                </div>
                <div class="process-info" id="process-info">
                    {% if current_process %}
                        {{ current_stage.display_name }} - {{ current_process.display_name }}
                    {% else %}
                        No Process Selected
                    {% endif %}
                </div>
            </div>
            <div class="display-badge">
                Display {{ station.display_number }}
                <div style="font-size: 14px; margin-top: 3px;">
                    {% if station.display_number == 1 %}BOMs & Reference
                    {% elif station.display_number == 2 %}Process Instructions  
                    {% else %}Instructional Videos{% endif %}
                </div>
            </div>
        </div>

        <!-- Media Slider -->
        <div class="slider-container" id="slider-container">
            <!-- Left Clicker Controls -->
<div class="clicker-controls clicker-left {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="left-controls">
    <button class="clicker-btn" id="backward-btn" title="Previous Process">
        &#8592;
    </button>
    <div class="clicker-hint">‚Üê Previous</div>
</div>

            <!-- Right Clicker Controls -->
<div class="clicker-controls clicker-right {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="right-controls">
    <button class="clicker-btn" id="forward-btn" title="Next Process">
        &#8594;
    </button>
    <div class="clicker-hint">Next ‚Üí</div>
</div>

            <div class="error-message hidden" id="error-message">
                <div>‚ö†Ô∏è Connection Error</div>
                <div style="font-size: 16px; margin-top: 15px;">
                    Please check network connection or contact supervisor
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            {% if has_bom_data %}
            <div class="bom-status" id="bom-status">
                üìã BOM: {{ bom_item_count }} items
            </div>
            {% endif %}
            
            <div class="loop-indicator {% if not loop_mode %}hidden{% endif %}" id="loop-indicator">
                üîÑ LOOP MODE - Processes 1A, 1B, 1C
            </div>
            <div id="connection-status" class="connection-status">Connecting...</div>
        </div>

        <!-- Click Feedback Alert -->
        <div class="click-alert" id="click-alert">
            Action Completed!
        </div>
    </div>

    <script>
// COMPLETE FIXED SCRIPT - NO MORE PAGE REVERT ISSUE
class OptimizedVideoManager {
    constructor() {
        this.videoCache = new Map();
        this.preloadQueue = [];
        this.maxCacheSize = 3;
        this.videoBufferSize = 1;
    }

    createOptimizedVideoElement(media, index) {
        const video = document.createElement('video');
        video.src = media.url;
        video.className = 'media-element video-optimized';
        video.preload = index === 0 ? 'auto' : 'metadata';
        video.controls = false;
        video.loop = false;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        
        video.setAttribute('webkit-playsinline', 'true');
        video.setAttribute('playsinline', 'true');
        video.setAttribute('x-webkit-airplay', 'allow');
        
        video.addEventListener('loadstart', () => {
        });
        
        video.addEventListener('canplaythrough', () => {
            this.videoCache.set(media.url, video);
            this.manageCacheSize();
        });
        
        video.addEventListener('loadedmetadata', () => {
        });
        
        video.addEventListener('error', (e) => {
            this.handleVideoError(video, media, index);
        });
        
        video.addEventListener('stalled', () => {
            this.recoverStalledVideo(video);
        });
        
        video.addEventListener('waiting', () => {
        });
        
        return video;
    }
    
    preloadNextVideos(currentIndex, mediaElements) {
        const nextIndex = (currentIndex + 1) % mediaElements.length;
        const nextVideo = mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload !== 'auto') {
            nextVideo.preload = 'auto';
            nextVideo.load();
        }
    }
    
    manageCacheSize() {
        if (this.videoCache.size > this.maxCacheSize) {
            const oldestKey = this.videoCache.keys().next().value;
            const oldVideo = this.videoCache.get(oldestKey);
            if (oldVideo && !oldVideo.classList.contains('active')) {
                oldVideo.src = '';
                this.videoCache.delete(oldestKey);
            }
        }
    }
    
    handleVideoError(video, media, index, retryCount = 0) {
        const maxRetries = 2;
        
        if (retryCount < maxRetries) {
            setTimeout(() => {
                video.load();
                this.handleVideoError(video, media, index, retryCount + 1);
            }, 1000 * (retryCount + 1));
        } else {
            console.error(`Video ${index} failed after ${maxRetries} retries`);
            this.showVideoErrorPlaceholder(video, media);
        }
    }
    
    recoverStalledVideo(video) {
        const currentTime = video.currentTime;
        video.load();
        video.addEventListener('loadedmetadata', () => {
            video.currentTime = currentTime;
        }, { once: true });
    }
    
    showVideoErrorPlaceholder(video, media) {
        const container = video.parentElement;
        const errorDiv = document.createElement('div');
        errorDiv.className = 'video-error-placeholder';
        errorDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: #2c3e50; color: white; font-size: 24px;">
                <div style="font-size: 48px; margin-bottom: 20px;">üé•</div>
                <div>Video Unavailable</div>
                <div style="font-size: 16px; margin-top: 10px; opacity: 0.7;">
                    ${media.url.split('/').pop()}
                </div>
            </div>
        `;
        container.appendChild(errorDiv);
        video.style.display = 'none';
    }
    
    async playVideoOptimized(video) {
        try {
            if (video.readyState < 3) {
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (video.readyState >= 3) {
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }
            
            await video.play();
            return true;
        } catch (error) {
            console.error('Video play error:', error);
            
            if (error.name === 'NotAllowedError') {
                video.muted = true;
                try {
                    await video.play();
                    return true;
                } catch (mutedError) {
                    console.error('Muted video play also failed:', mutedError);
                }
            }
            
            return false;
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.currentTime = 0;
            video.removeAttribute('src');
            video.load();
        }
    }
}

class VideoMemoryManager {
    constructor() {
        this.activeVideos = new Set();
        this.maxActiveVideos = 2;
    }
    
    registerVideo(video) {
        this.activeVideos.add(video);
        this.enforceMemoryLimits();
    }
    
    unregisterVideo(video) {
        this.activeVideos.delete(video);
        this.cleanupVideo(video);
    }
    
    enforceMemoryLimits() {
        if (this.activeVideos.size > this.maxActiveVideos) {
            const videosArray = Array.from(this.activeVideos);
            const oldestVideo = videosArray[0];
            this.unregisterVideo(oldestVideo);
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.removeAttribute('src');
            video.load();
        }
    }
    
    cleanup() {
        this.activeVideos.forEach(video => this.cleanupVideo(video));
        this.activeVideos.clear();
    }
}

// MAIN CLASS - COMPLETE REWRITE WITH FIXED PAGINATION
class BRGMediaSliderWithAutoLoop {
    constructor(stationId, displayNumber) {
        this.stationId = stationId;
        this.displayNumber = displayNumber;
        this.currentIndex = 0;
        this.mediaElements = [];
        this.slideshowTimer = null;
        this.pollingInterval = null;
        this.pollingDelay = 1000;
        this.lastDataHash = null;
        this.lastBomPaginationHash = null; // FIXED: Proper variable name
        this.pdfFullscreen = false;
        this.currentPdfZoom = 1.0;
        
        // Auto loop properties
        this.autoLoopMode = false;
        this.autoLoopTimer = null;
        this.autoLoopProgressTimer = null;
        this.loopProcessDurations = {
            'PROCESS 1A OF 6': 30000,
            'PROCESS 1B OF 6': 30000,
            'PROCESS 1C OF 6': 30000
        };

        // CRITICAL: BOM pagination properties - FIXED
        this.autoBomPaginationTimer = null;
        this.currentBomTotalPages = 1;
        this.isBomAutoPaginationActive = false;
        this.ignoreExternalBOMUpdates = false; // CRITICAL: Fixed missing semicolon
        this.isManualPaginationInProgress = false;
        this.currentBomPage = 1;
        this.manualPaginationCooldown = false; // NEW: Additional protection
        
        this.currentProcessName = null;
        this.isInLoopGroup = false;
        this.paginationMode = 'split';
        this.itemsPerScreen = 8;

        // DOM elements
        this.containerElement = document.getElementById('slider-container');
        this.statusElement = document.getElementById('connection-status');
        this.errorElement = document.getElementById('error-message');
        this.productCodeElement = document.getElementById('product-code');
        this.processInfoElement = document.getElementById('process-info');
        this.loopIndicatorElement = document.getElementById('loop-indicator');
        this.leftControlsElement = document.getElementById('left-controls');
        this.rightControlsElement = document.getElementById('right-controls');
        this.clickAlertElement = document.getElementById('click-alert');
        this.bomStatusElement = document.getElementById('bom-status');
        
        this.startPolling();
        this.setupKeyboardListeners();
        this.setupClickerListeners();
        this.logScreenInfo();
    }
async triggerOtherStationsReload() {
    try {
        
        const response = await fetch(`/station/${this.stationId}/trigger-stations-reload/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                source_station: this.displayNumber,
                target_stations: [2, 3]
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            this.showClickAlert('Triggered reload on Stations 2 & 3', false);
        } else {
            console.error('Failed to trigger stations reload:', result.error);
        }
    } catch (error) {
        console.error('Error triggering stations reload:', error);
    }
}

async checkForReloadSignal() {
    // Only stations 2 and 3 should check for reload signals
    if (this.displayNumber === 2 || this.displayNumber === 3) {
        try {
            const response = await fetch(`/station/${this.stationId}/check-reload-signal/?display_number=${this.displayNumber}`);
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.success && result.should_reload) {
                    this.showClickAlert(`Reload triggered by Station ${result.signal_data.triggered_by}`, false);
                    
                    // Wait 1 second then reload
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                }
            }
        } catch (error) {
            console.error('Error checking reload signal:', error);
        }
    }
}
    logScreenInfo() {
        console.log('Screen Information:', {
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            screenWidth: screen.width,
            screenHeight: screen.height,
            devicePixelRatio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.angle : 'unknown'
        });
    }

    async startPolling() {
        await this.pollForUpdates();
        this.pollingInterval = setInterval(async () => {
            await this.pollForUpdates();
                await this.checkForReloadSignal(); // NEW: Check for reload signals

        }, this.pollingDelay);
    }

async pollForUpdates() {
    try {
        // ‚≠ê ADD THIS: Check for BOM sync signals first (for displays 2 & 3)
        if (this.displayNumber !== 1) {
            await this.checkForBOMSyncSignal();
        }
        


        let mediaEndpoint = `/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`;
        
        const mediaResponse = await fetch(mediaEndpoint);
        if (!mediaResponse.ok) {
            throw new Error(`HTTP ${mediaResponse.status}`);
        }
        const mediaData = await mediaResponse.json();
        
        // FIX 2: Check for process changes that should reset pagination
        const currentProcessName = mediaData.station_info?.current_process?.name;
        const processChanged = this.currentProcessName && (this.currentProcessName !== currentProcessName);
        
        if (processChanged) {
            console.log(`üîÑ Process changed from ${this.currentProcessName} to ${currentProcessName} - resetting pagination state`);
            
            // CRITICAL: Reset all manual pagination protection when process changes
            this.isManualPaginationInProgress = false;
            this.ignoreExternalBOMUpdates = false;
            this.manualPaginationCooldown = false;
            this.stopAutoBomPagination();
            
            // Force reset BOM to page 1 for new process
            if (this.isCurrentlyShowingBOM()) {
                try {
                    console.log('üîÑ Resetting BOM to page 1 for new process...');
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log('‚úÖ BOM pagination reset to page 1 for new process');
                            this.showClickAlert(`New Process: ${currentProcessName} - Reset to Page 1`, false);
                        }
                    }
                } catch (resetError) {
                    console.warn('‚ö†Ô∏è Could not reset BOM pagination for new process:', resetError);
                }
            }
        }
        
        // Get current BOM pagination state for sync detection
        let currentBomPage = 1;
        let totalBomPages = 1;
        let bomPaginationHash = '';
        
        try {
            const bomPaginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
            if (bomPaginationResponse.ok) {
                const bomPaginationData = await bomPaginationResponse.json();
                const mediaItem = bomPaginationData.media?.[0];
                currentBomPage = mediaItem?.pagination?.current_page ?? 1;
                totalBomPages = mediaItem?.pagination?.total_pages ?? 1;
                bomPaginationHash = `${currentBomPage}_${totalBomPages}_${this.paginationMode}_${this.itemsPerScreen}`;
            }
        } catch (bomError) {
            console.warn('Could not fetch BOM pagination state:', bomError);
        }
        
        // Create hash for change detection
        const mediaHash = JSON.stringify({
            media: mediaData.media ? mediaData.media.map(m => ({ 
                id: m.id, 
                url: m.url, 
                type: m.type,
                is_bom_data: m.is_bom_data,
                bom_type: m.bom_type,
                bom_hash: m.bom_hash
            })) : [],
            station: mediaData.station_info,
            bom_pagination: bomPaginationHash
        });
        
        // Check what changed
        const mediaChanged = mediaHash !== this.lastDataHash;
        const bomPaginationChanged = bomPaginationHash !== this.lastBomPaginationHash;
        
        // FIX 2: Allow updates when process changes, even during manual pagination
        if ((bomPaginationChanged || mediaChanged) && 
            (this.ignoreExternalBOMUpdates || this.isManualPaginationInProgress || this.manualPaginationCooldown) &&
            !processChanged) { // FIXED: Allow updates when process changes
            console.log(`Display ${this.displayNumber}: Ignoring external updates - manual pagination active (but not process change)`);
            return;
        }
        
        if (mediaChanged || bomPaginationChanged || processChanged) {
            console.log(`Display ${this.displayNumber} update detected:`, { 
                mediaChanged, 
                bomPaginationChanged,
                processChanged,
                currentBomPage,
                totalBomPages,
                displayNumber: this.displayNumber
            });
            
            // Handle pagination changes differently from media changes
            if (bomPaginationChanged && !mediaChanged && !processChanged) {
                console.log(`Display ${this.displayNumber}: BOM pagination changed externally - syncing to page ${currentBomPage}/${totalBomPages}`);
                
                if (this.isCurrentlyShowingBOM()) {
                    await this.refreshBOMContent();
                    this.showClickAlert(`Synced: Page ${currentBomPage}/${totalBomPages}`, false);
                } else {
                    await this.refreshBOMContent();
                }

                this.lastBomPaginationHash = bomPaginationHash;
            } 
            else {
                // Handle normal media changes or process changes
                this.checkAutoLoopMode(mediaData);
                this.updateAssemblyInfo(mediaData, null);
                this.updateMedia(mediaData, null, false);
                this.playCurrentMedia();
                
                if (this.isCurrentlyShowingBOM()) {
                    console.log('Detected BOM slide after media update, refreshing content...');
                    this.refreshCurrentBOMContent();
                }

                this.hideError();
                this.updateConnectionStatus('connected', 'Updated');
                
                this.lastDataHash = mediaHash;
                this.lastBomPaginationHash = bomPaginationHash;
            }
        }
        
    } catch (error) {
        console.error(`Display ${this.displayNumber} polling error:`, error);
        this.showError('Connection error. Retrying...');
        this.updateConnectionStatus('disconnected', 'Connection Lost');
    }
}

    async sendClickerAction(action, alertMessage) {
        try {
            if (this.autoLoopMode) {
                console.log('Manual action detected - stopping auto loop immediately');
                this.stopAutoLoop();
                this.showClickAlert('Manual Override - Auto Loop Stopped', false);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            const response = await fetch(`/station/${this.stationId}/clicker/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Clicker action result:', result);
                
                if (result.pagination_reset) {
                    console.log('Pagination was reset due to process change');
                    setTimeout(async () => {
                        console.log('Forcing media refresh after pagination reset...');
                        await this.pollForUpdates();
                    }, 300);
                }
                
                this.updateConnectionStatus('connected', 
                    `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
                
                if (result.exit_loop) {
                    this.updateLoopIndicator(false, false);
                }
                
                console.log('Manual action completed - auto loop will NOT restart automatically');
                
                if (!result.pagination_reset) {
                    setTimeout(async () => {
                        await this.pollForUpdates();
                    }, 200);
                }
                
            } else {
                this.showError(result.error || 'Clicker action failed');
                this.showClickAlert('Action Failed!', true);
                setTimeout(() => this.hideError(), 4000);
            }
        } catch (error) {
            console.error('Clicker action error:', error);
            this.showError('Clicker communication error');
            this.showClickAlert('Connection Error!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    }

    checkAutoLoopMode(data) {
        if (!data.station_info || !data.station_info.current_process) {
            this.stopAutoLoop();
            return;
        }
        
        const currentProcess = data.station_info.current_process;
        const isInLoopGroup = currentProcess.loop_group === 'final_assembly_1abc';
        const isLoopMode = data.station_info.loop_mode;
        const processChanged = this.currentProcessName !== currentProcess.name;
        
        console.log('Auto loop check:', {
            currentProcess: currentProcess.name,
            isInLoopGroup,
            isLoopMode,
            processChanged,
            autoLoopMode: this.autoLoopMode,
            previousProcess: this.currentProcessName
        });
        
        const previousProcessName = this.currentProcessName;
        this.currentProcessName = currentProcess.name;
        this.isInLoopGroup = isInLoopGroup;
        
        if (this.autoLoopMode && (!isInLoopGroup || !isLoopMode)) {
            console.log('Exiting auto loop - no longer in loop group or loop mode disabled');
            this.stopAutoLoop();
            
            if (!isInLoopGroup && previousProcessName) {
                this.showClickAlert(`Moved to ${currentProcess.display_name} - Loop Exited`, false);
            }
        }
        else if (isInLoopGroup && isLoopMode && currentProcess.name === 'PROCESS 1A OF 6') {
            if (!this.autoLoopMode || processChanged) {
                console.log('Starting auto loop - entered Process 1A');
                this.startAutoLoop(currentProcess.name);
            }
        }
        else if (isInLoopGroup && isLoopMode && this.autoLoopMode && processChanged) {
            console.log('Restarting auto loop for new process:', currentProcess.name);
            this.startAutoLoop(currentProcess.name);
        }
        else if (!isInLoopGroup || !isLoopMode) {
            if (this.autoLoopMode) {
                console.log('Stopping auto loop - conditions not met');
                this.stopAutoLoop();
            }
        }
        
        this.updateLoopIndicator(isInLoopGroup, isLoopMode);
    }

    updateLoopIndicator(isInLoopGroup, isLoopMode) {
        if (isInLoopGroup && isLoopMode && this.autoLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ AUTO LOOP ACTIVE - 1A ‚Üí 1B ‚Üí 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#27ae60';
            this.loopIndicatorElement.classList.add('auto-mode');
        } else if (isInLoopGroup && isLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ LOOP MODE (Manual) - 1A, 1B, 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#f39c12';
            this.loopIndicatorElement.classList.remove('auto-mode');
        } else {
            this.loopIndicatorElement.classList.add('hidden');
            this.loopIndicatorElement.classList.remove('auto-mode');
        }
    }

    startAutoLoop(processName) {
        console.log(`Starting auto loop mode for process: ${processName}`);
        
        this.stopAutoLoop();
        this.autoLoopMode = true;
        
        const duration = this.loopProcessDurations[processName] || 30000;
        
        console.log(`Auto loop timer set for ${duration}ms (${duration/1000}s) for ${processName}`);
        
        this.autoLoopProgressTimer = setTimeout(async () => {
            await this.autoProgressLoop();
        }, duration);
        
        this.showClickAlert(`Auto Loop: ${processName} (${duration/1000}s)`, false);
    }

    stopAutoLoop() {
        if (this.autoLoopProgressTimer) {
            clearTimeout(this.autoLoopProgressTimer);
            this.autoLoopProgressTimer = null;
            console.log('Auto loop timer cleared');
        }
        
        if (this.autoLoopTimer) {
            clearTimeout(this.autoLoopTimer);
            this.autoLoopTimer = null;
        }
        
        this.autoLoopMode = false;
        console.log('Auto loop mode stopped');
    }

    async autoProgressLoop() {
        try {
            console.log('Auto-progressing loop from:', this.currentProcessName);
            
            const response = await fetch(`/station/${this.stationId}/auto-loop-progress/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Auto loop progression successful:', result.current_process.name);
                this.showClickAlert(`Auto: ${result.current_process.display_name}`, false);
                
                setTimeout(async () => {
                    await this.pollForUpdates();
                }, 200);
                
            } else {
                console.error('Auto loop progression failed:', result.error);
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Error', true);
            }
        } catch (error) {
            console.error('Auto loop progression error:', error);
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Connection Error', true);
        }
    }

    setupKeyboardListeners() {
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowRight') {
                console.log('Manual forward key pressed');
                this.sendClickerAction('forward', 'Manual Forward ‚û§');
                event.preventDefault();
            } else if (event.code === 'ArrowLeft') {
                console.log('Manual backward key pressed');
                this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
                    if (this.displayNumber === 1) {
                        this.triggerOtherStationsReload();
                    }

                event.preventDefault();
            } else if (event.code === 'ArrowDown') {
            if (this.isCurrentlyShowingBOM()) {
                console.log('Manual BOM page navigation (down arrow) - next page');
                this.navigateBOMPage('next_page');
                setTimeout(() => { this.triggerOtherStationsReload();}, 1000);
                event.preventDefault();
            } else {
                console.log('Down arrow pressed but not on BOM slide - no action');
            }
        } else if (event.code === 'ArrowUp') {
            if (this.isCurrentlyShowingBOM()) {
                console.log('Manual BOM page navigation (up arrow) - previous page');
                
                this.navigateBOMPage('previous_page');
                event.preventDefault();
            } else {
                console.log('Up arrow pressed but not on BOM slide - no action');
            }
            } else if (event.code === 'ArrowUp') {
                if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                    console.log('Manual BOM page navigation (up arrow) - previous page');
                    this.navigateBOMPage('previous_page');
                    event.preventDefault();
                } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                    console.log('Up arrow pressed but BOM auto-pagination is active - ignoring manual input');
                    this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                    event.preventDefault();
                } else {
                    console.log('Up arrow pressed but not on BOM slide - no action');
                }
            } else if (event.code === 'Space') {
                console.log('Space pressed - toggling loop mode');
                this.sendClickerAction('toggle_loop', 'Loop Mode Toggled');
                event.preventDefault();
            } else if (event.code === 'Escape') {
                if (this.autoLoopMode) {
                    console.log('ESC pressed - stopping auto loop');
                    this.stopAutoLoop();
                    this.showClickAlert('Auto Loop Stopped (Manual)', false);
                } else if (this.pdfFullscreen) {
                    this.togglePDFFullscreen();
                }
                event.preventDefault();
            }
            else if (event.code === 'PageDown' || (event.code === 'ArrowDown' && event.ctrlKey)) {
                console.log('Page Down pressed - next BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('next_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'PageUp' || (event.code === 'ArrowUp' && event.ctrlKey)) {
                console.log('Page Up pressed - previous BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('previous_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'KeyM' && event.ctrlKey) {
                console.log('Ctrl+M pressed - toggle pagination mode');
                this.togglePaginationMode();
                event.preventDefault();
            }
        });
    }

    isCurrentBOMDurationActive() {
        if (!this.isCurrentlyShowingBOM()) return false;
        
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement) return false;
        
        const isDurationActive = currentElement.dataset.isDurationActive === 'true';
        
        console.log('Checking current BOM duration status:', {
            is_duration_active: isDurationActive,
            dataset_value: currentElement.dataset.isDurationActive,
            is_auto_pagination_active: this.isBomAutoPaginationActive
        });
        
        return isDurationActive;
    }


    async checkForBOMSyncSignal() {
    if (this.displayNumber === 1) return; // Display 1 is the controller
    
    try {
        const response = await fetch(`/station/${this.stationId}/check-bom-sync/?display_number=${this.displayNumber}`);
        
        if (response.ok) {
            const result = await response.json();
            
            if (result.success && result.should_sync) {
                const targetPage = result.sync_data.target_page;
                const totalPages = result.sync_data.total_pages;
                
                console.log(`üì• Display ${this.displayNumber}: Received sync signal - jumping to page ${targetPage}/${totalPages}`);
                
                // Directly navigate to the target page without triggering another sync
                await this.navigateToBOMPageDirectly(targetPage);
                
                this.showClickAlert(`Synced from Display 1: Page ${targetPage}/${totalPages}`, false);
            }
        }
    } catch (error) {
        console.error('Error checking BOM sync signal:', error);
    }
}


async navigateToBOMPageDirectly(targetPage) {
    // Set protection flags but shorter duration for sync
    this.isManualPaginationInProgress = true;
    this.ignoreExternalBOMUpdates = true;
    
    try {
        const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                action: 'set_page',
                page: targetPage,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });

        const result = await response.json();

        if (result.success) {
            console.log(`‚úÖ Display ${this.displayNumber}: Jumped to page ${targetPage}`);
            
            // Update BOM content
            await this.refreshBOMContent();
        }
    } catch (error) {
        console.error('Error navigating to target page:', error);
    } finally {
        setTimeout(() => {
            this.isManualPaginationInProgress = false;
            this.ignoreExternalBOMUpdates = false;
        }, 1000);
    }
}
    // CRITICAL FIX: Completely rewritten navigation method that prevents auto-refresh conflicts
// FIX 2: Enhanced navigateBOMPage with shorter cooldown for process changes
async navigateBOMPage(action) {
    // Prevent multiple simultaneous pagination calls
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Pagination already in progress or in cooldown, ignoring duplicate call');
        return;
    }
    
            // If auto pagination is active, stop it to allow manual control
        // If auto pagination is active, remember it for restart later
        let wasAutoPaginationActive = this.isBomAutoPaginationActive;
        if (this.isBomAutoPaginationActive) {
            console.log('üîÑ Manual navigation during auto pagination - will restart after');
            
            // Clear the current timer but keep the active flag
            if (this.autoBomPaginationTimer) {
                clearTimeout(this.autoBomPaginationTimer);
                this.autoBomPaginationTimer = null;
            }
            
            this.showClickAlert('Manual + Auto Mode Active', false);
        }
    
    console.log(`=== MANUAL BOM PAGINATION START: ${action} ===`);
    
    // Set STRONGER protection flags
    this.isManualPaginationInProgress = true;
    this.ignoreExternalBOMUpdates = true;
    this.manualPaginationCooldown = true;
    
    // CRITICAL: Stop ALL polling and timers immediately
    if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        console.log('üõë STOPPED polling during manual pagination');
    }
    
    try {
        // Stop ALL auto-refresh mechanisms
        this.stopAutoBomPagination();
        this.stopAllBOMRefreshTimers();
        
        console.log(`Manual BOM pagination: ${action} requested`);

        const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                action: action,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });

        const result = await response.json();

            if (result.success) {
                console.log('‚úÖ Manual BOM pagination SUCCESS:', result);

                // Update internal state IMMEDIATELY to prevent revert
                this.currentBomPage = result.current_page;
                this.currentBomTotalPages = result.pagination.total_pages;
                    // ‚≠ê ADD THIS: Trigger other displays to sync
                    if (this.displayNumber === 1) {
                        console.log('üîÑ ‚≠ê‚≠ê‚≠ê‚≠ê Triggering sync for displays 2 & 3...');
                        this.syncOtherDisplaysToBOMPage(result.current_page, result.pagination.total_pages);
                    }

                // CRITICAL: Update hash to prevent external interference
                const newBomHash = `${result.current_page}_${result.pagination.total_pages}_${this.paginationMode}_${this.itemsPerScreen}`;
                this.lastBomPaginationHash = newBomHash;

                // Show success message
                let message = `Page ${result.current_page}/${result.pagination.total_pages}`;
                if (action === 'next_page') {
                    message = `Next: ${message}`;
                } else if (action === 'previous_page') {
                    message = `Prev: ${message}`;
                }
                this.showClickAlert(message, false);

                // Find and update active BOM element WITHOUT auto-refresh
                const activeBOM = this.mediaElements.find(el => 
                    el.classList.contains('active') && el.classList.contains('bom')
                );
                
                if (activeBOM) {
                    console.log('üîÑ Updating active BOM element with new page data');
                    
                    // Create fresh media object with pagination data
                    const freshBomData = {
                        url: activeBOM.dataset.url,
                        duration: parseInt(activeBOM.dataset.duration || 30000) / 1000,
                        is_duration_active: activeBOM.dataset.isDurationActive === 'true',
                        is_bom_data: true,
                        bom_type: activeBOM.dataset.mediaType || 'BOM',
                        is_split: true,
                        bom_items: result.pagination.total_items,
                        bom_data: result.bom_data,
                        pagination: result.pagination
                    };
                    
                    // Load new content with auto-refresh DISABLED
                    await this.loadSplitBOMContent(activeBOM, freshBomData, false, true);
                    
                    console.log(`‚úÖ BOM content updated: Page ${result.current_page}/${result.pagination.total_pages}`);
                    
                    // NEW: Restart auto pagination timer if it was active before manual action
                    if (wasAutoPaginationActive) {
                        const duration = parseInt(activeBOM.dataset.duration || 30000);
                        console.log(`üîÑ Restarting auto pagination timer after manual navigation (${duration}ms)`);
                        
                        // Ensure auto pagination is still marked as active
                        this.isBomAutoPaginationActive = true;
                        this.scheduleNextBomPage(duration);
                    }
                }
            } else {
            console.error('‚ùå BOM pagination error:', result.error);
            this.showClickAlert('Pagination Error', true);
        }
    } catch (error) {
        console.error('‚ùå BOM pagination error:', error);
        this.showClickAlert('Pagination Connection Error', true);
    } finally {
        // CRITICAL: Extended protection period to prevent external interference
        setTimeout(() => {
            console.log('=== MANUAL PAGINATION COOLDOWN ENDING ===');
            this.isManualPaginationInProgress = false;
            this.manualPaginationCooldown = false;
        }, 2000); // Increased from 1000ms
        
        // Keep external updates disabled longer
     
        // CRITICAL: Restart polling after protection period
        setTimeout(() => {
            console.log('üîÑ RESTARTING polling after manual pagination');
            this.startPolling();
        }, 4000); // Restart polling after 3 seconds
    }
}


    // CRITICAL: Method to stop all BOM refresh timers
    stopAllBOMRefreshTimers() {
        console.log(`=== STOPPING ALL BOM REFRESH TIMERS for display ${this.displayNumber} ===`);
        
        this.mediaElements.forEach((element, index) => {
            if (element.refreshTimer) {
                clearTimeout(element.refreshTimer);
                element.refreshTimer = null;
                console.log(`Cleared BOM refresh timer for element ${index}`);
            }
        });
    }

    togglePaginationMode() {
        this.paginationMode = this.paginationMode === 'split' ? 'single' : 'split';
        this.showClickAlert(`Pagination Mode: ${this.paginationMode.toUpperCase()}`, false);
        
        setTimeout(async () => {
            await this.pollForUpdates();
        }, 200);
    }

    setupClickerListeners() {
        document.getElementById('forward-btn').addEventListener('click', () => {
            this.sendClickerAction('forward', 'Manual Forward ‚û§');
        });

        document.getElementById('backward-btn').addEventListener('click', () => {
            this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
        });

        const autoLoopBtn = document.getElementById('auto-loop-btn');
        if (autoLoopBtn) {
            autoLoopBtn.addEventListener('click', () => {
                this.toggleAutoLoopMode();
            });
        }
    }

    async toggleAutoLoopMode() {
        if (!this.isInLoopGroup) {
            this.showClickAlert('Auto Loop only available in processes 1A, 1B, 1C', true);
            return;
        }

        if (this.autoLoopMode) {
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Disabled', false);
        } else {
            if (this.currentProcessName) {
                this.startAutoLoop(this.currentProcessName);
            }
        }
    }

    togglePDFFullscreen() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement || !currentElement.classList.contains('pdf')) {
            this.showClickAlert('Not a PDF document', true);
            return;
        }

        this.pdfFullscreen = !this.pdfFullscreen;
        
        if (this.pdfFullscreen) {
            currentElement.classList.add('fullscreen');
            this.showClickAlert('PDF Fullscreen Mode (ESC to exit)');
        } else {
            currentElement.classList.remove('fullscreen');
            this.showClickAlert('PDF Normal Mode');
        }
    }

    showClickAlert(message, isError = false) {
        this.clickAlertElement.textContent = message;
        this.clickAlertElement.className = isError ? 'click-alert error show' : 'click-alert show';
        
        setTimeout(() => {
            this.clickAlertElement.classList.remove('show');
        }, 3000);
    }

    updateConnectionStatus(status, message) {
        this.statusElement.className = `connection-status ${status} visible`;
        this.statusElement.textContent = message;
        
        if (status === 'connected') {
            setTimeout(() => {
                this.statusElement.classList.remove('visible');
            }, 2000);
        }
    }

    updateAssemblyInfo(data, bomData) {
        if (data.station_info) {
            const station = data.station_info;
            
            if (station.current_product) {
                this.productCodeElement.textContent = station.current_product.code;
            }
            
            if (station.current_stage && station.current_process) {
                this.processInfoElement.textContent = 
                    `${station.current_stage.name} - ${station.current_process.display_name}`;
            }
            
            if (station.clicker_enabled && this.displayNumber === 2) {
                this.leftControlsElement.classList.remove('hidden');
                this.rightControlsElement.classList.remove('hidden');
            } else {
                this.leftControlsElement.classList.add('hidden');
                this.rightControlsElement.classList.add('hidden');
            }
            
            if (bomData && bomData.bom_data && this.bomStatusElement) {
                const bomType = bomData.bom_template ? bomData.bom_template.bom_type : 'Unknown';
                this.bomStatusElement.textContent = `üìã BOM: ${bomData.bom_data.length} items (${bomType})`;
                this.bomStatusElement.classList.remove('hidden');
            } else if (this.bomStatusElement) {
                this.bomStatusElement.classList.add('hidden');
            }
        }
    }

    updateMedia(data, bomData, forceUpdate = false) {
        let allMedia = [];
        
        const bomMediaItems = data.media ? data.media.filter(m => 
            m.type === 'bom' && 
            m.is_bom_data && 
            m.bom_items > 0
        ) : [];
        
        if (bomMediaItems.length > 0) {
            bomMediaItems.forEach(bomMedia => {
                allMedia.push({
                    id: bomMedia.id,
                    url: bomMedia.url,
                    type: 'bom',
                    duration: bomMedia.duration || 30,
                    is_duration_active: bomMedia.is_duration_active,
                    media_type: bomMedia.media_type || 'Paginated BOM',
                    is_bom_data: true,
                    bom_items: bomMedia.bom_items || 0,
                    bom_type: bomMedia.bom_type,
                    display_info: bomMedia.display_info,
                    is_split: bomMedia.is_split,
                    bom_data: bomMedia.bom_data,
                    pagination: bomMedia.pagination,
                    bom_hash: bomMedia.bom_hash
                });
            });
        }
        
        if (data.media && data.media.length > 0) {
            const nonBomMedia = data.media.filter(m => 
                !(m.type === 'bom' && m.is_bom_data) && 
                m.media_type !== 'Bill of Material'
            );
            
            const processedNonBomMedia = nonBomMedia.map(media => ({
                ...media,
                is_duration_active: media.is_duration_active || false
            }));
            
            allMedia = allMedia.concat(nonBomMedia);
        }
        
        if (allMedia.length === 0) {
            console.warn('No media available for display', this.displayNumber);
            this.showError(`No media available for Display ${this.displayNumber}`);
            return;
        }

        const currentUrls = this.mediaElements.map(el => el.dataset.url);
        const newUrls = allMedia.map(m => m.url);
        
        const shouldUpdate = forceUpdate || JSON.stringify(currentUrls) !== JSON.stringify(newUrls);

        if (shouldUpdate) {
            console.log('Updating paginated media elements for display', this.displayNumber, '...');
            const wasPlayingBom = this.isCurrentlyShowingBOM();
            
            this.clearCurrentMedia();
            this.createNewMediaElements(allMedia);
            
            if (wasPlayingBom && this.hasBOMElement()) {
                this.currentIndex = 0;
            }
            
            this.playCurrentMedia();
        } else {
            console.log('No paginated media update needed for display', this.displayNumber);
        }
    }

    isCurrentlyShowingBOM() {
        if (this.mediaElements.length === 0 || this.currentIndex >= this.mediaElements.length) return false;
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'));
    }

    hasBOMElement() {
        return this.mediaElements.some(el => el.dataset.mediaType === 'Database BOM' || el.classList.contains('bom'));
    }

    clearCurrentMedia() {
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
        }
        this.stopCurrentMedia();
        
        // CRITICAL: Clean up ALL BOM refresh timers before clearing elements
        this.stopAllBOMRefreshTimers();
        
        const mediaChildren = Array.from(this.containerElement.children).filter(
            child => !child.classList.contains('clicker-controls') && 
                    !child.classList.contains('error-message')
        );
        mediaChildren.forEach(child => child.remove());
        this.mediaElements = [];
        this.currentIndex = 0;
        this.pdfFullscreen = false;
    }

    createNewMediaElements(mediaData) {
        mediaData.forEach((media, index) => {
            const mediaElement = this.createMediaElement(media, index);
            if (mediaElement) {
                this.containerElement.appendChild(mediaElement);
                this.mediaElements.push(mediaElement);
            }
        });
    }

    async syncOtherDisplaysToBOMPage(page, totalPages) {
    try {
        console.log(`üì° Display ${this.displayNumber}: Broadcasting BOM page ${page}/${totalPages} to other displays`);
        
        const response = await fetch(`/station/${this.stationId}/sync-bom-pagination/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                source_display: this.displayNumber,
                target_page: page,
                total_pages: totalPages,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('‚úÖ BOM pagination sync broadcast successful');
            this.showClickAlert(`Synced: Page ${page}/${totalPages} ‚Üí All Displays`, false);
        }
    } catch (error) {
        console.error('‚ùå Error broadcasting BOM pagination sync:', error);
    }
}
    createMediaElement(media, index) {
        let element;
        let indicator;

        if (media.is_bom_data || media.type === 'bom') {
            console.log('Creating BOM element:', media);
            element = document.createElement('div');
            element.className = 'media-element bom';
            element.dataset.url = media.url;
            element.dataset.isDurationActive = media.is_duration_active || false;
            element.dataset.duration = media.duration * 1000;
            element.dataset.bomHash = media.bom_hash || '';

            let bomTypeDisplay = 'BOM';
            if (media.is_split) {
                bomTypeDisplay = 'Split BOM';
                element.dataset.mediaType = 'Split BOM';
            } else if (media.id === 'database_bom') {
                bomTypeDisplay = 'Real-time BOM';
                element.dataset.mediaType = 'Database BOM';
            } else {
                bomTypeDisplay = media.bom_type || 'BOM';
                element.dataset.mediaType = media.media_type || 'BOM';
            }
            
            console.log(`Creating BOM element for display ${this.displayNumber}:`, {
                bomType: bomTypeDisplay,
                mediaType: element.dataset.mediaType,
                url: media.url,
                is_split: media.is_split,
                bom_items: media.bom_items
            });
            
            if (media.is_split && media.bom_data) {
                console.log('Loading split BOM content');
                this.loadSplitBOMContent(element, media);
            } else {
                console.log('Loading database BOM content');
                this.loadBOMContent(element, media);
            }
            
            indicator = document.createElement('div');
            indicator.className = 'media-type-indicator bom-indicator';
            indicator.textContent = `üìã ${bomTypeDisplay}`;
            
        } else {
            const type = media.type.toLowerCase();
            
            if (['mp4', 'mov', 'webm', 'avi'].includes(type)) {
                console.log(`Creating video element ${index}:`, media.url);
                
                element = document.createElement('video');
                element.src = media.url;
                element.className = 'media-element video-optimized';
                element.controls = false;
                element.loop = false;
                element.muted = true;
                element.playsInline = true;
                
                element.preload = index === 0 ? 'metadata' : 'none';
                element.style.transform = 'translateZ(0)';
                element.style.willChange = 'opacity';
                element.style.backfaceVisibility = 'hidden';
                
                let loadTimeout;
                element.addEventListener('loadstart', () => {
                    console.log(`Video ${index} loading started`);
                    loadTimeout = setTimeout(() => {
                        console.warn(`Video ${index} load timeout - skipping`);
                    }, 10000);
                });
                
                element.addEventListener('canplay', () => {
                    console.log(`Video ${index} ready to play`);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                });
                
                element.addEventListener('ended', () => {
                    console.log(`Video ${index} ended naturally`);
                    this.switchMedia();
                });
                
                element.addEventListener('error', (e) => {
                    console.error(`Video ${index} error:`, e);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                    this.showClickAlert('Video Error - Skipping', true);
                    setTimeout(() => this.switchMedia(), 2000);
                });
                
                indicator = document.createElement('div');
                indicator.className = 'media-type-indicator video-indicator';
                indicator.textContent = 'üé• Video';
                
            } else if (type === 'pdf') {
                console.log(`Creating PDF element ${index}:`, media.url);
                element = this.createOptimizedPDFElement(media);
                
            } else {
                console.warn(`Unsupported media type: ${type}`);
                return null;
            }
        }

        if (element) {
            element.dataset.duration = media.duration * 1000;
            element.dataset.url = media.url;
            element.dataset.mediaType = element.dataset.mediaType || media.media_type;
            element.className += index === 0 ? ' active' : '';
            
            if (indicator) {
                element.appendChild(indicator);
            }
        }
        
        return element;
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

    // CRITICAL FIX: Modified loadSplitBOMContent with NO AUTO-REFRESH during manual pagination
async loadSplitBOMContent(element, media, forceResetToPage1 = false, disableAutoRefresh = false) {
    try {
        console.log(`Loading BOM content for display ${this.displayNumber}:`, {
            url: media.url,
            forceReset: forceResetToPage1,
            disableAutoRefresh: disableAutoRefresh,
            currentPagination: media.pagination,
            manualPaginationActive: this.isManualPaginationInProgress
        });

        let currentPage = 1;
        let totalPages = 1;
        
        // CRITICAL FIX: Proper pagination state handling
        if (media.pagination && !forceResetToPage1) {
            // Use pagination from media data if available and not forcing reset
            currentPage = media.pagination.current_page || 1;
            totalPages = media.pagination.total_pages || 1;
            console.log(`Using provided pagination data: Page ${currentPage}/${totalPages}`);
        } else if (!forceResetToPage1) {
            // FIXED: Get current pagination state from backend when not forcing reset
            try {
                console.log("Getting current pagination state from backend...");

                const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?t=${Date.now()}`);
                
                if (paginationResponse.ok) {
                    const paginationData = await paginationResponse.json();
                    const mediaItem = paginationData.media?.[0];

                    currentPage = mediaItem?.pagination?.current_page ?? 1;
                    totalPages = mediaItem?.pagination?.total_pages ?? 1;

                    console.log(`Display ${this.displayNumber}: Current BOM page from backend is ${currentPage}/${totalPages}`);
                } else {
                    console.log(`Display ${this.displayNumber}: Could not get pagination state, using page 1`);
                }
            } catch (paginationError) {
                console.warn(`Display ${this.displayNumber}: Error getting pagination state:`, paginationError);
            }
        }
        
        // Handle force reset to page 1
        if (forceResetToPage1 && currentPage > 1) {
            console.log(`Display ${this.displayNumber}: Force reset requested - resetting to page 1`);
            
            try {
                const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        action: 'set_page',
                        page: 1,
                        mode: this.paginationMode,
                        items_per_screen: this.itemsPerScreen
                    })
                });
                
                if (resetResponse.ok) {
                    const resetResult = await resetResponse.json();
                    if (resetResult.success) {
                        currentPage = 1;
                        console.log(`Display ${this.displayNumber}: Successfully reset to page 1`);
                    }
                }
            } catch (resetError) {
                console.warn(`Display ${this.displayNumber}: Could not reset pagination to page 1:`, resetError);
            }
        }
        
        const timestamp = new Date().getTime();
        const paginationParams = new URLSearchParams({
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // CRITICAL: Use the actual current page
            t: timestamp
        });
        
        console.log(`Loading BOM content with params:`, {
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // LOG the actual page being requested
            url: `${media.url}?${paginationParams}`,
            disableAutoRefresh: disableAutoRefresh,
            manualMode: this.isManualPaginationInProgress
        });
        
        const response = await fetch(`${media.url}?${paginationParams}`);
        
        if (response.ok) {
            const bomHTML = await response.text();
            element.innerHTML = bomHTML;
            console.log(`Paginated BOM content loaded for display ${this.displayNumber} - Page ${currentPage}/${totalPages}`);
            
            // FIXED: Update indicator with correct pagination info
            const indicator = element.querySelector('.media-type-indicator');
            if (indicator) {
                const statusText = this.isBomAutoPaginationActive ? 'Auto Paging' : 'Manual';
                indicator.textContent = `üìã ${media.bom_type || 'BOM'} (Page ${currentPage}/${totalPages} - ${statusText})`;
            }
            
            // CRITICAL: Store the current page in element for future reference
            element.dataset.currentPage = currentPage;
            element.dataset.totalPages = totalPages;
            
        } else {
            console.error(`Failed to load paginated BOM: ${response.status}`);
            element.innerHTML = `
                <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                    <div>Failed to load Paginated BOM data</div>
                    <div style="font-size: 16px; margin-top: 10px;">Status: ${response.status}</div>
                    <div style="font-size: 14px; margin-top: 10px;">URL: ${media.url}?${paginationParams}</div>
                </div>
            `;
        }
        
        // CRITICAL: NEVER set up auto-refresh if manual pagination is active or disabled
        if (!disableAutoRefresh && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
            this.setupBOMContentRefreshTimer(element, media);
        } else {
            console.log(`Auto-refresh DISABLED for display ${this.displayNumber} - manual pagination protection active`);
        }
        
    } catch (error) {
        console.error(`Error loading paginated BOM content for display ${this.displayNumber}:`, error);
        element.innerHTML = `
            <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                <div>Error loading Paginated BOM data</div>
                <div style="font-size: 16px; margin-top: 10px;">${error.message}</div>
            </div>
        `;
    }
}


    // CRITICAL: Modified refresh timer that respects manual pagination
    setupBOMContentRefreshTimer(element, media) {
        // CRITICAL: Never set up refresh timer if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
            console.log(`Skipping BOM refresh timer setup - manual pagination protection active`);
            return;
        }

        if (element.refreshTimer) {
            clearTimeout(element.refreshTimer);
            element.refreshTimer = null;
        }
        
        const isCurrentlyActive = element.classList.contains('active') && this.isCurrentlyShowingBOM();
        
        if (isCurrentlyActive) {
            console.log(`Setting up BOM refresh timer for display ${this.displayNumber} (with manual protection)`);
            
            element.refreshTimer = setTimeout(async () => {
                // Double-check protection flags before refreshing
                if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
                    console.log(`Skipping auto-refresh - manual pagination protection active`);
                    // Reschedule for later
                    this.setupBOMContentRefreshTimer(element, media);
                    return;
                }

                if (element.classList.contains('active') && this.isCurrentlyShowingBOM()) {
                    console.log(`Auto-refreshing BOM content for display ${this.displayNumber}`);
                    
                    try {
                        const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                        
                        if (response.ok) {
                            const freshData = await response.json();
                            
                            const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                                m.type === 'bom' && 
                                m.is_bom_data && 
                                m.bom_items > 0
                            ) : [];
                            
                            if (bomMediaItems.length > 0) {
                                const freshBomData = bomMediaItems.find(item => item.url === element.dataset.url) || bomMediaItems[0];

                                element.dataset.duration = (freshBomData.duration || 30) * 1000;
                                element.dataset.isDurationActive = freshBomData.is_duration_active || false;

                                // also update pagination info
                                const currentPage = freshBomData.pagination?.current_page ?? 1;
                                const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                                element.dataset.currentPage = currentPage;
                                element.dataset.totalPages  = totalPages;

                                // Refresh WITHOUT auto-refresh timer
                                await this.loadSplitBOMContent(element, freshBomData, false, true);
                                
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with fresh data`);
                            } else {
                                await this.loadSplitBOMContent(element, media, false, true);
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with existing data`);
                            }
                        } else {
                            await this.loadSplitBOMContent(element, media, false, true);
                            console.log(`BOM content auto-refreshed for display ${this.displayNumber} (fresh data fetch failed)`);
                        }
                    } catch (refreshError) {
                        console.error(`Error during BOM auto-refresh for display ${this.displayNumber}:`, refreshError);
                    }
                    
                    // Set up next refresh cycle
                    this.setupBOMContentRefreshTimer(element, media);
                } else {
                    console.log(`BOM refresh timer stopped for display ${this.displayNumber} - element no longer active`);
                }
            }, 25000); // Increased to 15 seconds to reduce conflicts
        } else {
            console.log(`No BOM refresh timer set for display ${this.displayNumber} - element not currently active`);
        }
    }

    async refreshBOMContent() {
        // Skip refresh if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
            console.log(`Skipping BOM refresh - manual pagination active`);
            
            return;
        }

        const bomElements = this.mediaElements.filter(el => 
            el.classList.contains('bom') || 
            el.dataset.mediaType === 'Paginated BOM' ||
            el.dataset.mediaType === 'Database BOM'
        );
        
        console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
        
        for (const bomElement of bomElements) {
            const mediaUrl = bomElement.dataset.url;
            if (mediaUrl) {
                console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
                
                try {
                    const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                    
                    if (response.ok) {
                        const freshData = await response.json();
                        
                        const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                            m.type === 'bom' && 
                            m.is_bom_data && 
                            m.bom_items > 0
                        ) : [];
                        
                        if (bomMediaItems.length > 0) {
                            const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                            bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                            bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                            // ‚úÖ add pagination info
                            const currentPage = freshBomData.pagination?.current_page ?? 1;
                            const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                            freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                            await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                            
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh data`);
                        } else {
                            const tempMedia = {
                                url: mediaUrl,
                                bom_type: bomElement.dataset.mediaType || 'BOM',
                                bom_items: 1,
                                pagination: { current_page: 1, total_pages: 1 }
                            };
                            
                            await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback data`);
                        }
                    } else {
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: 1, total_pages: 1 }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with temp data (API failed)`);
                    }
                } catch (error) {
                    console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
                }
            }
        }
    }

    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    createOptimizedPDFElement(media) {
        const container = document.createElement('div');
        container.className = 'media-element pdf';
        
        const iframe = document.createElement('iframe');
        
        const pdfUrl = media.url + '#toolbar=0&navpanes=0&scrollbar=0&view=FitH&zoom=page-width&page-mode=none';
        iframe.src = pdfUrl;
        iframe.className = 'pdf-iframe';
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        
        iframe.style.cssText = `
            width: 100% !important;
            height: 100% !important;
            border: none !important;
            margin: 0 !important;
            padding: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            background: white !important;
        `;
        
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'pdf-loading';
        loadingDiv.textContent = 'Loading PDF Document';
        
        const controlsDiv = this.createPDFControls();
        
        const zoomInfo = document.createElement('div');
        zoomInfo.className = 'pdf-zoom-info';
        zoomInfo.style.display = 'none';
        
        iframe.addEventListener('load', () => {
            console.log('PDF loaded successfully:', media.url);
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            zoomInfo.classList.add('visible');
            setTimeout(() => {
                zoomInfo.classList.remove('visible');
            }, 4000);
            
            this.optimizePDFZoom(iframe);
        });
        
        iframe.addEventListener('error', (e) => {
            console.error('PDF load error:', e);
            this.handlePDFError(container, media);
        });
        
        container.appendChild(iframe);
        container.appendChild(loadingDiv);
        container.appendChild(controlsDiv);
        container.appendChild(zoomInfo);
        
        return container;
    }

    optimizePDFZoom(iframe) {
        try {
            setTimeout(() => {
                const containerWidth = this.containerElement.offsetWidth;
                const containerHeight = this.containerElement.offsetHeight;
                
                console.log('PDF container dimensions:', {
                    width: containerWidth,
                    height: containerHeight,
                    screenRatio: containerWidth / containerHeight
                });
                
                if (iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        action: 'maximizeZoom',
                        containerWidth: containerWidth,
                        containerHeight: containerHeight
                    }, '*');
                }
            }, 1000);
        } catch (error) {
            console.log('Cannot access PDF iframe content (cross-origin):', error);
        }
    }

    createPDFControls() {
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'pdf-controls';
        controlsDiv.style.display = 'none';
        
        return controlsDiv;
    }

    refreshCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.classList.contains('pdf')) {
            const iframe = currentElement.querySelector('iframe');
            if (iframe) {
                const originalSrc = iframe.src;
                iframe.src = '';
                setTimeout(() => {
                    iframe.src = originalSrc + '&refresh=' + Date.now();
                    this.showClickAlert('PDF Refreshed');
                }, 100);
            }
        }
    }

    handlePDFError(pdfElement, media) {
        console.error('PDF failed to load:', media.url);
        
        const loadingDiv = pdfElement.querySelector('.pdf-loading');
        if (loadingDiv) {
            loadingDiv.remove();
        }
        
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(231, 76, 60, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            max-width: 80%;
        `;
        errorDiv.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px;">üìÑ PDF Load Error</div>
            <div style="font-size: 16px; margin-bottom: 15px;">
                Unable to display: ${media.url.split('/').pop()}
            </div>
            <div style="font-size: 14px; opacity: 0.9;">
                Check PDF file format and network connection
            </div>
        `;
        
        pdfElement.appendChild(errorDiv);
        
        setTimeout(() => {
            this.switchMedia();
        }, 8000);
    }

    async loadBOMContent(element, media) {
        try {
            console.log("Loading normal BOM content");
            const timestamp = new Date().getTime();
            const response = await fetch(`/station/${this.stationId}/bom-render-paginated/?t=${timestamp}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log('BOM content refreshed');
            } else {
                element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Failed to load BOM data</div>';
            }
        } catch (error) {
            console.error('Error loading BOM content:', error);
            element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Error loading BOM data</div>';
        }
    }

    async refreshCurrentBOMContent() {
    // Skip if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Skipping current BOM refresh - manual pagination active');
        return;
    }

    const currentElement = this.mediaElements[this.currentIndex];
    if (currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'))) {
        console.log('Refreshing current BOM content...');
        
        try {
            const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
            
            if (response.ok) {
                const freshData = await response.json();
                
                const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                    m.type === 'bom' && 
                    m.is_bom_data && 
                    m.bom_items > 0
                ) : [];
                
                if (bomMediaItems.length > 0) {
                    const freshBomData = bomMediaItems.find(item => item.url === currentElement.dataset.url) || bomMediaItems[0];

                    currentElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                    currentElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                    // CRITICAL: Use fresh pagination data from backend
                    const currentPage = freshBomData.pagination?.current_page ?? 1;
                    const totalPages = freshBomData.pagination?.total_pages ?? 1;
                    
                    // Store current pagination state
                    currentElement.dataset.currentPage = currentPage;
                    currentElement.dataset.totalPages = totalPages;
                    
                    // ENSURE pagination object exists and has correct values
                    freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                    console.log('Current BOM content refreshed with updated pagination data:', {
                        duration: currentElement.dataset.duration,
                        is_duration_active: currentElement.dataset.isDurationActive,
                        current_page: currentPage,
                        total_pages: totalPages
                    });

                    await this.loadSplitBOMContent(currentElement, freshBomData, false, true);
                } else {
                    await this.loadBOMContent(currentElement, {});
                }
            } else {
                await this.loadBOMContent(currentElement, {});
            }
        } catch (error) {
            console.error('Error refreshing current BOM with fresh data:', error);
            await this.loadBOMContent(currentElement, {});
        }
    }
}

// CRITICAL FIX: Enhanced refreshBOMContent to preserve pagination state
async refreshBOMContent() {
    // Skip refresh if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log(`Skipping BOM refresh - manual pagination active`);
        return;
    }

    const bomElements = this.mediaElements.filter(el => 
        el.classList.contains('bom') || 
        el.dataset.mediaType === 'Paginated BOM' ||
        el.dataset.mediaType === 'Database BOM'
    );
    
    console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
    
    for (const bomElement of bomElements) {
        const mediaUrl = bomElement.dataset.url;
        if (mediaUrl) {
            console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
            
            try {
                // CRITICAL: Get fresh pagination state from backend
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];
                    
                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                        bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                        bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                        // CRITICAL: Use fresh pagination data from backend
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages = freshBomData.pagination?.total_pages ?? 1;
                        
                        // ENSURE pagination object exists and has correct values
                        freshBomData.pagination = { 
                            current_page: currentPage, 
                            total_pages: totalPages 
                        };

                        console.log(`Display ${this.displayNumber}: Refreshing BOM with fresh pagination: Page ${currentPage}/${totalPages}`);

                        // Load content with correct pagination state
                        await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                        
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh pagination data`);
                    } else {
                        // Fallback with stored pagination state
                        const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                        const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                        
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: storedPage, total_pages: storedTotal }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with stored pagination data`);
                    }
                } else {
                    // Fallback with stored pagination state
                    const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                    const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                    
                    const tempMedia = {
                        url: mediaUrl,
                        bom_type: bomElement.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        pagination: { current_page: storedPage, total_pages: storedTotal }
                    };
                    
                    await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                    console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback pagination data`);
                }
            } catch (error) {
                console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
            }
        }
    }
}

    async playCurrentMedia() {
        console.log("Starting playCurrentMedia...");
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        let duration = parseInt(currentMedia.dataset.duration) || 15000;
        let isDurationActive = currentMedia.dataset.isDurationActive === 'true';
        
        if (currentMedia.classList.contains('bom')) {
            try {
                console.log('BOM detected - fetching fresh duration data from server...');
                
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];

                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === currentMedia.dataset.url) || bomMediaItems[0];
                        
                        duration = (freshBomData.duration || 30) * 1000;
                        isDurationActive = freshBomData.is_duration_active || false;
                        
                        currentMedia.dataset.duration = duration;
                        currentMedia.dataset.isDurationActive = isDurationActive;

                        // ‚úÖ normalize pagination
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                        freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                        console.log('Fresh BOM duration + pagination data retrieved and updated', {
                            duration,
                            isDurationActive,
                            currentPage,
                            totalPages
                        });
                        
                        // Only set up refresh timer if NOT in manual mode
                        if (!this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                            this.setupBOMContentRefreshTimer(currentMedia, freshBomData);
                        }
                    }

                }
            } catch (error) {
                console.error('Error fetching fresh duration data:', error);
            }
        }

        if (currentMedia.tagName === 'VIDEO') {
            console.log('Playing video with optimizations...');
            
            if (!currentMedia.paused && currentMedia.currentTime > 0) {
                console.log('Video is already playing, not restarting');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                return;
            }
            
            try {
                if (currentMedia.preload === 'none') {
                    console.log('Loading video on-demand...');
                    currentMedia.preload = 'metadata';
                    currentMedia.load();
                }
                
                const videoReady = await Promise.race([
                    new Promise((resolve) => {
                        if (currentMedia.readyState >= 3) {
                            resolve(true);
                        } else {
                            const checkReady = () => {
                                if (currentMedia.readyState >= 3) {
                                    resolve(true);
                                } else {
                                    setTimeout(checkReady, 200);
                                }
                            };
                            checkReady();
                        }
                    }),
                    new Promise((resolve) => {
                        setTimeout(() => resolve(false), 5000);
                    })
                ]);
                
                if (!videoReady) {
                    console.warn('Video not ready after timeout, trying anyway...');
                }
                
                await currentMedia.play();
                console.log('Video playing successfully');
                
                this.preloadNextVideo();
                
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                
            } catch (error) {
                console.error('Video play error:', error.message);
                
                try {
                    currentMedia.muted = true;
                    await currentMedia.play();
                    console.log('Video playing with muted fallback');
                    this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                } catch (mutedError) {
                    console.error('All video playback failed, skipping...');
                    setTimeout(() => this.switchMedia(), 1000);
                }
            }
            
        } else if (currentMedia.classList.contains('pdf')) {
            console.log(`Displaying PDF: ${currentMedia.dataset.url}`);
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            
        } else if (currentMedia.classList.contains('bom')) {
            console.log('Displaying BOM with duration info');
            
            this.stopAutoBomPagination();

            if (isDurationActive) {
                console.log('BOM duration IS active - starting auto pagination');
                this.startAutoBomPagination(duration);
            } else {
                console.log('BOM duration is NOT active - will stay until manual advance');
                this.isBomAutoPaginationActive = false;
                this.stopAutoBomPagination();
                
                // Only set up refresh timer if NOT in manual mode
                if (!currentMedia.refreshTimer && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                    const tempMedia = {
                        url: currentMedia.dataset.url,
                        bom_type: currentMedia.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        duration: duration / 1000,
                        is_duration_active: isDurationActive
                    };
                    this.setupBOMContentRefreshTimer(currentMedia, tempMedia);
                }
            }

        } else {
            console.log('Displaying other media type');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

async startAutoBomPagination(duration) {
    this.stopAutoBomPagination(); // This will now properly clear the timer
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;
            
            this.currentBomTotalPages = totalPages;
            
            console.log(`Starting auto BOM pagination: Page ${currentPage}/${totalPages}, Duration: ${duration}ms`);
            
            if (totalPages > 1) {
                this.isBomAutoPaginationActive = true;
                this.scheduleNextBomPage(duration);
                this.showClickAlert(`Auto BOM: Page ${currentPage}/${totalPages} (${duration/1000}s)`, false);
            } else {
                console.log('BOM has only 1 page, no auto pagination needed');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('Failed to get BOM pagination info');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    } catch (error) {
        console.error('Error starting auto BOM pagination:', error);
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

scheduleNextBomPage(duration) {
    console.log(`üîÑ Scheduling next BOM page in ${duration}ms`);
    
    // FIXED: Clear the correct timer variable
    if (this.autoBomPaginationTimer) {
        console.log(`üîÑ Clearing existing auto BOM pagination timer`);
        clearTimeout(this.autoBomPaginationTimer);
    }
    
    // Only schedule if auto pagination is still active
    if (!this.isBomAutoPaginationActive) {
        console.log('üö´ Auto pagination no longer active, not scheduling');
        return;
    }
    
    // FIXED: Use consistent variable name
    this.autoBomPaginationTimer = setTimeout(() => {
        console.log(`‚è∞ Auto BOM pagination timer fired after ${duration}ms`);
        this.advanceAutoBomPage(duration);
    }, duration);
    
    console.log(`üîÑ Auto BOM pagination timer set with ID: ${this.autoBomPaginationTimer}`);
}

async advanceAutoBomPage(duration) {
    if (!this.isBomAutoPaginationActive) {
        console.log('üö´ Auto BOM pagination not active, skipping advance');
        return;
    }
    
    console.log(`üîÑ Advancing auto BOM page with duration: ${duration}ms`);
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;

            console.log(`üîÑ Auto BOM pagination: Currently on page ${currentPage}/${totalPages}`);
            
            let nextAction;
            let nextPage;
            
            if (currentPage < totalPages) {
                nextAction = 'next_page';
                nextPage = currentPage + 1;
                console.log(`üìÑ Moving to next page: ${nextPage}`);
            } else {
                // CRITICAL FIX: Reset to page 1 before completing cycle
                console.log(`üîÑ Completed full BOM cycle (page ${currentPage}/${totalPages}), resetting to page 1 for next cycle`);
                
                try {
                    // Reset pagination to page 1
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log(`‚úÖ Successfully reset BOM pagination to page 1 for next cycle`);
                            
                            // Update pagination state immediately
                            this.currentBomPage = 1;
                            
                            // Refresh BOM content to show page 1
                            await this.refreshBOMContent();
                            
                            console.log(`üîÑ BOM content refreshed to page 1, cycle complete`);
                        }
                    }
                } catch (resetError) {
                    console.error('‚ùå Error resetting BOM pagination to page 1:', resetError);
                }
                
                // Now move to next media after reset
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), 1000);
                return;
            }

            console.log(`üîÑ Auto BOM pagination: Moving from page ${currentPage} to page ${nextPage}`);
            
            const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    action: nextAction,
                    page: nextPage,
                    mode: this.paginationMode,
                    items_per_screen: this.itemsPerScreen
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Update the current page state
                this.currentBomPage = result.current_page;
                
                console.log(`‚úÖ Auto BOM pagination successful: Page ${result.current_page}/${result.pagination.total_pages}`);
                
                this.showClickAlert(`Auto: Page ${result.current_page}/${result.pagination.total_pages}`, false);
                
                // Always refresh BOM content after pagination change
                await this.refreshBOMContent();
                
                // Continue to next page with same duration
                this.scheduleNextBomPage(duration);
                
            } else {
                console.error('‚ùå Auto BOM pagination failed:', result.error);
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('‚ùå Failed to get current BOM pagination state');
            this.stopAutoBomPagination();
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
        
    } catch (error) {
        console.error('‚ùå Error in auto BOM pagination:', error);
        this.stopAutoBomPagination();
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}
stopAutoBomPagination() {
    // FIXED: Use the correct timer variable name
    if (this.autoBomPaginationTimer) {
        clearTimeout(this.autoBomPaginationTimer);
        this.autoBomPaginationTimer = null;
        console.log('Auto BOM pagination timer cleared');
    }
    this.isBomAutoPaginationActive = false;
    console.log('Auto BOM pagination stopped');
}

    isCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && currentElement.classList.contains('pdf');
    }

    stopCurrentMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        if (currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (currentMedia.classList.contains('pdf')) {
            currentMedia.classList.remove('fullscreen');
            this.pdfFullscreen = false;
        }
        
        if (currentMedia.classList.contains('bom')) {
            this.stopAutoBomPagination();
        }
        clearTimeout(this.slideshowTimer);
    }

    switchMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (currentMedia && currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (this.mediaElements.length === 1) {
            if (this.isCurrentlyShowingBOM()) {
                this.refreshCurrentBOMContent();
            }
            this.stopCurrentMedia();
            this.playCurrentMedia();
            return;
        }

        if (currentMedia) {
            currentMedia.classList.add('fade-out');
            currentMedia.classList.remove('active');
        }
        
        this.stopCurrentMedia();
        this.currentIndex = (this.currentIndex + 1) % this.mediaElements.length;
        
        const nextMedia = this.mediaElements[this.currentIndex];
        if (nextMedia) {
            nextMedia.classList.remove('fade-out');
            nextMedia.classList.add('active');
            
            if (nextMedia.dataset.mediaType === 'Database BOM' || nextMedia.classList.contains('bom')) {
                this.loadBOMContent(nextMedia, {});
            }
            
            this.playCurrentMedia();
        }
    }

    handleMediaError(error) {
        console.error('Media error:', error);
        this.showError('Media playback error');
        setTimeout(() => this.switchMedia(), 3000);
    }

    showError(message) {
        this.errorElement.textContent = message;
        this.errorElement.classList.remove('hidden');
    }

    hideError() {
        this.errorElement.classList.add('hidden');
    }

    setAutoLoopDurations(durations) {
        this.loopProcessDurations = { ...this.loopProcessDurations, ...durations };
        console.log('Auto loop durations updated:', this.loopProcessDurations);
    }

    getAutoLoopStatus() {
        return {
            autoLoopMode: this.autoLoopMode,
            isInLoopGroup: this.isInLoopGroup,
            currentProcessName: this.currentProcessName,
            loopProcessDurations: this.loopProcessDurations,
            timeRemaining: this.autoLoopProgressTimer ? 'active' : 'inactive'
        };
    }

    async forceAutoLoopProgress() {
        if (this.autoLoopMode) {
            await this.autoProgressLoop();
        } else {
            console.warn('Auto loop is not active');
        }
    }

    destroy() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
            this.slideshowTimer = null;
        }
        
        this.stopAllBOMRefreshTimers();
        this.stopAutoBomPagination();
        this.stopAutoLoop();
        this.stopCurrentMedia();
        
        console.log(`BRG Media Slider Display ${this.displayNumber} destroyed`);
    }
}

// Initialize the enhanced slider when page loads
document.addEventListener('DOMContentLoaded', () => {
    const stationId = {{ station.id }};
    const displayNumber = {{ station.display_number }};
    
    window.mediaSlider = new BRGMediaSliderWithAutoLoop(stationId, displayNumber);
    
    // Add global keyboard shortcuts for debugging
    document.addEventListener('keydown', (event) => {
        if (event.ctrlKey && event.shiftKey) {
            switch(event.code) {
                case 'KeyA':
                    if (window.mediaSlider) {
                        window.mediaSlider.toggleAutoLoopMode();
                    }
                    event.preventDefault();
                    break;
                case 'KeyS':
                    if (window.mediaSlider) {
                        const status = window.mediaSlider.getAutoLoopStatus();
                        console.log('Auto Loop Status:', status);
                        window.mediaSlider.showClickAlert(`Auto Loop: ${status.autoLoopMode ? 'ON' : 'OFF'}`, false);
                    }
                    event.preventDefault();
                    break;
                case 'KeyF':
                    if (window.mediaSlider) {
                        window.mediaSlider.forceAutoLoopProgress();
                    }
                    event.preventDefault();
                    break;
            }
        }
    });
});

window.addEventListener('beforeunload', () => {
    if (window.mediaSlider) {
        window.mediaSlider.destroy();
    }
});

window.getSliderStatus = () => {
    if (window.mediaSlider) {
        return {
            displayNumber: window.mediaSlider.displayNumber,
            currentIndex: window.mediaSlider.currentIndex,
            mediaCount: window.mediaSlider.mediaElements.length,
            autoLoopStatus: window.mediaSlider.getAutoLoopStatus(),
            currentProcessName: window.mediaSlider.currentProcessName,
            isInLoopGroup: window.mediaSlider.isInLoopGroup,
            manualPaginationActive: window.mediaSlider.isManualPaginationInProgress,
            ignoreExternalUpdates: window.mediaSlider.ignoreExternalBOMUpdates,
            manualCooldown: window.mediaSlider.manualPaginationCooldown
        };
    }
    return null;
};
</script>
</body>
</html>
