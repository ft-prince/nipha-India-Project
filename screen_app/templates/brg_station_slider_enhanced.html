<!-- templates/brg_station_slider_enhanced.html - OPTIMIZED FOR LARGE ROTATED DISPLAYS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRG Assembly 40K - Display {{ station.display_number }}</title>
    <style>

body, html {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background-color: #ffffff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* ENHANCED: Better rotation for portrait monitors */
body {
    transform: rotate(90deg);
    transform-origin: center center;
    width: 100vh;
    height: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    margin-top: -50vw;
    margin-left: -50vh;
    background-color: #ffffff;
}

.main-container {
    display: flex;
    flex-direction: column;
    height: 100vw;
    width: 100vh;
    position: relative;
}

/* COMPACT: Reduced header height to maximize content area */
.assembly-header {
    background: linear-gradient(135deg, #2c3e50, #3498db);
    color: white;
    padding: 12px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 60px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    flex-shrink: 0;
}

.product-info {
    display: flex;
    flex-direction: column;
}

.product-code {
    font-size: 28px;
    font-weight: bold;
    margin-bottom: 8px;
}

.process-info {
    font-size: 18px;
    opacity: 0.9;
}

.display-badge {
    background: rgba(255,255,255,0.2);
    padding: 12px 20px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 20px;
}

.display-1 { border-left: 5px solid #FF6B6B; }
.display-2 { border-left: 5px solid #4ECDC4; }
.display-3 { border-left: 5px solid #45B7D1; }

/* ENHANCED: Media slider with better flex management */
.slider-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: black;
    overflow: hidden;
    min-height: 0; /* Important for flex children */
}

.media-element {
    height: 100%;
    width: 100%;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: contain;
    transition: opacity 0.5s ease-in-out;
}

/* COMPLETELY REWRITTEN: PDF styling for large rotated displays */
.media-element.pdf {
    /* MAXIMIZED: Use every pixel available */
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    
    /* ENHANCED: Better PDF rendering */
    object-fit: fill;
    border: none;
    background-color: white;
    
    /* CRITICAL: Force PDF to use full space */
    box-sizing: border-box;
    
    /* ENHANCED: High quality rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    
    /* REMOVE: Any margins or padding that might interfere */
    margin: 0 !important;
    padding: 0 !important;
    
    /* ENSURE: PDF is displayed with maximum zoom */
    zoom: 1;
}

/* ALTERNATIVE: PDF iframe for better control */
.media-element.pdf-iframe {
    width: 100% !important;
    height: 100% !important;
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    border: none;
    background-color: white;
    overflow: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* ENHANCED: PDF controls with better visibility */
.pdf-controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 150;
    display: flex;
    gap: 15px;
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.pdf-controls:hover {
    opacity: 1;
}

.pdf-control-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.pdf-control-btn:hover {
    background: rgba(0,0,0,1);
    transform: scale(1.1);
}

/* ENHANCED: Fullscreen PDF mode */
.media-element.pdf.fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    z-index: 1000;
    background: white;
    position: fixed !important;
}

.media-element.bom {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
}

.media-element.active {
    display: block;
    opacity: 1;
}

.media-element.fade-out {
    opacity: 0;
}

/* ENHANCED: Better clicker controls for large screens */
.clicker-controls {
    position: absolute;
    bottom: 30px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.clicker-left {
    left: 30px;
}

.clicker-right {
    right: 30px;
}

.clicker-btn {
    background: rgba(52, 152, 219, 0.9);
    border: none;
    border-radius: 50%;
    width: 90px;
    height: 90px;
    color: white;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
}

.clicker-btn:hover {
    background: rgba(52, 152, 219, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.clicker-btn:active {
    transform: scale(0.95);
    background: rgba(41, 128, 185, 1);
}

.clicker-hint {
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    margin-top: 8px;
    white-space: nowrap;
}

.clicker-controls.hidden {
    display: none;
}

/* Enhanced click feedback */
.click-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(46, 204, 113, 0.95);
    color: white;
    padding: 25px 50px;
    border-radius: 30px;
    font-size: 22px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
    transition: all 0.3s ease;
}

.click-alert.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.click-alert.error {
    background: rgba(231, 76, 60, 0.95);
}

/* COMPACT: Reduced status bar height to reclaim space */
.status-bar {
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 8px 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 35px;
    gap: 40px;
    flex-shrink: 0;
    font-size: 14px;
}

.loop-indicator {
    background: #f39c12;
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 2s infinite;
}

.loop-indicator.hidden {
    display: none;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.connection-status {
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.connection-status.visible { opacity: 1; }
.connection-status.connected { background-color: #27ae60; color: white; }
.connection-status.disconnected { background-color: #e74c3c; color: white; }
.connection-status.reconnecting { background-color: #f39c12; color: white; }

/* Navigation hints */
.navigation-hints {
    background: rgba(52, 152, 219, 0.2);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.navigation-hints.hidden {
    display: none;
}

/* ENHANCED: Media type indicators */
.media-type-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    backdrop-filter: blur(5px);
}

.bom-indicator { background: rgba(52, 152, 219, 0.8); }
.video-indicator { background: rgba(231, 76, 60, 0.8); }
.doc-indicator { 
    background: rgba(46, 204, 113, 0.8);
    font-size: 18px;
    padding: 15px 25px;
}

/* Error states */
.error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    font-size: 20px;
    z-index: 1000;
}

.error-message.hidden {
    display: none;
}

/* BOM indicator in status bar */
.bom-status {
    background: rgba(52, 152, 219, 0.8);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
}

/* CRITICAL: Responsive scaling for different large monitor sizes */
@media screen and (min-width: 1920px) {
    .product-code { font-size: 32px; }
    .process-info { font-size: 20px; }
    .display-badge { font-size: 22px; padding: 15px 25px; }
    .assembly-header { padding: 15px 30px; min-height: 70px; }
    .status-bar { padding: 10px 30px; font-size: 16px; min-height: 40px; }
    
    .media-element.pdf {
        /* FORCE: Maximum utilization on large screens */
        width: 100% !important;
        height: 100% !important;
    }
}

@media screen and (min-width: 2560px) {
    .product-code { font-size: 36px; }
    .process-info { font-size: 22px; }
    .display-badge { font-size: 24px; padding: 18px 30px; }
    .assembly-header { padding: 18px 35px; min-height: 80px; }
    .status-bar { padding: 12px 35px; font-size: 18px; min-height: 45px; }
    
    .pdf-control-btn { width: 70px; height: 70px; font-size: 24px; }
    .clicker-btn { width: 100px; height: 100px; font-size: 32px; }
    
    .media-type-indicator { font-size: 18px; padding: 15px 25px; }
    .doc-indicator { font-size: 20px; padding: 18px 30px; }
}

@media screen and (min-width: 3440px) {
    .product-code { font-size: 40px; }
    .process-info { font-size: 24px; }
    .display-badge { font-size: 26px; padding: 20px 35px; }
    .assembly-header { padding: 22px 40px; min-height: 90px; }
    .status-bar { padding: 15px 40px; font-size: 20px; min-height: 50px; }
    
    .pdf-control-btn { width: 80px; height: 80px; font-size: 28px; }
    .clicker-btn { width: 110px; height: 110px; font-size: 36px; }
    
    .media-type-indicator { font-size: 20px; padding: 18px 30px; }
    .doc-indicator { font-size: 24px; padding: 20px 35px; }
}

/* ULTRA-WIDE: 4K and above optimizations */
@media screen and (min-width: 4096px) {
    .product-code { font-size: 44px; }
    .process-info { font-size: 26px; }
    .display-badge { font-size: 28px; padding: 25px 40px; }
    .assembly-header { padding: 25px 45px; min-height: 100px; }
    .status-bar { padding: 18px 45px; font-size: 22px; min-height: 55px; }
    
    .pdf-control-btn { width: 90px; height: 90px; font-size: 32px; }
    .clicker-btn { width: 120px; height: 120px; font-size: 40px; }
    
    .media-type-indicator { font-size: 22px; padding: 20px 35px; }
    .doc-indicator { font-size: 26px; padding: 25px 40px; }
}

/* PDF LOADING INDICATOR */
.pdf-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #333;
    font-size: 24px;
    z-index: 50;
    background: rgba(255, 255, 255, 0.9);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.pdf-loading::after {
    content: "...";
    animation: dots 2s infinite;
}

@keyframes dots {
    0%, 20% { content: ""; }
    40% { content: "."; }
    60% { content: ".."; }
    80%, 100% { content: "..."; }
}

/* ZOOM ENHANCEMENT: Better PDF zoom controls */
.pdf-zoom-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 120;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pdf-zoom-info.visible {
    opacity: 1;
}

/* DEBUG: Temporary border to see PDF boundaries (remove in production) */
.media-element.pdf.debug {
    border: 3px solid red !important;
}

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Assembly Header -->
        <div class="assembly-header display-{{ station.display_number }}">
            <div class="product-info">
                <div class="product-code" id="product-code">
                    {% if current_product %}{{ current_product.code }}{% else %}No Product Selected{% endif %}
                </div>
                <div class="process-info" id="process-info">
                    {% if current_process %}
                        {{ current_stage.display_name }} - {{ current_process.display_name }}
                    {% else %}
                        No Process Selected
                    {% endif %}
                </div>
            </div>
            <div class="display-badge">
                Display {{ station.display_number }}
                <div style="font-size: 14px; margin-top: 3px;">
                    {% if station.display_number == 1 %}BOMs & Reference
                    {% elif station.display_number == 2 %}Process Instructions  
                    {% else %}Instructional Videos{% endif %}
                </div>
            </div>
        </div>

        <!-- Media Slider -->
        <div class="slider-container" id="slider-container">
            <!-- Left Clicker Controls -->
            <div class="clicker-controls clicker-left {% if not clicker_enabled %}hidden{% endif %}" id="left-controls">
                <button class="clicker-btn" id="backward-btn" title="Previous Process">
                    &#8592;
                </button>
                <div class="clicker-hint">‚Üê Previous</div>
            </div>

            <!-- Right Clicker Controls -->
            <div class="clicker-controls clicker-right {% if not clicker_enabled %}hidden{% endif %}" id="right-controls">
                <button class="clicker-btn" id="forward-btn" title="Next Process">
                    &#8594;
                </button>
                <div class="clicker-hint">Next ‚Üí</div>
            </div>

            <div class="error-message hidden" id="error-message">
                <div>‚ö†Ô∏è Connection Error</div>
                <div style="font-size: 16px; margin-top: 15px;">
                    Please check network connection or contact supervisor
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            {% if has_bom_data %}
            <div class="bom-status" id="bom-status">
                üìã BOM: {{ bom_item_count }} items
            </div>
            {% endif %}
            
            <div class="loop-indicator {% if not loop_mode %}hidden{% endif %}" id="loop-indicator">
                üîÑ LOOP MODE - Processes 1A, 1B, 1C
            </div>
            <div id="connection-status" class="connection-status">Connecting...</div>
        </div>

        <!-- Click Feedback Alert -->
        <div class="click-alert" id="click-alert">
            Action Completed!
        </div>
    </div>

<script>
// Enhanced BRG Media Slider optimized for large rotated displays
class BRGMediaSliderWithBOM {
    constructor(stationId, displayNumber) {
        this.stationId = stationId;
        this.displayNumber = displayNumber;
        this.currentIndex = 0;
        this.mediaElements = [];
        this.slideshowTimer = null;
        this.pollingInterval = null;
        this.pollingDelay = 2000;
        this.lastDataHash = null;
        this.lastBomHash = null;
        this.pdfFullscreen = false;
        this.currentPdfZoom = 1.0;
        
        // DOM elements
        this.containerElement = document.getElementById('slider-container');
        this.statusElement = document.getElementById('connection-status');
        this.errorElement = document.getElementById('error-message');
        this.productCodeElement = document.getElementById('product-code');
        this.processInfoElement = document.getElementById('process-info');
        this.loopIndicatorElement = document.getElementById('loop-indicator');
        this.leftControlsElement = document.getElementById('left-controls');
        this.rightControlsElement = document.getElementById('right-controls');
        this.clickAlertElement = document.getElementById('click-alert');
        this.bomStatusElement = document.getElementById('bom-status');
        
        this.startPolling();
        this.setupKeyboardListeners();
        this.setupClickerListeners();
        
        // Log screen information for debugging
        this.logScreenInfo();
    }

    logScreenInfo() {
        console.log('Screen Information:', {
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            screenWidth: screen.width,
            screenHeight: screen.height,
            devicePixelRatio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.angle : 'unknown'
        });
    }

    async startPolling() {
        await this.pollForUpdates();
        this.pollingInterval = setInterval(async () => {
            await this.pollForUpdates();
        }, this.pollingDelay);
    }

    async pollForUpdates() {
        try {
            // Get regular media data
            const mediaResponse = await fetch(`/station/${this.stationId}/media/`);
            if (!mediaResponse.ok) {
                throw new Error(`HTTP ${mediaResponse.status}`);
            }
            const mediaData = await mediaResponse.json();
            
            // Get BOM data separately for real-time updates
            let bomData = null;
            if (this.displayNumber === 1) {
                try {
                    const bomResponse = await fetch(`/station/api/station/${this.stationId}/bom-data/`);
                    if (bomResponse.ok) {
                        bomData = await bomResponse.json();
                    }
                } catch (bomError) {
                    console.log('No BOM data available:', bomError);
                }
            }
            
            // Create separate hashes for media and BOM to track changes independently
            const mediaHash = JSON.stringify({
                media: mediaData.media ? mediaData.media.map(m => ({ 
                    id: m.id, 
                    url: m.url, 
                    type: m.type
                })) : [],
                station: mediaData.station_info
            });
            
            const bomHash = bomData ? JSON.stringify({
                items: bomData.bom_data.map(item => ({
                    serial: item.serial_number,
                    code: item.item_code,
                    quantity: item.calculated_quantity
                })),
                template: bomData.bom_template,
                stage: bomData.station_info.current_stage,
                quantity: bomData.station_info.quantity
            }) : null;
            
            // Check if anything changed
            const mediaChanged = mediaHash !== this.lastDataHash;
            const bomChanged = bomHash !== this.lastBomHash;
            
            if (mediaChanged || bomChanged) {
                console.log('Update detected:', { mediaChanged, bomChanged });
                
                this.updateAssemblyInfo(mediaData, bomData);
                this.updateMedia(mediaData, bomData, bomChanged);
                
                this.hideError();
                this.updateConnectionStatus('connected', 'Updated');
                
                // Update hashes
                this.lastDataHash = mediaHash;
                this.lastBomHash = bomHash;
            }
            
        } catch (error) {
            console.error('Polling error:', error);
            this.showError('Connection error. Retrying...');
            this.updateConnectionStatus('disconnected', 'Connection Lost');
        }
    }

    setupKeyboardListeners() {
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowRight') {
                this.sendClickerAction('forward', 'Forward ‚û§');
                event.preventDefault();
            } else if (event.code === 'ArrowLeft') {
                this.sendClickerAction('backward', 'Backward ‚óÄ');
                event.preventDefault();
            }
        });
    }

    setupClickerListeners() {
        document.getElementById('forward-btn').addEventListener('click', () => {
            this.sendClickerAction('forward', 'Forward ‚û§');
        });

        document.getElementById('backward-btn').addEventListener('click', () => {
            this.sendClickerAction('backward', 'Backward ‚óÄ');
        });
    }

    // ENHANCED: Better PDF fullscreen toggle
    togglePDFFullscreen() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement || !currentElement.classList.contains('pdf')) {
            this.showClickAlert('Not a PDF document', true);
            return;
        }

        this.pdfFullscreen = !this.pdfFullscreen;
        
        if (this.pdfFullscreen) {
            currentElement.classList.add('fullscreen');
            this.showClickAlert('PDF Fullscreen Mode (ESC to exit)');
            console.log('PDF in fullscreen mode');
        } else {
            currentElement.classList.remove('fullscreen');
            this.showClickAlert('PDF Normal Mode');
            console.log('PDF in normal mode');
        }
    }

    // DEBUG: Toggle debug borders on PDFs
    togglePDFDebug() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.classList.contains('pdf')) {
            currentElement.classList.toggle('debug');
            this.showClickAlert('PDF Debug Mode Toggled');
        }
    }

    showClickAlert(message, isError = false) {
        this.clickAlertElement.textContent = message;
        this.clickAlertElement.className = isError ? 'click-alert error show' : 'click-alert show';
        
        setTimeout(() => {
            this.clickAlertElement.classList.remove('show');
        }, 3000);
    }

    updateConnectionStatus(status, message) {
        this.statusElement.className = `connection-status ${status} visible`;
        this.statusElement.textContent = message;
        
        if (status === 'connected') {
            setTimeout(() => {
                this.statusElement.classList.remove('visible');
            }, 2000);
        }
    }

    updateAssemblyInfo(data, bomData) {
        if (data.station_info) {
            const station = data.station_info;
            
            if (station.current_product) {
                this.productCodeElement.textContent = station.current_product.code;
            }
            
            if (station.current_stage && station.current_process) {
                this.processInfoElement.textContent = 
                    `${station.current_stage.name} - ${station.current_process.display_name}`;
            }
            
            // Remove quantity info element reference since it no longer exists
            
            if (station.loop_mode) {
                this.loopIndicatorElement.classList.remove('hidden');
            } else {
                this.loopIndicatorElement.classList.add('hidden');
            }
            
            if (station.clicker_enabled) {
                this.leftControlsElement.classList.remove('hidden');
                this.rightControlsElement.classList.remove('hidden');
            } else {
                this.leftControlsElement.classList.add('hidden');
                this.rightControlsElement.classList.add('hidden');
            }
            
            // Update BOM status for Display 1
            if (bomData && bomData.bom_data && this.bomStatusElement) {
                const bomType = bomData.bom_template ? bomData.bom_template.bom_type : 'Unknown';
                this.bomStatusElement.textContent = `üìã BOM: ${bomData.bom_data.length} items (${bomType})`;
                this.bomStatusElement.classList.remove('hidden');
            } else if (this.bomStatusElement) {
                this.bomStatusElement.classList.add('hidden');
            }
        }
    }

    updateMedia(data, bomData, forceUpdate = false) {
        // Combine regular media with BOM data for Display 1
        let allMedia = [];
        
        // Add BOM as first item for Display 1 if available
        if (this.displayNumber === 1 && bomData && bomData.bom_data && bomData.bom_data.length > 0) {
            allMedia.push({
                id: 'database_bom',
                url: `/station/${this.stationId}/bom-render/`,
                type: 'bom',
                duration: 30,
                media_type: 'Database BOM',
                is_bom_data: true,
                bom_items: bomData.bom_data.length,
                bom_hash: this.lastBomHash
            });
        }
        
        // Add regular media (videos, documents - no PDF BOMs)
        if (data.media && data.media.length > 0) {
            allMedia = allMedia.concat(data.media.filter(m => m.media_type !== 'Bill of Material'));
        }
        
        if (allMedia.length === 0) {
            this.showError('No media available for current configuration');
            return;
        }

        const currentUrls = this.mediaElements.map(el => el.dataset.url);
        const newUrls = allMedia.map(m => m.url);
        
        // Force update if BOM changed or media changed
        const shouldUpdate = forceUpdate || JSON.stringify(currentUrls) !== JSON.stringify(newUrls);

        if (shouldUpdate) {
            console.log('Updating media elements...');
            const wasPlayingBom = this.isCurrentlyShowingBOM();
            
            this.clearCurrentMedia();
            this.createNewMediaElements(allMedia);
            
            // If we were showing BOM and BOM changed, stay on BOM
            if (wasPlayingBom && this.hasBOMElement()) {
                this.currentIndex = 0; // BOM is always first
            }
            
            this.playCurrentMedia();
        }
    }

    isCurrentlyShowingBOM() {
        if (this.mediaElements.length === 0 || this.currentIndex >= this.mediaElements.length) return false;
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && currentElement.dataset.mediaType === 'Database BOM';
    }

    hasBOMElement() {
        return this.mediaElements.some(el => el.dataset.mediaType === 'Database BOM');
    }

    clearCurrentMedia() {
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
        }
        this.stopCurrentMedia();
        
        const mediaChildren = Array.from(this.containerElement.children).filter(
            child => !child.classList.contains('clicker-controls') && 
                     !child.classList.contains('error-message')
        );
        mediaChildren.forEach(child => child.remove());
        this.mediaElements = [];
        this.currentIndex = 0;
        this.pdfFullscreen = false;
    }

    createNewMediaElements(mediaData) {
        mediaData.forEach((media, index) => {
            const mediaElement = this.createMediaElement(media, index);
            if (mediaElement) {
                this.containerElement.appendChild(mediaElement);
                this.mediaElements.push(mediaElement);
            }
        });
    }

    createMediaElement(media, index) {
        let element;
        let indicator;

        if (media.is_bom_data || media.type === 'bom') {
            // Create Database BOM element
            element = document.createElement('div');
            element.className = 'media-element bom';
            element.dataset.url = media.url;
            element.dataset.duration = media.duration * 1000;
            element.dataset.mediaType = 'Database BOM';
            element.dataset.bomHash = media.bom_hash || '';
            
            // Load BOM content via fetch
            this.loadBOMContent(element, media);
            
            indicator = document.createElement('div');
            indicator.className = 'media-type-indicator bom-indicator';
            indicator.textContent = 'üìã Real-time BOM';
            
        } else {
            const type = media.type.toLowerCase();
            
            if (['mp4', 'mov'].includes(type)) {
                element = document.createElement('video');
                element.src = media.url;
                element.className = 'media-element';
                element.controls = false;
                element.loop = false;
                element.muted = true;
                element.playsInline = true;
                element.addEventListener('ended', () => this.switchMedia());
                element.addEventListener('error', (e) => this.handleMediaError(e));
                
                indicator = document.createElement('div');
                indicator.className = 'media-type-indicator video-indicator';
                indicator.textContent = 'üé• Video';
                
            } else if (type === 'pdf') {
                // CRITICAL: Enhanced PDF handling for large rotated displays
                element = this.createOptimizedPDFElement(media);
                
                indicator = document.createElement('div');

                
            } else {
                console.warn(`Unsupported media type: ${type}`);
                return null;
            }
        }

        element.dataset.duration = media.duration * 1000;
        element.dataset.url = media.url;
        element.dataset.mediaType = media.media_type;
        element.className += index === 0 ? ' active' : '';
        
        if (indicator) {
            element.appendChild(indicator);
        }
        
        return element;
    }

    // CRITICAL: New optimized PDF element creation
    createOptimizedPDFElement(media) {
        // Create container for PDF
        const container = document.createElement('div');
        container.className = 'media-element pdf';
        
        // ENHANCED: Create iframe for better PDF control
        const iframe = document.createElement('iframe');
        
        // OPTIMIZED: PDF URL with maximum zoom and fit parameters
        const pdfUrl = media.url + '#toolbar=0&navpanes=0&scrollbar=0&view=FitH&zoom=page-width&page-mode=none';
        iframe.src = pdfUrl;
        iframe.className = 'pdf-iframe';
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        
        // CRITICAL: Force iframe to use full container space
        iframe.style.cssText = `
            width: 100% !important;
            height: 100% !important;
            border: none !important;
            margin: 0 !important;
            padding: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            background: white !important;
        `;
        
        // ADD: Loading indicator
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'pdf-loading';
        loadingDiv.textContent = 'Loading PDF Document';
        
        // ADD: PDF controls
        const controlsDiv = this.createPDFControls();
        
        // ADD: Zoom info indicator (hidden)
        const zoomInfo = document.createElement('div');
        zoomInfo.className = 'pdf-zoom-info';
        zoomInfo.style.display = 'none'; // Hide zoom info
        
        // ENHANCED: Better load handling
        iframe.addEventListener('load', () => {
            console.log('PDF loaded successfully:', media.url);
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            // Show zoom info briefly
            zoomInfo.classList.add('visible');
            setTimeout(() => {
                zoomInfo.classList.remove('visible');
            }, 4000);
            
            // Try to maximize PDF zoom programmatically
            this.optimizePDFZoom(iframe);
        });
        
        iframe.addEventListener('error', (e) => {
            console.error('PDF load error:', e);
            this.handlePDFError(container, media);
        });
        
        // Assemble the PDF container
        container.appendChild(iframe);
        container.appendChild(loadingDiv);
        container.appendChild(controlsDiv);
        container.appendChild(zoomInfo);
        
        return container;
    }

    // NEW: Optimize PDF zoom for large screens
    optimizePDFZoom(iframe) {
        try {
            // Attempt to access iframe content and maximize zoom
            setTimeout(() => {
                const containerWidth = this.containerElement.offsetWidth;
                const containerHeight = this.containerElement.offsetHeight;
                
                console.log('PDF container dimensions:', {
                    width: containerWidth,
                    height: containerHeight,
                    screenRatio: containerWidth / containerHeight
                });
                
                // Send message to iframe to maximize zoom if possible
                if (iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        action: 'maximizeZoom',
                        containerWidth: containerWidth,
                        containerHeight: containerHeight
                    }, '*');
                }
            }, 1000);
        } catch (error) {
            console.log('Cannot access PDF iframe content (cross-origin):', error);
        }
    }

    // ENHANCED: Better PDF controls
    createPDFControls() {
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'pdf-controls';
        controlsDiv.style.display = 'none'; // Hide PDF controls
        
        return controlsDiv;
    }

    // NEW: Refresh current PDF
    refreshCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.classList.contains('pdf')) {
            const iframe = currentElement.querySelector('iframe');
            if (iframe) {
                const originalSrc = iframe.src;
                iframe.src = '';
                setTimeout(() => {
                    iframe.src = originalSrc + '&refresh=' + Date.now();
                    this.showClickAlert('PDF Refreshed');
                }, 100);
            }
        }
    }

    // ENHANCED: Better PDF error handling
    handlePDFError(pdfElement, media) {
        console.error('PDF failed to load:', media.url);
        
        // Remove loading indicator
        const loadingDiv = pdfElement.querySelector('.pdf-loading');
        if (loadingDiv) {
            loadingDiv.remove();
        }
        
        // Create enhanced error message
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(231, 76, 60, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            max-width: 80%;
        `;
        errorDiv.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px;">üìÑ PDF Load Error</div>
            <div style="font-size: 16px; margin-bottom: 15px;">
                Unable to display: ${media.url.split('/').pop()}
            </div>
            <div style="font-size: 14px; opacity: 0.9;">
                Check PDF file format and network connection
            </div>
        `;
        
        pdfElement.appendChild(errorDiv);
        
        // Auto-advance after error
        setTimeout(() => {
            this.switchMedia();
        }, 8000);
    }

    async loadBOMContent(element, media) {
        try {
            // Add timestamp to prevent caching for real-time updates
            const timestamp = new Date().getTime();
            const response = await fetch(`/station/${this.stationId}/bom-render/?t=${timestamp}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log('BOM content refreshed');
            } else {
                element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Failed to load BOM data</div>';
            }
        } catch (error) {
            console.error('Error loading BOM content:', error);
            element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Error loading BOM data</div>';
        }
    }

    async refreshCurrentBOMContent() {
        // Method to refresh BOM content without rebuilding entire media
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.dataset.mediaType === 'Database BOM') {
            console.log('Refreshing current BOM content...');
            await this.loadBOMContent(currentElement, {});
        }
    }

    playCurrentMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        let duration = parseInt(currentMedia.dataset.duration) || 15000;

        if (currentMedia.tagName === 'VIDEO') {
            currentMedia.play().catch(error => {
                console.error('Error playing video:', error);
                this.switchMedia();
            });
        } else if (currentMedia.classList.contains('pdf')) {
            // ENHANCED: Longer duration for PDFs on large screens
            duration = 60000; // 60 seconds for PDFs
            console.log(`Displaying PDF: ${currentMedia.dataset.url}`);
            
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        } else {
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    }

    isCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && currentElement.classList.contains('pdf');
    }

    stopCurrentMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        if (currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        // Reset PDF fullscreen when stopping
        if (currentMedia.classList.contains('pdf')) {
            currentMedia.classList.remove('fullscreen');
            this.pdfFullscreen = false;
        }
        
        clearTimeout(this.slideshowTimer);
    }

    switchMedia() {
        if (this.mediaElements.length === 0) return;
        if (this.mediaElements.length === 1) {
            // If only one element and it's BOM, refresh its content periodically
            if (this.isCurrentlyShowingBOM()) {
                this.refreshCurrentBOMContent();
            }
            this.stopCurrentMedia();
            this.playCurrentMedia();
            return;
        }

        const currentMedia = this.mediaElements[this.currentIndex];
        if (currentMedia) {
            currentMedia.classList.add('fade-out');
            currentMedia.classList.remove('active');
        }
        
        this.stopCurrentMedia();
        this.currentIndex = (this.currentIndex + 1) % this.mediaElements.length;
        
        const nextMedia = this.mediaElements[this.currentIndex];
        if (nextMedia) {
            nextMedia.classList.remove('fade-out');
            nextMedia.classList.add('active');
            
            // If switching to BOM, refresh its content
            if (nextMedia.dataset.mediaType === 'Database BOM') {
                this.loadBOMContent(nextMedia, {});
            }
            
            this.playCurrentMedia();
        }
    }

    handleMediaError(error) {
        console.error('Media error:', error);
        this.showError('Media playback error');
        setTimeout(() => this.switchMedia(), 3000);
    }

    showError(message) {
        this.errorElement.textContent = message;
        this.errorElement.classList.remove('hidden');
    }

    hideError() {
        this.errorElement.classList.add('hidden');
    }

    async sendClickerAction(action, alertMessage) {
        try {
            const response = await fetch(`/station/${this.stationId}/clicker/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.updateConnectionStatus('connected', 
                    `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
                this.showClickAlert(alertMessage || 'Action Completed!');
                
                // Force immediate update after clicker action
                setTimeout(async () => {
                    await this.pollForUpdates();
                }, 100);
                
            } else {
                this.showError(result.error || 'Clicker action failed');
                this.showClickAlert('Action Failed!', true);
                setTimeout(() => this.hideError(), 4000);
            }
        } catch (error) {
            console.error('Clicker action error:', error);
            this.showError('Clicker communication error');
            this.showClickAlert('Connection Error!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    }

    destroy() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
        }
    }
}

// Initialize the enhanced slider when page loads
document.addEventListener('DOMContentLoaded', () => {
    const stationId = {{ station.id }};
    const displayNumber = {{ station.display_number }};
    window.mediaSlider = new BRGMediaSliderWithBOM(stationId, displayNumber);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (window.mediaSlider) {
        window.mediaSlider.destroy();
    }
});
</script>
</body>
</html>