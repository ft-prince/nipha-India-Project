<!-- templates/brg_station_slider_enhanced.html - OPTIMIZED FOR LARGE ROTATED DISPLAYS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRG Assembly 40K - Display {{ station.display_number }}</title>
    <style>

body, html {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background-color: #ffffff !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* ENHANCED: Better rotation for portrait monitors */
body {
    transform: rotate(90deg);
    transform-origin: center center;
    width: 100vh;
    height: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    margin-top: -50vw;
    margin-left: -50vh;
    background-color: #ffffff !important;
}

.main-container {
    display: flex;
    flex-direction: column;
    height: 100vw;
    width: 100vh;
    position: relative;
}

/* COMPACT: Reduced header height to maximize content area */
.assembly-header {
    background: linear-gradient(135deg, #2c3e50, #3498db);
    color: white;
    padding: 18px 30px; /* Increased from 12px 25px */
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 80px; /* Increased from 60px */
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    flex-shrink: 0;
}

.product-info {
    display: flex;
    flex-direction: column;
}

.product-code {
    font-size: 36px; /* Increased from 28px */
    font-weight: bold;
    margin-bottom: 10px; /* Increased from 8px */
    margin-bottom: 8px;
        line-height: 1.2;

}

.process-info {
    font-size: 22px; /* Increased from 18px */
    opacity: 0.9;
        line-height: 1.3;

}

.display-badge {
    background: rgba(255,255,255,0.2);
    padding: 15px 25px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 24px;
}
.display-badge div {
    font-size: 16px !important; /* Increased from 14px */
    margin-top: 5px !important; /* Increased from 3px */
}

.display-1 { border-left: 5px solid #FF6B6B; }
.display-2 { border-left: 5px solid #4ECDC4; }
.display-3 { border-left: 5px solid #45B7D1; }

/* ENHANCED: Media slider with better flex management */
.slider-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: rgb(255, 255, 255);
    overflow: hidden;
    min-height: 0; /* Important for flex children */
}

.media-element {
    height: 100%;
    width: 100%;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: contain;
    transition: opacity 0.5s ease-in-out;
}

/* COMPLETELY REWRITTEN: PDF styling for large rotated displays */
.media-element.pdf {
    /* MAXIMIZED: Use every pixel available */
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    
    position: absolute;
    top: 62%;
    left: 54%;

    /* ENHANCED: Better PDF rendering */
    object-fit: cover;
    border: none;
    background-color: white;
    
    /* CRITICAL: Force PDF to use full space */
    box-sizing: border-box;
    
    /* ENHANCED: High quality rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    
    /* REMOVE: Any margins or padding that might interfere */
    margin: 0 0 0 0 !important;
    padding: 0 !important;
    /* Centered zoom */
    transform: scale(1.088) translate(-50%, -50%);
    transform-origin: center center;

}

/* ALTERNATIVE: PDF iframe for better control */
.media-element.pdf-iframe {
    width: 100% !important;
    height: 100% !important;
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    border: none;
    background-color: white;
    overflow: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* ENHANCED: PDF controls with better visibility */
.pdf-controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 150;
    display: flex;
    gap: 15px;
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.pdf-controls:hover {
    opacity: 1;
}

.pdf-control-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.pdf-control-btn:hover {
    background: rgba(0,0,0,1);
    transform: scale(1.1);
}

/* ENHANCED: Fullscreen PDF mode */
.media-element.pdf.fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    z-index: 1000;
    background: white;
    position: fixed !important;
}

.media-element.bom {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
}

.media-element.active {
    display: block;
    opacity: 1;
}

.media-element.fade-out {
    opacity: 0;
}

/* ENHANCED: Better clicker controls for large screens */
.clicker-controls {
    position: absolute;
    bottom: 30px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.clicker-left {
    left: 30px;
}

.clicker-right {
    right: 30px;
}

.clicker-btn {
    background: rgba(52, 152, 219, 0.9);
    border: none;
    border-radius: 50%;
    width: 90px;
    height: 90px;
    color: white;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
}

.clicker-btn:hover {
    background: rgba(52, 152, 219, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.clicker-btn:active {
    transform: scale(0.95);
    background: rgba(41, 128, 185, 1);
}

.clicker-hint {
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    margin-top: 8px;
    white-space: nowrap;
}

.clicker-controls.hidden {
    display: none;
}

/* Enhanced click feedback */
.click-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(46, 204, 113, 0.95);
    color: white;
    padding: 25px 50px;
    border-radius: 30px;
    font-size: 22px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
    transition: all 0.3s ease;
}

.click-alert.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.click-alert.error {
    background: rgba(231, 76, 60, 0.95);
}

/* COMPACT: Reduced status bar height to reclaim space */
.status-bar {
    background: rgba(246, 246, 246, 0.9);
    color: white;
    padding: 8px 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 35px;
    gap: 40px;
    flex-shrink: 0;
    font-size: 14px;
}

.loop-indicator {
    background: #f39c12;
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 2s infinite;
}

.loop-indicator.hidden {
    display: none;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.connection-status {
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.connection-status.visible { opacity: 1; }
.connection-status.connected { background-color: #27ae60; color: white; }
.connection-status.disconnected { background-color: #e74c3c; color: white; }
.connection-status.reconnecting { background-color: #f39c12; color: white; }

/* Navigation hints */
.navigation-hints {
    background: rgba(52, 152, 219, 0.2);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.navigation-hints.hidden {
    display: none;
}

/* ENHANCED: Media type indicators */
.media-type-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    backdrop-filter: blur(5px);
}

.bom-indicator { background: rgba(52, 152, 219, 0.8); }
.video-indicator { background: rgba(231, 76, 60, 0.8); }
.doc-indicator { 
    background: rgba(46, 204, 113, 0.8);
    font-size: 18px;
    padding: 15px 25px;
}

/* Error states */
.error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    font-size: 20px;
    z-index: 1000;
}

.error-message.hidden {
    display: none;
}

/* BOM indicator in status bar */
.bom-status {
    background: rgba(52, 152, 219, 0.8);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
}

/* CRITICAL: Responsive scaling for different large monitor sizes */
@media screen and (min-width: 1920px) {
    .product-code { font-size: 42px; }
    .process-info { font-size: 26px; }
    .display-badge { font-size: 28px; padding: 18px 30px; }
    .assembly-header { padding: 20px 35px; min-height: 70px; }
    .status-bar { padding: 10px 30px; font-size: 16px; min-height: 40px; }
    
    .media-element.pdf {
        /* FORCE: Maximum utilization on large screens */
        width: 100% !important;
        height: 100% !important;
    }
}

@media screen and (min-width: 2560px) {
    .product-code { 
        font-size: 50px; /* Increased from 36px */
        margin-bottom: 15px;
    }
    .process-info { font-size: 30px; }
    .display-badge { font-size: 32x; padding: 18px 30px; }
    .assembly-header { padding: 25px 40px; min-height: 100px; }
    .status-bar { padding: 12px 35px; font-size: 18px; min-height: 45px; }
    
    .pdf-control-btn { width: 70px; height: 70px; font-size: 24px; }
    .clicker-btn { width: 100px; height: 100px; font-size: 32px; }
    
    .media-type-indicator { font-size: 18px; padding: 15px 25px; }
    .doc-indicator { font-size: 20px; padding: 18px 30px; }
}

@media screen and (min-width: 3440px) {
    .assembly-header { 
        padding: 30px 45px; 
        min-height: 130px; /* Increased from 90px */
    }
    .product-code { 
        font-size: 58px; /* Increased from 40px */
        margin-bottom: 18px;
    }
    .process-info { 
        font-size: 34px; /* Increased from 24px */
    }
    .display-badge { 
        font-size: 36px; /* Increased from 26px */
        padding: 25px 40px; /* Increased from 20px 35px */
    }

    .status-bar { padding: 15px 40px; font-size: 20px; min-height: 50px; }
    
    .pdf-control-btn { width: 80px; height: 80px; font-size: 28px; }
    .clicker-btn { width: 110px; height: 110px; font-size: 36px; }
    
    .media-type-indicator { font-size: 20px; padding: 18px 30px; }
    .doc-indicator { font-size: 24px; padding: 20px 35px; }
}

/* ULTRA-WIDE: 4K and above optimizations */
@media screen and (min-width: 4096px) {
    .assembly-header { 
        padding: 35px 50px; 
        min-height: 150px; /* Increased from 100px */
    }
    .product-code { 
        font-size: 66px; /* Increased from 44px */
        margin-bottom: 20px;
    }
    .process-info { 
        font-size: 38px; /* Increased from 26px */
    }
    .display-badge { 
        font-size: 40px; /* Increased from 28px */
        padding: 28px 45px; /* Increased from 25px 40px */
    }
    .status-bar { padding: 18px 45px; font-size: 22px; min-height: 55px; }
    
    .pdf-control-btn { width: 90px; height: 90px; font-size: 32px; }
    .clicker-btn { width: 120px; height: 120px; font-size: 40px; }
    
    .media-type-indicator { font-size: 22px; padding: 20px 35px; }
    .doc-indicator { font-size: 26px; padding: 25px 40px; }
}

/* PDF LOADING INDICATOR */
.pdf-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #333;
    font-size: 24px;
    z-index: 50;
    background: rgba(255, 255, 255, 0.9);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.pdf-loading::after {
    content: "...";
    animation: dots 2s infinite;
}

@keyframes dots {
    0%, 20% { content: ""; }
    40% { content: "."; }
    60% { content: ".."; }
    80%, 100% { content: "..."; }
}

/* ZOOM ENHANCEMENT: Better PDF zoom controls */
.pdf-zoom-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 120;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pdf-zoom-info.visible {
    opacity: 1;
}

/* DEBUG: Temporary border to see PDF boundaries (remove in production) */
.media-element.pdf.debug {
    border: 3px solid red !important;
}

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Assembly Header -->
        <div class="assembly-header display-{{ station.display_number }}">
            <div class="product-info">
                <div class="product-code" id="product-code">
                    {% if current_product %}{{ current_product.code }}{% else %}No Product Selected{% endif %}
                </div>
                <div class="process-info" id="process-info">
                    {% if current_process %}
                        {{ current_stage.display_name }} - {{ current_process.display_name }}
                    {% else %}
                        No Process Selected
                    {% endif %}
                </div>
            </div>
            <div class="display-badge">
                Display {{ station.display_number }}
                <div style="font-size: 14px; margin-top: 3px;">
                    {% if station.display_number == 1 %}BOMs & Reference
                    {% elif station.display_number == 2 %}Process Instructions  
                    {% else %}Instructional Videos{% endif %}
                </div>
            </div>
        </div>

        <!-- Media Slider -->
        <div class="slider-container" id="slider-container">
            <!-- Left Clicker Controls -->
<div class="clicker-controls clicker-left {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="left-controls">
    <button class="clicker-btn" id="backward-btn" title="Previous Process">
        &#8592;
    </button>
    <div class="clicker-hint">‚Üê Previous</div>
</div>

            <!-- Right Clicker Controls -->
<div class="clicker-controls clicker-right {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="right-controls">
    <button class="clicker-btn" id="forward-btn" title="Next Process">
        &#8594;
    </button>
    <div class="clicker-hint">Next ‚Üí</div>
</div>

            <div class="error-message hidden" id="error-message">
                <div>‚ö†Ô∏è Connection Error</div>
                <div style="font-size: 16px; margin-top: 15px;">
                    Please check network connection or contact supervisor
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            {% if has_bom_data %}
            <div class="bom-status" id="bom-status">
                üìã BOM: {{ bom_item_count }} items
            </div>
            {% endif %}
            
            <div class="loop-indicator {% if not loop_mode %}hidden{% endif %}" id="loop-indicator">
                üîÑ LOOP MODE - Processes 1A, 1B, 1C
            </div>
            <div id="connection-status" class="connection-status">Connecting...</div>
        </div>

        <!-- Click Feedback Alert -->
        <div class="click-alert" id="click-alert">
            Action Completed!
        </div>
    </div>

    <script>
// Enhanced BRG Media Slider with AUTOMATIC LOOP MODE - COMPLETE VERSION
class BRGMediaSliderWithAutoLoop {
    constructor(stationId, displayNumber) {
        this.stationId = stationId;
        this.displayNumber = displayNumber;
        this.currentIndex = 0;
        this.mediaElements = [];
        this.slideshowTimer = null;
        this.pollingInterval = null;
        this.pollingDelay = 1000;
        this.lastDataHash = null;
        this.lastBomHash = null;
        this.pdfFullscreen = false;
        this.currentPdfZoom = 1.0;
        
        // Auto loop properties
        this.autoLoopMode = false;
        this.autoLoopTimer = null;
        this.autoLoopProgressTimer = null;
        this.loopProcessDurations = {
            'PROCESS 1A OF 6': 30000, // 30 seconds - configurable
            'PROCESS 1B OF 6': 30000, // 45 seconds - configurable
            'PROCESS 1C OF 6': 30000  // 60 seconds - configurable
        };

            // NEW: Auto BOM pagination properties
        this.autoBomPaginationTimer = null;
        this.currentBomTotalPages = 1;
        this.isBomAutoPaginationActive = false;

        this.currentProcessName = null;
        this.isInLoopGroup = false;
                this.paginationMode = 'split'; // or 'single'
        this.itemsPerScreen = 8;
        this.currentBomPage = 1;

        // DOM elements
        this.containerElement = document.getElementById('slider-container');
        this.statusElement = document.getElementById('connection-status');
        this.errorElement = document.getElementById('error-message');
        this.productCodeElement = document.getElementById('product-code');
        this.processInfoElement = document.getElementById('process-info');
        this.loopIndicatorElement = document.getElementById('loop-indicator');
        this.leftControlsElement = document.getElementById('left-controls');
        this.rightControlsElement = document.getElementById('right-controls');
        this.clickAlertElement = document.getElementById('click-alert');
        this.bomStatusElement = document.getElementById('bom-status');
        
        this.startPolling();
        this.setupKeyboardListeners();
        this.setupClickerListeners();
        this.logScreenInfo();
    }

    logScreenInfo() {
        console.log('Screen Information:', {
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            screenWidth: screen.width,
            screenHeight: screen.height,
            devicePixelRatio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.angle : 'unknown'
        });
    }

    async startPolling() {
        await this.pollForUpdates();
        this.pollingInterval = setInterval(async () => {
            await this.pollForUpdates();
        }, this.pollingDelay);
    }

    async pollForUpdates() {
        try {
            let mediaEndpoint;
            
            // UPDATED: Use pagination-aware endpoints
            if (this.displayNumber === 1) {
                // For Display 1, use the new paginated media endpoint
                mediaEndpoint = `/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`;
            } else {
                // For other displays, use the regular paginated endpoint
                mediaEndpoint = `/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`;
            }
            
            const mediaResponse = await fetch(mediaEndpoint);
            if (!mediaResponse.ok) {
                throw new Error(`HTTP ${mediaResponse.status}`);
            }
            const mediaData = await mediaResponse.json();
            
            // REMOVED: Separate BOM data fetch since it's now included in media response
            
            // Create hash for change detection (updated for pagination)
            const mediaHash = JSON.stringify({
                media: mediaData.media ? mediaData.media.map(m => ({ 
                    id: m.id, 
                    url: m.url, 
                    type: m.type,
                    is_bom_data: m.is_bom_data,
                    bom_type: m.bom_type,
                    bom_hash: m.bom_hash // Include pagination hash
                })) : [],
                station: mediaData.station_info
            });
            
            // Check if anything changed
            const mediaChanged = mediaHash !== this.lastDataHash;
            
            if (mediaChanged) {
                console.log(`Display ${this.displayNumber} update detected (paginated):`, { mediaChanged });
                
                this.checkAutoLoopMode(mediaData);
                this.updateAssemblyInfo(mediaData, null); // No separate BOM data
                this.updateMedia(mediaData, null, false); // Updated to handle pagination
                this.playCurrentMedia()
                if (this.isCurrentlyShowingBOM()) {
                        console.log('Detected BOM slide after media update, refreshing content...');
                        this.refreshCurrentBOMContent();  // Forces real-time BOM to re-render
                    }

                this.hideError();
                this.updateConnectionStatus('connected', 'Updated');
                
                this.lastDataHash = mediaHash;
            }
            
        } catch (error) {
            console.error(`Display ${this.displayNumber} polling error:`, error);
            this.showError('Connection error. Retrying...');
            this.updateConnectionStatus('disconnected', 'Connection Lost');
        }
    }
// UPDATED: Add this to your sendClickerAction method in BRGMediaSliderWithAutoLoop

async sendClickerAction(action, alertMessage) {
    try {
        // CRITICAL: Stop auto loop immediately when ANY manual action is taken
        if (this.autoLoopMode) {
            console.log('Manual action detected - stopping auto loop immediately');
            this.stopAutoLoop();
            
            // Show override message
            this.showClickAlert('Manual Override - Auto Loop Stopped', false);
            
            // Brief delay to show the override message
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        const response = await fetch(`/station/${this.stationId}/clicker/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ action: action })
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('Clicker action result:', result);
            
            // NEW: Handle pagination reset
            if (result.pagination_reset) {
                console.log('Pagination was reset due to process change üôè ');
                // Force immediate media update to get fresh BOM data
                setTimeout(async () => {
                    console.log('Forcing media refresh after pagination reset... üíÄ');
                    await this.pollForUpdates();
                    await this.playCurrentMedia(); 
                }, 200);
            }
            
            // Update connection status
            this.updateConnectionStatus('connected', 
                `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
            
            // Handle loop exit messaging
            if (result.exit_loop) {
                this.updateLoopIndicator(false, false);
            } else {
                // Optional: Show action completed message
                // this.showClickAlert(alertMessage || 'Action Completed!');
            }
            
            // DO NOT restart auto loop after manual action
            console.log('Manual action completed - auto loop will NOT restart automatically');
            
            // Force immediate update after clicker action (in addition to pagination reset update)
            if (!result.pagination_reset) {
                console.log('üôè');
                setTimeout(async () => {
                    await this.pollForUpdates();
                    await this.playCurrentMedia(); 
                }, 100);
            }
            
        } else {
            this.showError(result.error || 'Clicker action failed');
            this.showClickAlert('Action Failed!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    } catch (error) {
        console.error('Clicker action error:', error);
        this.showError('Clicker communication error');
        this.showClickAlert('Connection Error!', true);
        setTimeout(() => this.hideError(), 4000);
    }
}

    // Check and manage auto loop mode
    checkAutoLoopMode(data) {
        if (!data.station_info || !data.station_info.current_process) {
            this.stopAutoLoop();
            return;
        }
        
        const currentProcess = data.station_info.current_process;
        const isInLoopGroup = currentProcess.loop_group === 'final_assembly_1abc';
        const isLoopMode = data.station_info.loop_mode;
        const processChanged = this.currentProcessName !== currentProcess.name;
        
        console.log('Auto loop check:', {
            currentProcess: currentProcess.name,
            isInLoopGroup,
            isLoopMode,
            processChanged,
            autoLoopMode: this.autoLoopMode,
            previousProcess: this.currentProcessName
        });
        
        // Update current process tracking
        const previousProcessName = this.currentProcessName;
        this.currentProcessName = currentProcess.name;
        this.isInLoopGroup = isInLoopGroup;
        
        // ENHANCED: Check if we've exited the loop group
        if (this.autoLoopMode && (!isInLoopGroup || !isLoopMode)) {
            console.log('Exiting auto loop - no longer in loop group or loop mode disabled');
            this.stopAutoLoop();
            
            if (!isInLoopGroup && previousProcessName) {
                this.showClickAlert(`Moved to ${currentProcess.display_name} - Loop Exited`, false);
            }
        }
        // Check if we should start auto loop (only if we're entering 1A specifically)
        else if (isInLoopGroup && isLoopMode && currentProcess.name === 'PROCESS 1A OF 6') {
            if (!this.autoLoopMode || processChanged) {
                console.log('Starting auto loop - entered Process 1A');
                this.startAutoLoop(currentProcess.name);
            }
        }
        // Restart auto loop if we're still in loop group and mode, but process changed
        else if (isInLoopGroup && isLoopMode && this.autoLoopMode && processChanged) {
            console.log('Restarting auto loop for new process:', currentProcess.name);
            this.startAutoLoop(currentProcess.name);
        }
        // Stop auto loop if we're not in the right conditions
        else if (!isInLoopGroup || !isLoopMode) {
            if (this.autoLoopMode) {
                console.log('Stopping auto loop - conditions not met');
                this.stopAutoLoop();
            }
        }
        
        // Update loop indicator
        this.updateLoopIndicator(isInLoopGroup, isLoopMode);
    }


        // Update loop indicator with auto loop status
    updateLoopIndicator(isInLoopGroup, isLoopMode) {
        if (isInLoopGroup && isLoopMode && this.autoLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ AUTO LOOP ACTIVE - 1A ‚Üí 1B ‚Üí 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#27ae60'; // Green for auto mode
            this.loopIndicatorElement.classList.add('auto-mode');
        } else if (isInLoopGroup && isLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ LOOP MODE (Manual) - 1A, 1B, 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#f39c12'; // Orange for manual mode
            this.loopIndicatorElement.classList.remove('auto-mode');
        } else {
            this.loopIndicatorElement.classList.add('hidden');
            this.loopIndicatorElement.classList.remove('auto-mode');
        }
    }

        // Start automatic loop progression
        startAutoLoop(processName) {
            console.log(`Starting auto loop mode for process: ${processName}`);
            
            this.stopAutoLoop(); // Clear any existing timers
            this.autoLoopMode = true;
            
            // Get duration for current process
            const duration = this.loopProcessDurations[processName] || 30000; // Default 30 seconds
            
            console.log(`Auto loop timer set for ${duration}ms (${duration/1000}s) for ${processName}`);
            
            // Set timer for automatic progression
            this.autoLoopProgressTimer = setTimeout(async () => {
                await this.autoProgressLoop();
            }, duration);
            
            // Show auto loop status
            this.showClickAlert(`Auto Loop: ${processName} (${duration/1000}s)`, false);
        }

        // Stop automatic loop progression - COMPLETED
        stopAutoLoop() {
            if (this.autoLoopProgressTimer) {
                clearTimeout(this.autoLoopProgressTimer);
                this.autoLoopProgressTimer = null;
                console.log('Auto loop timer cleared');
            }
            
            if (this.autoLoopTimer) {
                clearTimeout(this.autoLoopTimer);
                this.autoLoopTimer = null;
            }
            
            this.autoLoopMode = false;
            console.log('Auto loop mode stopped');
        }

        // Automatically progress to next step in loop
        async autoProgressLoop() {
            try {
                console.log('Auto-progressing loop from:', this.currentProcessName);
                
                const response = await fetch(`/station/${this.stationId}/auto-loop-progress/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Auto loop progression successful:', result.current_process.name);
                    
                    // Show progression alert
                    this.showClickAlert(`Auto: ${result.current_process.display_name}`, false);
                    
                    // Force immediate update to get new media
                    setTimeout(async () => {
                        await this.pollForUpdates();
                    }, 200);
                    
                } else {
                    console.error('Auto loop progression failed:', result.error);
                    this.stopAutoLoop();
                    this.showClickAlert('Auto Loop Error', true);
                }
            } catch (error) {
                console.error('Auto loop progression error:', error);
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Connection Error', true);
            }
        }

 setupKeyboardListeners() {
    document.addEventListener('keydown', (event) => {
        if (event.code === 'ArrowRight') {
            console.log('Manual forward key pressed');
            this.sendClickerAction('forward', 'Manual Forward ‚û§');
            event.preventDefault();
        } else if (event.code === 'ArrowLeft') {
            console.log('Manual backward key pressed');
            this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
            event.preventDefault();
        } else if (event.code === 'ArrowDown') {
            // NEW: Manual BOM pagination with down arrow
            if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                console.log('Manual BOM page navigation (down arrow) - next page');
                this.navigateBOMPage('next_page');
                event.preventDefault();
            } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                console.log('Down arrow pressed but BOM auto-pagination is active - ignoring manual input');
                this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                event.preventDefault();
            } else {
                console.log('Down arrow pressed but not on BOM slide - no action');
            }
        } else if (event.code === 'ArrowUp') {
            // BONUS: Add up arrow for previous BOM page
            if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                console.log('Manual BOM page navigation (up arrow) - previous page');
                this.navigateBOMPage('previous_page');
                event.preventDefault();
            } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                console.log('Up arrow pressed but BOM auto-pagination is active - ignoring manual input');
                this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                event.preventDefault();
            } else {
                console.log('Up arrow pressed but not on BOM slide - no action');
            }
        } else if (event.code === 'Space') {
            console.log('Space pressed - toggling loop mode');
            this.sendClickerAction('toggle_loop', 'Loop Mode Toggled');
            event.preventDefault();
        } else if (event.code === 'Escape') {
            if (this.autoLoopMode) {
                console.log('ESC pressed - stopping auto loop');
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Stopped (Manual)', false);
            } else if (this.pdfFullscreen) {
                this.togglePDFFullscreen();
            }
            event.preventDefault();
        }
        // Keep existing pagination controls (Page Down/Up with Ctrl)
        else if (event.code === 'PageDown' || (event.code === 'ArrowDown' && event.ctrlKey)) {
            console.log('Page Down pressed - next BOM page');
            this.navigateBOMPage('next_page');
            event.preventDefault();
        } else if (event.code === 'PageUp' || (event.code === 'ArrowUp' && event.ctrlKey)) {
            console.log('Page Up pressed - previous BOM page');
            this.navigateBOMPage('previous_page');
            event.preventDefault();
        } else if (event.code === 'KeyM' && event.ctrlKey) {
            console.log('Ctrl+M pressed - toggle pagination mode');
            this.togglePaginationMode();
            event.preventDefault();
        }
    });
}


// NEW: Helper method to check if current BOM has duration active
isCurrentBOMDurationActive() {
    if (!this.isCurrentlyShowingBOM()) return false;
    
    const currentElement = this.mediaElements[this.currentIndex];
    if (!currentElement) return false;
    
    // Get the current value from dataset (which should be updated by playCurrentMedia)
    const isDurationActive = currentElement.dataset.isDurationActive === 'true';
    
    console.log('Checking current BOM duration status:', {
        is_duration_active: isDurationActive,
        dataset_value: currentElement.dataset.isDurationActive,
        is_auto_pagination_active: this.isBomAutoPaginationActive
    });
    
    return isDurationActive;
}

async navigateBOMPage(action) {
    try {
        // Stop auto pagination when user takes manual control
        this.stopAutoBomPagination();
        
        const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                action: action,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('Manual BOM pagination result:', result);
            
            // ENHANCED: Show different messages for different navigation types
            let message = `Page ${result.current_page}/${result.pagination.total_pages}`;
            if (action === 'next_page') {
                message = `Next: ${message}`;
            } else if (action === 'previous_page') {
                message = `Prev: ${message}`;
            } else {
                message = `Manual: ${message}`;
            }
            
            this.showClickAlert(message, false);
            
            // Refresh BOM content immediately
            await this.refreshBOMContent();
            
            // Don't restart auto pagination after manual action
            console.log('Manual BOM pagination - auto pagination will not restart');
            
        } else {
            console.error('BOM pagination error:', result.error);
            this.showClickAlert('Pagination Error', true);
        }
    } catch (error) {
        console.error('BOM pagination error:', error);
        this.showClickAlert('Pagination Connection Error', true);
    }
}


    // NEW: Toggle pagination mode
    togglePaginationMode() {
        this.paginationMode = this.paginationMode === 'split' ? 'single' : 'split';
        this.showClickAlert(`Pagination Mode: ${this.paginationMode.toUpperCase()}`, false);
        
        // Force update with new mode
        setTimeout(async () => {
            await this.pollForUpdates();
        }, 200);
    }

        setupClickerListeners() {
            document.getElementById('forward-btn').addEventListener('click', () => {
                this.sendClickerAction('forward', 'Manual Forward ‚û§');
            });

            document.getElementById('backward-btn').addEventListener('click', () => {
                this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
            });

            // Add auto loop toggle button if it exists
            const autoLoopBtn = document.getElementById('auto-loop-btn');
            if (autoLoopBtn) {
                autoLoopBtn.addEventListener('click', () => {
                    this.toggleAutoLoopMode();
                });
            }
        }

        // Toggle auto loop mode manually
        async toggleAutoLoopMode() {
            if (!this.isInLoopGroup) {
                this.showClickAlert('Auto Loop only available in processes 1A, 1B, 1C', true);
                return;
            }

            if (this.autoLoopMode) {
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Disabled', false);
            } else {
                // Start auto loop for current process
                if (this.currentProcessName) {
                    this.startAutoLoop(this.currentProcessName);
                }
            }
        }

        togglePDFFullscreen() {
            const currentElement = this.mediaElements[this.currentIndex];
            if (!currentElement || !currentElement.classList.contains('pdf')) {
                this.showClickAlert('Not a PDF document', true);
                return;
            }

            this.pdfFullscreen = !this.pdfFullscreen;
            
            if (this.pdfFullscreen) {
                currentElement.classList.add('fullscreen');
                this.showClickAlert('PDF Fullscreen Mode (ESC to exit)');
            } else {
                currentElement.classList.remove('fullscreen');
                this.showClickAlert('PDF Normal Mode');
            }
        }

        showClickAlert(message, isError = false) {
            this.clickAlertElement.textContent = message;
            this.clickAlertElement.className = isError ? 'click-alert error show' : 'click-alert show';
            
            setTimeout(() => {
                this.clickAlertElement.classList.remove('show');
            }, 3000);
        }

        updateConnectionStatus(status, message) {
            this.statusElement.className = `connection-status ${status} visible`;
            this.statusElement.textContent = message;
            
            if (status === 'connected') {
                setTimeout(() => {
                    this.statusElement.classList.remove('visible');
                }, 2000);
            }
        }

        updateAssemblyInfo(data, bomData) {
            if (data.station_info) {
                const station = data.station_info;
                
                if (station.current_product) {
                    this.productCodeElement.textContent = station.current_product.code;
                }
                
                if (station.current_stage && station.current_process) {
                    this.processInfoElement.textContent = 
                        `${station.current_stage.name} - ${station.current_process.display_name}`;
                }
                
                if (station.clicker_enabled && this.displayNumber === 2) {
                    this.leftControlsElement.classList.remove('hidden');
                    this.rightControlsElement.classList.remove('hidden');
                } else {
                    this.leftControlsElement.classList.add('hidden');
                    this.rightControlsElement.classList.add('hidden');
                }
                
                // Update BOM status for Display 1
                if (bomData && bomData.bom_data && this.bomStatusElement) {
                    const bomType = bomData.bom_template ? bomData.bom_template.bom_type : 'Unknown';
                    this.bomStatusElement.textContent = `üìã BOM: ${bomData.bom_data.length} items (${bomType})`;
                    this.bomStatusElement.classList.remove('hidden');
                } else if (this.bomStatusElement) {
                    this.bomStatusElement.classList.add('hidden');
                }
            }
        }

 updateMedia(data, bomData, forceUpdate = false) {
    let allMedia = [];
    
    console.log('updateMedia called (paginated):', {
        displayNumber: this.displayNumber,
        hasMediaData: !!data.media,
        mediaCount: data.media ? data.media.length : 0,
        paginationMode: this.paginationMode,
        debugInfo: data.debug_info
    });
    
    // CRITICAL: Only process BOM media if it actually has items
    const bomMediaItems = data.media ? data.media.filter(m => 
        m.type === 'bom' && 
        m.is_bom_data && 
        m.bom_items > 0  // ADDED: Only include BOM if it has items
    ) : [];
    
    console.log('Paginated BOM media items found:', bomMediaItems.length);
    
    if (bomMediaItems.length > 0) {
        bomMediaItems.forEach(bomMedia => {

                        console.log('=== BACKEND DATA DEBUG ===');
            console.log('Raw bomMedia:', bomMedia);
            console.log('bomMedia.is_duration_active:', bomMedia.is_duration_active);
            console.log('Type of is_duration_active:', typeof bomMedia.is_duration_active);
            console.log('bomMedia.duration:', bomMedia.duration);
            console.log('==========================');

            console.log('Adding paginated BOM from media response:', {
                id: bomMedia.id,
                type: bomMedia.type,
                is_bom_data: bomMedia.is_bom_data,
                bom_type: bomMedia.bom_type,
                is_split: bomMedia.is_split,
                display_number: this.displayNumber,
                bom_items: bomMedia.bom_items,
                pagination: bomMedia.pagination,
                is_duration_active: bomMedia.is_duration_active
                
            });
            
            allMedia.push({
                id: bomMedia.id,
                url: bomMedia.url,
                type: 'bom',
                duration: bomMedia.duration || 30,
                is_duration_active: bomMedia.is_duration_active,
                media_type: bomMedia.media_type || 'Paginated BOM',
                is_bom_data: true,
                bom_items: bomMedia.bom_items || 0,
                bom_type: bomMedia.bom_type,
                display_info: bomMedia.display_info,
                is_split: bomMedia.is_split,
                bom_data: bomMedia.bom_data,
                pagination: bomMedia.pagination,
                bom_hash: bomMedia.bom_hash
            });
        });
    }
    
    // Add regular media (videos, documents - ALWAYS include these)
    if (data.media && data.media.length > 0) {
        const nonBomMedia = data.media.filter(m => 
            !(m.type === 'bom' && m.is_bom_data) && 
            m.media_type !== 'Bill of Material'
        );
        
        console.log('Adding non-BOM media:', {
            totalMedia: data.media.length,
            nonBomMedia: nonBomMedia.length,
            mediaTypes: nonBomMedia.map(m => m.media_type)
        });
                // Also add is_duration_active to regular media
        const processedNonBomMedia = nonBomMedia.map(media => ({
            ...media,
            is_duration_active: media.is_duration_active || false  // ‚úÖ ADD THIS LINE
        }));
        
        allMedia = allMedia.concat(nonBomMedia);
    }
    
    console.log('Final paginated media array:', {
        totalItems: allMedia.length,
        bomItems: allMedia.filter(m => m.is_bom_data).length,
        regularMedia: allMedia.filter(m => !m.is_bom_data).length,
        mediaTypes: allMedia.map(m => m.media_type)
    });
    
    // CRITICAL: If no media at all, show error
    if (allMedia.length === 0) {
        console.warn('No media available for display', this.displayNumber);
        this.showError(`No media available for Display ${this.displayNumber}`);
        return;
    }

    const currentUrls = this.mediaElements.map(el => el.dataset.url);
    const newUrls = allMedia.map(m => m.url);
    
    const shouldUpdate = forceUpdate || JSON.stringify(currentUrls) !== JSON.stringify(newUrls);

    if (shouldUpdate) {
        console.log('Updating paginated media elements for display', this.displayNumber, '...');
        const wasPlayingBom = this.isCurrentlyShowingBOM();
        
        this.clearCurrentMedia();
        this.createNewMediaElements(allMedia);
        
        if (wasPlayingBom && this.hasBOMElement()) {
            this.currentIndex = 0;
        }
        
        this.playCurrentMedia();
    } else {
        console.log('No paginated media update needed for display', this.displayNumber);
    }
}


        isCurrentlyShowingBOM() {
            if (this.mediaElements.length === 0 || this.currentIndex >= this.mediaElements.length) return false;
            const currentElement = this.mediaElements[this.currentIndex];
            return currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'));
        }

        hasBOMElement() {
            return this.mediaElements.some(el => el.dataset.mediaType === 'Database BOM' || el.classList.contains('bom'));
        }

        clearCurrentMedia() {
            if (this.slideshowTimer) {
                clearTimeout(this.slideshowTimer);
            }
            this.stopCurrentMedia();
            
            const mediaChildren = Array.from(this.containerElement.children).filter(
                child => !child.classList.contains('clicker-controls') && 
                        !child.classList.contains('error-message')
            );
            mediaChildren.forEach(child => child.remove());
            this.mediaElements = [];
            this.currentIndex = 0;
            this.pdfFullscreen = false;
        }

        createNewMediaElements(mediaData) {
            mediaData.forEach((media, index) => {
                const mediaElement = this.createMediaElement(media, index);
                if (mediaElement) {
                    this.containerElement.appendChild(mediaElement);
                    this.mediaElements.push(mediaElement);
                }
            });
        }

        createMediaElement(media, index) {
            let element;
            let indicator;

            if (media.is_bom_data || media.type === 'bom') {
                console.log('ssssssssss',media)
                // Create BOM element (both database and split BOM)
                element = document.createElement('div');
                element.className = 'media-element bom';
                element.dataset.url = media.url;
                element.dataset.isDurationActive = media.is_duration_active  || false; // ADD THIS LINE

                element.dataset.duration = media.duration * 1000;
                element.dataset.bomHash = media.bom_hash || '';
                



                // Determine BOM type for display
                let bomTypeDisplay = 'BOM';
                if (media.is_split) {
                    bomTypeDisplay = 'Split BOM';
                    element.dataset.mediaType = 'Split BOM';
                } else if (media.id === 'database_bom') {
                    bomTypeDisplay = 'Real-time BOM';
                    element.dataset.mediaType = 'Database BOM';
                } else {
                    bomTypeDisplay = media.bom_type || 'BOM';
                    element.dataset.mediaType = media.media_type || 'BOM';
                }
                
                console.log(`Creating BOM element for display ${this.displayNumber}:`, {
                    bomType: bomTypeDisplay,
                    mediaType: element.dataset.mediaType,
                    url: media.url,
                    is_split: media.is_split,
                    bom_items: media.bom_items
                });
                
                // Load BOM content
                if (media.is_split && media.bom_data) {
                    // For split BOM, use the provided BOM data directly
                    console.log('byeeeeeeeeeeeeeeeeeeeee')
                    this.loadSplitBOMContent(element, media);
                } else {
                    console.log('heyyyyy')
                    // For database BOM, fetch from render endpoint
                    this.loadBOMContent(element, media);
                }
                
                indicator = document.createElement('div');
                indicator.className = 'media-type-indicator bom-indicator';
                indicator.textContent = `üìã ${bomTypeDisplay}`;
                
            } else {
                const type = media.type.toLowerCase();
                
                if (['mp4', 'mov'].includes(type)) {
                    element = document.createElement('video');
                    element.src = media.url;
                    element.className = 'media-element';
                    element.controls = false;
                    element.loop = false;
                    element.muted = true;
                    element.playsInline = true;
                    element.addEventListener('ended', () => this.switchMedia());
                    element.addEventListener('error', (e) => this.handleMediaError(e));
                    
                    indicator = document.createElement('div');
                    indicator.className = 'media-type-indicator video-indicator';
                    indicator.textContent = 'üé• Video';
                    
                } else if (type === 'pdf') {
                    element = this.createOptimizedPDFElement(media);
                    
                    indicator = document.createElement('div');
                    indicator.className = 'media-type-indicator pdf-indicator';                
                } else {
                    console.warn(`Unsupported media type: ${type}`);
                    return null;
                }
            }

            element.dataset.duration = media.duration * 1000;
            element.dataset.url = media.url;
            element.dataset.mediaType = element.dataset.mediaType || media.media_type;
            element.className += index === 0 ? ' active' : '';
            
            if (indicator) {
                element.appendChild(indicator);
            }
            
            return element;
        }

async loadSplitBOMContent(element, media, forceResetToPage1 = false) {
    try {
        console.log(`Loading paginated BOM content for display ${this.displayNumber}:`, {
            bomType: media.bom_type,
            bomItemsCount: media.bom_items,
            url: media.url,
            pagination: media.pagination,
            isBomAutoPaginationActive: this.isBomAutoPaginationActive,
            forceResetToPage1: forceResetToPage1
        });
        
        // ADDED: Check if BOM has items before loading
        if (!media.bom_items || media.bom_items === 0) {
            console.log(`No BOM items for display ${this.displayNumber}, not loading BOM content`);
            element.innerHTML = `
                <div class="no-bom-data-slider">
                    <div class="no-bom-icon-slider">üìã</div>
                    <h3>No BOM Items for Display ${this.displayNumber}</h3>
                    <p>This display has no BOM items assigned.</p>
                    <p>Check other displays for BOM content.</p>
                </div>
            `;
            return;
        }
        
        // Get current pagination state from the pagination API
        try {
            console.log("Getting current pagination state from backend...");

            const paginationResponse = await fetch(`/station/${this.stationId}/bom-paginated/`);
            let currentPage = 1;
            let totalPages = 1;
            
            if (paginationResponse.ok) {
                const paginationData = await paginationResponse.json();
                currentPage = paginationData.pagination ? paginationData.pagination.current_page : 1;
                totalPages = paginationData.pagination ? paginationData.pagination.total_pages : 1;
                console.log(`Display ${this.displayNumber}: Current BOM page is ${currentPage}/${totalPages}`);
            } else {
                console.log(`Display ${this.displayNumber}: Could not get pagination state, using page 1`);
            }
            
            // FIXED: Only reset to page 1 in specific circumstances
            if (forceResetToPage1 && currentPage > 1) {
                console.log(`Display ${this.displayNumber}: Force reset requested - resetting to page 1`);
                
                try {
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            currentPage = 1;
                            console.log(`Display ${this.displayNumber}: Successfully reset to page 1`);
                        }
                    }
                } catch (resetError) {
                    console.warn(`Display ${this.displayNumber}: Could not reset pagination to page 1:`, resetError);
                }
            } else {
                console.log(`Display ${this.displayNumber}: Keeping current page ${currentPage} (no reset needed)`);
            }
            
            // Use the render endpoint with current pagination state
            const timestamp = new Date().getTime();
            const paginationParams = new URLSearchParams({
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen,
                page: currentPage,
                t: timestamp
            });
            
            console.log(`Loading BOM content with params:`, {
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen,
                page: currentPage,
                url: `${media.url}?${paginationParams}`,
                isBomAutoPaginationActive: this.isBomAutoPaginationActive
            });
            
            const response = await fetch(`${media.url}?${paginationParams}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log(`Paginated BOM content loaded for display ${this.displayNumber} - Page ${currentPage}/${totalPages}`);
                
                // Update indicator with current pagination info
                const indicator = element.querySelector('.media-type-indicator');
                if (indicator) {
                    const statusText = this.isBomAutoPaginationActive ? 'Auto Paging' : 'Manual';
                    indicator.textContent = `üìã ${media.bom_type || 'BOM'} (Page ${currentPage}/${totalPages} - ${statusText})`;
                }
            } else {
                console.error(`Failed to load paginated BOM: ${response.status}`);
                element.innerHTML = `
                    <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                        <div>Failed to load Paginated BOM data</div>
                        <div style="font-size: 16px; margin-top: 10px;">Status: ${response.status}</div>
                        <div style="font-size: 14px; margin-top: 10px;">URL: ${media.url}?${paginationParams}</div>
                    </div>
                `;
            }
            
        } catch (paginationError) {
            console.error(`Error getting pagination state for display ${this.displayNumber}:`, paginationError);
            
            // Fallback: Load page 1
            const timestamp = new Date().getTime();
            const paginationParams = new URLSearchParams({
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen,
                page: 1,
                t: timestamp
            });
            
            const response = await fetch(`${media.url}?${paginationParams}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log(`Paginated BOM content loaded for display ${this.displayNumber} (fallback to page 1)`);
            } else {
                element.innerHTML = `
                    <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                        <div>Error loading Paginated BOM data</div>
                        <div style="font-size: 16px; margin-top: 10px;">${paginationError.message}</div>
                    </div>
                `;
            }
        }
        
    } catch (error) {
        console.error(`Error loading paginated BOM content for display ${this.displayNumber}:`, error);
        element.innerHTML = `
            <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                <div>Error loading Paginated BOM data</div>
                <div style="font-size: 16px; margin-top: 10px;">${error.message}</div>
            </div>
        `;
    }
}



// ADDED: Method to refresh BOM content when pagination changes
async refreshBOMContent() {
    const bomElements = this.mediaElements.filter(el => 
        el.classList.contains('bom') || el.dataset.mediaType === 'Paginated BOM'
    );
    
    for (const bomElement of bomElements) {
        const mediaUrl = bomElement.dataset.url;
        if (mediaUrl) {
            console.log(`Refreshing BOM content for display ${this.displayNumber}`);
            
            // Create a temporary media object for loadSplitBOMContent
            const tempMedia = {
                url: mediaUrl,
                bom_type: bomElement.dataset.mediaType || 'BOM',
                bom_items: 1, // Just to pass the check
                pagination: { current_page: 1, total_pages: 1 }
            };
            
            await this.loadSplitBOMContent(bomElement, tempMedia);
        }
    }
}


    // NEW: Helper method for CSRF token
    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }


        createOptimizedPDFElement(media) {
            // Create container for PDF
            const container = document.createElement('div');
            container.className = 'media-element pdf';
            
            // Create iframe for better PDF control
            const iframe = document.createElement('iframe');
            
            // PDF URL with maximum zoom and fit parameters
            const pdfUrl = media.url + '#toolbar=0&navpanes=0&scrollbar=0&view=FitH&zoom=page-width&page-mode=none';
            iframe.src = pdfUrl;
            iframe.className = 'pdf-iframe';
            iframe.frameBorder = '0';
            iframe.allowFullscreen = true;
            
            // Force iframe to use full container space
            iframe.style.cssText = `
                width: 100% !important;
                height: 100% !important;
                border: none !important;
                margin: 0 !important;
                padding: 0 !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                background: white !important;
            `;
            
            // Loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'pdf-loading';
            loadingDiv.textContent = 'Loading PDF Document';
            
            // PDF controls
            const controlsDiv = this.createPDFControls();
            
            // Zoom info indicator
            const zoomInfo = document.createElement('div');
            zoomInfo.className = 'pdf-zoom-info';
            zoomInfo.style.display = 'none';
            
            // Better load handling
            iframe.addEventListener('load', () => {
                console.log('PDF loaded successfully:', media.url);
                if (loadingDiv && loadingDiv.parentNode) {
                    loadingDiv.remove();
                }
                
                // Show zoom info briefly
                zoomInfo.classList.add('visible');
                setTimeout(() => {
                    zoomInfo.classList.remove('visible');
                }, 4000);
                
                // Try to maximize PDF zoom programmatically
                this.optimizePDFZoom(iframe);
            });
            
            iframe.addEventListener('error', (e) => {
                console.error('PDF load error:', e);
                this.handlePDFError(container, media);
            });
            
            // Assemble the PDF container
            container.appendChild(iframe);
            container.appendChild(loadingDiv);
            container.appendChild(controlsDiv);
            container.appendChild(zoomInfo);
            
            return container;
        }

        optimizePDFZoom(iframe) {
            try {
                // Attempt to access iframe content and maximize zoom
                setTimeout(() => {
                    const containerWidth = this.containerElement.offsetWidth;
                    const containerHeight = this.containerElement.offsetHeight;
                    
                    console.log('PDF container dimensions:', {
                        width: containerWidth,
                        height: containerHeight,
                        screenRatio: containerWidth / containerHeight
                    });
                    
                    // Send message to iframe to maximize zoom if possible
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            action: 'maximizeZoom',
                            containerWidth: containerWidth,
                            containerHeight: containerHeight
                        }, '*');
                    }
                }, 1000);
            } catch (error) {
                console.log('Cannot access PDF iframe content (cross-origin):', error);
            }
        }

        createPDFControls() {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'pdf-controls';
            controlsDiv.style.display = 'none'; // Hide PDF controls
            
            return controlsDiv;
        }

        refreshCurrentPDF() {
            const currentElement = this.mediaElements[this.currentIndex];
            if (currentElement && currentElement.classList.contains('pdf')) {
                const iframe = currentElement.querySelector('iframe');
                if (iframe) {
                    const originalSrc = iframe.src;
                    iframe.src = '';
                    setTimeout(() => {
                        iframe.src = originalSrc + '&refresh=' + Date.now();
                        this.showClickAlert('PDF Refreshed');
                    }, 100);
                }
            }
        }

        handlePDFError(pdfElement, media) {
            console.error('PDF failed to load:', media.url);
            
            // Remove loading indicator
            const loadingDiv = pdfElement.querySelector('.pdf-loading');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            // Create enhanced error message
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                background: rgba(231, 76, 60, 0.95);
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 20px;
                z-index: 100;
                box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                max-width: 80%;
            `;
            errorDiv.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 15px;">üìÑ PDF Load Error</div>
                <div style="font-size: 16px; margin-bottom: 15px;">
                    Unable to display: ${media.url.split('/').pop()}
                </div>
                <div style="font-size: 14px; opacity: 0.9;">
                    Check PDF file format and network connection
                </div>
            `;
            
            pdfElement.appendChild(errorDiv);
            
            // Auto-advance after error
            setTimeout(() => {
                this.switchMedia();
            }, 8000);
        }

        async loadBOMContent(element, media) {
            try {
                console.log("Bom Withhhhhhhhhhhhhhhh Normal")
                // Add timestamp to prevent caching for real-time updates
                const timestamp = new Date().getTime();
                const response = await fetch(`/station/${this.stationId}/bom-render-paginated/?t=${timestamp}`);
                
                if (response.ok) {
                    const bomHTML = await response.text();
                    
                    element.innerHTML = bomHTML;
                    console.log('BOM content refreshed');
                } else {
                    element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Failed to load BOM data</div>';
                }
            } catch (error) {
                console.error('Error loading BOM content:', error);
                element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Error loading BOM data</div>';
            }
        }

async refreshCurrentBOMContent() {
    // Method to refresh BOM content without rebuilding entire media
    const currentElement = this.mediaElements[this.currentIndex];
    if (currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'))) {
        console.log('Refreshing current BOM content...');
        
        try {
            // ENHANCED: Fetch fresh media data to get updated duration settings
            const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`);
            
            if (response.ok) {
                const freshData = await response.json();
                
                // Find the current BOM media in the fresh data
                const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                    m.type === 'bom' && 
                    m.is_bom_data && 
                    m.bom_items > 0
                ) : [];
                
                if (bomMediaItems.length > 0) {
                    const freshBomData = bomMediaItems.find(item => item.url === currentElement.dataset.url) || bomMediaItems[0];
                    
                    // Update DOM element with fresh duration data
                    currentElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                    currentElement.dataset.isDurationActive = freshBomData.is_duration_active || false;
                    
                    console.log('BOM content refreshed with updated duration data:', {
                        duration: currentElement.dataset.duration,
                        is_duration_active: currentElement.dataset.isDurationActive
                    });
                    
                    // Load fresh BOM content
                    await this.loadSplitBOMContent(currentElement, freshBomData);
                } else {
                    // Fallback to old method if no fresh BOM data
                    await this.loadBOMContent(currentElement, {});
                }
            } else {
                // Fallback to old method if API call fails
                await this.loadBOMContent(currentElement, {});
            }
        } catch (error) {
            console.error('Error refreshing BOM with fresh data:', error);
            // Fallback to old method
            await this.loadBOMContent(currentElement, {});
        }
    }
}

async playCurrentMedia() {
    console.log("Current Media üíãüíãüíãüíãüíãüíãüíãüíãüíãüíãüíãüíãüíã")
    if (this.mediaElements.length === 0) return;
    
    const currentMedia = this.mediaElements[this.currentIndex];
    if (!currentMedia) return;

    let duration = parseInt(currentMedia.dataset.duration) || 15000;
    let isDurationActive = currentMedia.dataset.isDurationActive === 'true';

    // CRITICAL FIX: For BOM elements, fetch fresh duration data from server
    if (currentMedia.classList.contains('bom')) {
        try {
            console.log('BOM detected - fetching fresh duration data from server...');
            
            const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`);
            
            if (response.ok) {
                const freshData = await response.json();
                
                // Find the current BOM media in the fresh data
                const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                    m.type === 'bom' && 
                    m.is_bom_data && 
                    m.bom_items > 0
                ) : [];
                
                if (bomMediaItems.length > 0) {
                    // Use the first BOM item's fresh data (or match by URL if multiple)
                    const freshBomData = bomMediaItems.find(item => item.url === currentMedia.dataset.url) || bomMediaItems[0];
                    
                    // Update with fresh server data
                    duration = (freshBomData.duration || 30) * 1000; // Convert to milliseconds
                    isDurationActive = freshBomData.is_duration_active || false;
                    
                    // CRITICAL: Update the DOM element's dataset with fresh data
                    currentMedia.dataset.duration = duration;
                    currentMedia.dataset.isDurationActive = isDurationActive;
                    
                    console.log('Fresh BOM duration data retrieved:', {
                        duration: duration,
                        is_duration_active: isDurationActive,
                        fresh_data: freshBomData,
                        url: currentMedia.dataset.url
                    });
                } else {
                    console.warn('No BOM items found in fresh data, using cached values');
                }
            } else {
                console.warn('Failed to fetch fresh duration data, using cached values');
            }
        } catch (error) {
            console.error('Error fetching fresh duration data:', error, 'using cached values');
        }
    }

    console.log('Final Media Duration Info:', {
        duration: duration,
        is_duration_active: isDurationActive,
        media_type: currentMedia.dataset.mediaType,
        is_bom: currentMedia.classList.contains('bom'),
        element_dataset_duration: currentMedia.dataset.isDurationActive // For debugging
    });

    if (currentMedia.tagName === 'VIDEO') {
        currentMedia.play().catch(error => {
            console.error('Error playing video:', error);
            this.switchMedia();
        });
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        
    } else if (currentMedia.classList.contains('pdf')) {
        // Enhanced: Longer duration for PDFs on large screens
        duration = currentMedia.dataset.duration; // 60 seconds for PDFs
        console.log(`Displaying PDF: ${currentMedia.dataset.url}`);
        
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        
    } else if (currentMedia.classList.contains('bom')) {
        console.log('Displaying BOM with FRESH duration info:', {
            duration: duration,
            is_duration_active: isDurationActive,
            bom_type: currentMedia.dataset.mediaType
        });
        
        this.stopAutoBomPagination();

        if (isDurationActive) {
            console.log('BOM duration IS active - starting auto pagination');
            // Start automatic BOM pagination
            this.startAutoBomPagination(duration);
        } else {
            console.log('BOM duration is NOT active - will stay until manual advance');
            // Stop any existing auto pagination
            this.isBomAutoPaginationActive = false;
            this.stopAutoBomPagination();
        }

    } else {
        console.log('Displaying other media type with duration:', currentMedia.dataset.duration);
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

        // NEW: Start automatic BOM pagination
async startAutoBomPagination(duration) {
    // Stop any existing pagination timer
    this.stopAutoBomPagination();
    
    try {
        // Get current BOM pagination info
        const paginationResponse = await fetch(`/station/${this.stationId}/bom-paginated/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const currentPage = paginationData.pagination ? paginationData.pagination.current_page : 1;
            const totalPages = paginationData.pagination ? paginationData.pagination.total_pages : 1;
            
            this.currentBomTotalPages = totalPages;
            
            console.log(`Starting auto BOM pagination: Page ${currentPage}/${totalPages}, Duration: ${duration}ms`);
            
            if (totalPages > 1) {
                this.isBomAutoPaginationActive = true;
                this.scheduleNextBomPage(duration);
                
                // Show indicator that auto pagination is active
                this.showClickAlert(`Auto BOM: Page ${currentPage}/${totalPages} (${duration/1000}s)`, false);
            } else {
                console.log('BOM has only 1 page, no auto pagination needed');
                // If only 1 page, set timer to advance to next media
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('Failed to get BOM pagination info');
            // Fallback: advance to next media
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    } catch (error) {
        console.error('Error starting auto BOM pagination:', error);
        // Fallback: advance to next media
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

// NEW: Schedule next BOM page
scheduleNextBomPage(duration) {
    this.autoBomPaginationTimer = setTimeout(async () => {
        await this.advanceAutoBomPage(duration);
    }, duration);
}

// NEW: Advance to next BOM page automatically
async advanceAutoBomPage(duration) {
    if (!this.isBomAutoPaginationActive) return;
    
    try {
        // Get current pagination state
        const paginationResponse = await fetch(`/station/${this.stationId}/bom-paginated/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const currentPage = paginationData.pagination ? paginationData.pagination.current_page : 1;
            const totalPages = paginationData.pagination ? paginationData.pagination.total_pages : 1;
            
            console.log(`Auto BOM pagination: Currently on page ${currentPage}/${totalPages}`);
            
            let nextAction;
            let nextPage;
            
            if (currentPage < totalPages) {
                // Go to next page
                nextAction = 'next_page';
                nextPage = currentPage + 1;
            } else {
                // Loop back to page 1
                nextAction = 'set_page';
                nextPage = 1;
            }
            
            console.log(`Auto BOM pagination: Moving from page ${currentPage} to page ${nextPage}`);
            
            // Call pagination API
            const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    action: nextAction,
                    page: nextPage,
                    mode: this.paginationMode,
                    items_per_screen: this.itemsPerScreen
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log(`Auto BOM pagination successful: Page ${result.current_page}/${result.pagination.total_pages}`);
                
                // Show brief page indicator
                this.showClickAlert(`Auto: Page ${result.current_page}/${result.pagination.total_pages}`, false);
                
                // Refresh BOM content immediately
                await this.refreshBOMContent();
                
                // Check if we should continue auto pagination or switch to next media
                if (result.current_page === 1 && currentPage === totalPages) {
                    // We've completed a full cycle, switch to next media
                    console.log('Auto BOM pagination completed full cycle, switching to next media');
                    this.stopAutoBomPagination();
                    this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                } else {
                    // Continue auto pagination
                    this.scheduleNextBomPage(duration);
                }
                
            } else {
                console.error('Auto BOM pagination failed:', result.error);
                this.stopAutoBomPagination();
                // Fallback: switch to next media
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('Failed to get current BOM pagination state');
            this.stopAutoBomPagination();
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
        
    } catch (error) {
        console.error('Error in auto BOM pagination:', error);
        this.stopAutoBomPagination();
        // Fallback: switch to next media
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

// NEW: Stop automatic BOM pagination
stopAutoBomPagination() {
    if (this.autoBomPaginationTimer) {
        clearTimeout(this.autoBomPaginationTimer);
        this.autoBomPaginationTimer = null;
        console.log('Auto BOM pagination timer cleared');
    }
    this.isBomAutoPaginationActive = false;
}


        isCurrentPDF() {
            const currentElement = this.mediaElements[this.currentIndex];
            return currentElement && currentElement.classList.contains('pdf');
        }

        stopCurrentMedia() {
            if (this.mediaElements.length === 0) return;
            
            const currentMedia = this.mediaElements[this.currentIndex];
            if (!currentMedia) return;

            if (currentMedia.tagName === 'VIDEO') {
                currentMedia.pause();
                currentMedia.currentTime = 0;
            }
            
            // Reset PDF fullscreen when stopping
            if (currentMedia.classList.contains('pdf')) {
                currentMedia.classList.remove('fullscreen');
                this.pdfFullscreen = false;
            }
               // NEW: Stop auto BOM pagination when switching away from BOM
                    if (currentMedia.classList.contains('bom')) {
                        this.stopAutoBomPagination();
                    }
            clearTimeout(this.slideshowTimer);
        }

        switchMedia() {
            if (this.mediaElements.length === 0) return;
            if (this.mediaElements.length === 1) {
                // If only one element and it's BOM, refresh its content periodically
                if (this.isCurrentlyShowingBOM()) {
                    this.refreshCurrentBOMContent();
                }
                this.stopCurrentMedia();
                this.playCurrentMedia();
                return;
            }

            const currentMedia = this.mediaElements[this.currentIndex];
            if (currentMedia) {
                currentMedia.classList.add('fade-out');
                currentMedia.classList.remove('active');
            }
            
            this.stopCurrentMedia();
            this.currentIndex = (this.currentIndex + 1) % this.mediaElements.length;
            
            const nextMedia = this.mediaElements[this.currentIndex];
            if (nextMedia) {
                nextMedia.classList.remove('fade-out');
                nextMedia.classList.add('active');
                
                // If switching to BOM, refresh its content
                if (nextMedia.dataset.mediaType === 'Database BOM' || nextMedia.classList.contains('bom')) {
                    this.loadBOMContent(nextMedia, {});
                }
                
                this.playCurrentMedia();
            }
        }

        handleMediaError(error) {
            console.error('Media error:', error);
            this.showError('Media playback error');
            setTimeout(() => this.switchMedia(), 3000);
        }

        showError(message) {
            this.errorElement.textContent = message;
            this.errorElement.classList.remove('hidden');
        }

        hideError() {
            this.errorElement.classList.add('hidden');
        }

    async sendClickerAction(action, alertMessage) {
        try {
            // CRITICAL: Stop auto loop immediately when ANY manual action is taken
            if (this.autoLoopMode) {
                console.log('Manual action detected - stopping auto loop immediately');
                this.stopAutoLoop();
                
                // Show override message
                this.showClickAlert('Manual Override - Auto Loop Stopped', false);
                
                // Brief delay to show the override message
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            const response = await fetch(`/station/${this.stationId}/clicker/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Clicker action result:', result);
                
                // Update connection status
                this.updateConnectionStatus('connected', 
                    `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
                
                // Handle loop exit messaging
                if (result.exit_loop) {
            //       this.showClickAlert(`Exited Loop Mode ‚Üí ${result.current_process.display_name}`, false);
                //    console.log('Loop mode exited:', result.exit_message);
                    
                    // Update loop indicator immediately
                    this.updateLoopIndicator(false, false);
                } else {
                //  this.showClickAlert(alertMessage || 'Action Completed!');
                }
                
                // DO NOT restart auto loop after manual action
                // The user has taken manual control, so respect that decision
                console.log('Manual action completed - auto loop will NOT restart automatically');
                
                // Force immediate update after clicker action
                setTimeout(async () => {
                    await this.pollForUpdates();
                }, 100);
                
            } else {
                this.showError(result.error || 'Clicker action failed');
                this.showClickAlert('Action Failed!', true);
                setTimeout(() => this.hideError(), 4000);
            }
        } catch (error) {
            console.error('Clicker action error:', error);
            this.showError('Clicker communication error');
            this.showClickAlert('Connection Error!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    }


        // Method to configure auto loop durations
        setAutoLoopDurations(durations) {
            this.loopProcessDurations = { ...this.loopProcessDurations, ...durations };
            console.log('Auto loop durations updated:', this.loopProcessDurations);
        }

        // Method to get current auto loop status
        getAutoLoopStatus() {
            return {
                autoLoopMode: this.autoLoopMode,
                isInLoopGroup: this.isInLoopGroup,
                currentProcessName: this.currentProcessName,
                loopProcessDurations: this.loopProcessDurations,
                timeRemaining: this.autoLoopProgressTimer ? 'active' : 'inactive'
            };
        }

        // Method to force auto loop progression (for testing)
        async forceAutoLoopProgress() {
            if (this.autoLoopMode) {
                await this.autoProgressLoop();
            } else {
                console.warn('Auto loop is not active');
            }
        }

        destroy() {
            // Clean up all timers and intervals
            if (this.pollingInterval) {
                clearInterval(this.pollingInterval);
                this.pollingInterval = null;
            }
            if (this.slideshowTimer) {
                clearTimeout(this.slideshowTimer);
                this.slideshowTimer = null;
            }
            

                // Stop auto BOM pagination
              this.stopAutoBomPagination();

            // Stop auto loop
            this.stopAutoLoop();
            
            // Clean up media elements
            this.stopCurrentMedia();
            
            console.log(`BRG Media Slider Display ${this.displayNumber} destroyed`);
        }
}





    // Initialize the enhanced slider when page loads
    document.addEventListener('DOMContentLoaded', () => {
        const stationId = {{ station.id }};
        const displayNumber = {{ station.display_number }};
        
        // Create the slider instance
        window.mediaSlider = new BRGMediaSliderWithAutoLoop(stationId, displayNumber);
        
        // Optional: Configure custom auto loop durations if needed
        // window.mediaSlider.setAutoLoopDurations({
        //     'PROCESS 1A OF 6': 45000, // 45 seconds
        //     'PROCESS 1B OF 6': 60000, // 60 seconds
        //     'PROCESS 1C OF 6': 30000  // 30 seconds
        // });
        
        // Add global keyboard shortcuts for debugging
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.shiftKey) {
                switch(event.code) {
                    case 'KeyA':
                        // Ctrl+Shift+A: Toggle auto loop
                        if (window.mediaSlider) {
                            window.mediaSlider.toggleAutoLoopMode();
                        }
                        event.preventDefault();
                        break;
                    case 'KeyS':
                        // Ctrl+Shift+S: Show auto loop status
                        if (window.mediaSlider) {
                            const status = window.mediaSlider.getAutoLoopStatus();
                            console.log('Auto Loop Status:', status);
                            window.mediaSlider.showClickAlert(`Auto Loop: ${status.autoLoopMode ? 'ON' : 'OFF'}`, false);
                        }
                        event.preventDefault();
                        break;
                    case 'KeyF':
                        // Ctrl+Shift+F: Force auto loop progress (for testing)
                        if (window.mediaSlider) {
                            window.mediaSlider.forceAutoLoopProgress();
                        }
                        event.preventDefault();
                        break;
                }
            }
        });
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        if (window.mediaSlider) {
            window.mediaSlider.destroy();
        }
    });

    // Expose slider instance globally for debugging
    window.getSliderStatus = () => {
        if (window.mediaSlider) {
            return {
                displayNumber: window.mediaSlider.displayNumber,
                currentIndex: window.mediaSlider.currentIndex,
                mediaCount: window.mediaSlider.mediaElements.length,
                autoLoopStatus: window.mediaSlider.getAutoLoopStatus(),
                currentProcessName: window.mediaSlider.currentProcessName,
                isInLoopGroup: window.mediaSlider.isInLoopGroup
            };
        }
        return null;
    };
</script>
</body>
</html>











 // tmkc 

 <!-- templates/brg_station_slider_enhanced.html - OPTIMIZED FOR LARGE ROTATED DISPLAYS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRG Assembly 40K - Display {{ station.display_number }}</title>
    <style>

body, html {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background-color: #ffffff !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* ENHANCED: Better rotation for portrait monitors */
body {
    transform: rotate(90deg);
    transform-origin: center center;
    width: 100vh;
    height: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    margin-top: -50vw;
    margin-left: -50vh;
    background-color: #ffffff !important;
}

.main-container {
    display: flex;
    flex-direction: column;
    height: 102vw;
    width: 100vh;
    position: relative;
}

/* COMPACT: Reduced header height to maximize content area */
.assembly-header {
    background: #DF2427;
    color: white;
    padding: 18px 30px; /* Increased from 12px 25px */
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 80px; /* Increased from 60px */
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    flex-shrink: 0;
}

.product-info {
    display: flex;
    flex-direction: column;
}

.product-code {
    font-size: 36px; /* Increased from 28px */
    font-weight: bold;
    margin-bottom: 10px; /* Increased from 8px */
    margin-bottom: 8px;
        line-height: 1.2;

}

.process-info {
    font-size: 22px; /* Increased from 18px */
    opacity: 0.9;
        line-height: 1.3;

}

.display-badge {
    background: #DF2427;
    padding: 15px 25px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 24px;
}
.display-badge div {
    font-size: 16px !important; /* Increased from 14px */
    margin-top: 5px !important; /* Increased from 3px */
}

.display-1 { border-left: 5px solid #FF6B6B; }
.display-2 { border-left: 5px solid #4ECDC4; }
.display-3 { border-left: 5px solid #45B7D1; }

/* ENHANCED: Media slider with better flex management */
.slider-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: rgb(255, 255, 255);
    overflow: hidden;
    min-height: 0; /* Important for flex children */
}

.media-element {
    height: 100%;
    width: 100%;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: contain;
    transition: opacity 0.5s ease-in-out;
}

/* COMPLETELY REWRITTEN: PDF styling for large rotated displays */
.media-element.pdf {
    /* MAXIMIZED: Use every pixel available */
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    
    position: absolute;
    top: 62%;
    left: 54%;

    /* ENHANCED: Better PDF rendering */
    object-fit: cover;
    border: none;
    background-color: white;
    
    /* CRITICAL: Force PDF to use full space */
    box-sizing: border-box;
    
    /* ENHANCED: High quality rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    
    /* REMOVE: Any margins or padding that might interfere */
    margin: 0 0 0 0 !important;
    padding: 0 !important;
    /* Centered zoom */
    transform: scale(1.088) translate(-50%, -50%);
    transform-origin: center center;

}

/* ALTERNATIVE: PDF iframe for better control */
.media-element.pdf-iframe {
    width: 100% !important;
    height: 100% !important;
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    border: none;
    background-color: white;
    overflow: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* ENHANCED: PDF controls with better visibility */
.pdf-controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 150;
    display: flex;
    gap: 15px;
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.pdf-controls:hover {
    opacity: 1;
}
.media-element video {
    /* Hardware acceleration */
    transform: translateZ(0);
    will-change: opacity;
    backface-visibility: hidden;
    
    /* Smooth transitions */
    transition: opacity 0.3s ease;
}

.media-element.video-optimized {
    /* Reduce repaints */
    image-rendering: optimizeSpeed;
}
.pdf-control-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.pdf-control-btn:hover {
    background: rgba(0,0,0,1);
    transform: scale(1.1);
}

/* ENHANCED: Fullscreen PDF mode */
.media-element.pdf.fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    z-index: 1000;
    background: white;
    position: fixed !important;
}

.media-element.bom {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
}

.media-element.active {
    display: block;
    opacity: 1;
}

.media-element.fade-out {
    opacity: 0;
}

/* ENHANCED: Better clicker controls for large screens */
.clicker-controls {
    position: absolute;
    bottom: -25px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.clicker-left {
    left: 30px;
}

.clicker-right {
    right: 30px;
}

.clicker-btn {
    background: rgba(52, 152, 219, 0.9);
    border: none;
    border-radius: 50%;
    width: 90px;
    height: 90px;
    color: white;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
}

.clicker-btn:hover {
    background: rgba(52, 152, 219, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.clicker-btn:active {
    transform: scale(0.95);
    background: rgba(41, 128, 185, 1);
}

.clicker-hint {
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    margin-top: 8px;
    white-space: nowrap;
}

.clicker-controls.hidden {
    display: none;
}

/* Enhanced click feedback */
.click-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(46, 204, 113, 0.95);
    color: white;
    padding: 25px 50px;
    border-radius: 30px;
    font-size: 22px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
    transition: all 0.3s ease;
}

.click-alert.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.click-alert.error {
    background: rgba(231, 76, 60, 0.95);
}

/* COMPACT: Reduced status bar height to reclaim space */
.status-bar {
    background: rgba(246, 246, 246, 0.9);
    color: white;
    padding: 4px 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
    flex-shrink: 0;
    font-size: 14px;
}

.loop-indicator {
    background: #f39c12;
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 2s infinite;
}

.loop-indicator.hidden {
    display: none;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.connection-status {
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.connection-status.visible { opacity: 1; }
.connection-status.connected { background-color: #27ae60; color: white; }
.connection-status.disconnected { background-color: #e74c3c; color: white; }
.connection-status.reconnecting { background-color: #f39c12; color: white; }

/* Navigation hints */
.navigation-hints {
    background: rgba(52, 152, 219, 0.2);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.navigation-hints.hidden {
    display: none;
}

/* ENHANCED: Media type indicators */
.media-type-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    backdrop-filter: blur(5px);
}

.bom-indicator { background: rgba(52, 152, 219, 0.8); }
.video-indicator { background: rgba(231, 76, 60, 0.8); }
.doc-indicator { 
    background: rgba(46, 204, 113, 0.8);
    font-size: 18px;
    padding: 15px 25px;
}

/* Error states */
.error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    font-size: 20px;
    z-index: 1000;
}

.error-message.hidden {
    display: none;
}

/* BOM indicator in status bar */
.bom-status {
    background: rgba(52, 152, 219, 0.8);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
}

/* CRITICAL: Responsive scaling for different large monitor sizes */
@media screen and (min-width: 1920px) {
    .product-code { font-size: 42px; }
    .process-info { font-size: 26px; }
    .display-badge { font-size: 28px; padding: 18px 30px; }
    .assembly-header { padding: 20px 35px; min-height: 70px; }
    .status-bar { padding: 10px 30px; font-size: 16px; min-height: 40px; }
    
    .media-element.pdf {
        /* FORCE: Maximum utilization on large screens */
        width: 100% !important;
        height: 100% !important;
    }
}

@media screen and (min-width: 2560px) {
    .product-code { 
        font-size: 50px; /* Increased from 36px */
        margin-bottom: 15px;
    }
    .process-info { font-size: 30px; }
    .display-badge { font-size: 32x; padding: 18px 30px; }
    .assembly-header { padding: 25px 40px; min-height: 100px; }
    .status-bar { padding: 12px 35px; font-size: 18px; min-height: 45px; }
    
    .pdf-control-btn { width: 70px; height: 70px; font-size: 24px; }
    .clicker-btn { width: 100px; height: 100px; font-size: 32px; }
    
    .media-type-indicator { font-size: 18px; padding: 15px 25px; }
    .doc-indicator { font-size: 20px; padding: 18px 30px; }
}

@media screen and (min-width: 3440px) {
    .assembly-header { 
        padding: 30px 45px; 
        min-height: 130px; /* Increased from 90px */
    }
    .product-code { 
        font-size: 58px; /* Increased from 40px */
        margin-bottom: 18px;
    }
    .process-info { 
        font-size: 34px; /* Increased from 24px */
    }
    .display-badge { 
        font-size: 36px; /* Increased from 26px */
        padding: 25px 40px; /* Increased from 20px 35px */
    }

    .status-bar { padding: 15px 40px; font-size: 20px; min-height: 50px; }
    
    .pdf-control-btn { width: 80px; height: 80px; font-size: 28px; }
    .clicker-btn { width: 110px; height: 110px; font-size: 36px; }
    
    .media-type-indicator { font-size: 20px; padding: 18px 30px; }
    .doc-indicator { font-size: 24px; padding: 20px 35px; }
}

/* ULTRA-WIDE: 4K and above optimizations */
@media screen and (min-width: 4096px) {
    .assembly-header { 
        padding: 35px 50px; 
        min-height: 150px; /* Increased from 100px */
    }
    .product-code { 
        font-size: 66px; /* Increased from 44px */
        margin-bottom: 20px;
    }
    .process-info { 
        font-size: 38px; /* Increased from 26px */
    }
    .display-badge { 
        font-size: 40px; /* Increased from 28px */
        padding: 28px 45px; /* Increased from 25px 40px */
    }
    .status-bar { padding: 18px 45px; font-size: 22px; min-height: 55px; }
    
    .pdf-control-btn { width: 90px; height: 90px; font-size: 32px; }
    .clicker-btn { width: 120px; height: 120px; font-size: 40px; }
    
    .media-type-indicator { font-size: 22px; padding: 20px 35px; }
    .doc-indicator { font-size: 26px; padding: 25px 40px; }
}

/* PDF LOADING INDICATOR */
.pdf-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #333;
    font-size: 24px;
    z-index: 50;
    background: rgba(255, 255, 255, 0.9);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.pdf-loading::after {
    content: "...";
    animation: dots 2s infinite;
}

@keyframes dots {
    0%, 20% { content: ""; }
    40% { content: "."; }
    60% { content: ".."; }
    80%, 100% { content: "..."; }
}

/* ZOOM ENHANCEMENT: Better PDF zoom controls */
.pdf-zoom-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 120;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pdf-zoom-info.visible {
    opacity: 1;
}

/* DEBUG: Temporary border to see PDF boundaries (remove in production) */
.media-element.pdf.debug {
    border: 3px solid red !important;
}

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Assembly Header -->
        <div class="assembly-header display-{{ station.display_number }}">
            <div class="product-info">
                <div class="product-code" id="product-code">
                    {% if current_product %}{{ current_product.code }}{% else %}No Product Selected{% endif %}
                </div>
                <div class="process-info" id="process-info">
                    {% if current_process %}
                        {{ current_stage.display_name }} - {{ current_process.display_name }}
                    {% else %}
                        No Process Selected
                    {% endif %}
                </div>
            </div>
            <div class="display-badge">
                Display {{ station.display_number }}
                <div style="font-size: 14px; margin-top: 3px;">
                    {% if station.display_number == 1 %}BOMs & Reference
                    {% elif station.display_number == 2 %}Process Instructions  
                    {% else %}Instructional Videos{% endif %}
                </div>
            </div>
        </div>

        <!-- Media Slider -->
        <div class="slider-container" id="slider-container">
            <!-- Left Clicker Controls -->
<div class="clicker-controls clicker-left {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="left-controls">
    <button class="clicker-btn" id="backward-btn" title="Previous Process">
        &#8592;
    </button>
    <div class="clicker-hint">‚Üê Previous</div>
</div>

            <!-- Right Clicker Controls -->
<div class="clicker-controls clicker-right {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="right-controls">
    <button class="clicker-btn" id="forward-btn" title="Next Process">
        &#8594;
    </button>
    <div class="clicker-hint">Next ‚Üí</div>
</div>

            <div class="error-message hidden" id="error-message">
                <div>‚ö†Ô∏è Connection Error</div>
                <div style="font-size: 16px; margin-top: 15px;">
                    Please check network connection or contact supervisor
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            {% if has_bom_data %}
            <div class="bom-status" id="bom-status">
                üìã BOM: {{ bom_item_count }} items
            </div>
            {% endif %}
            
            <div class="loop-indicator {% if not loop_mode %}hidden{% endif %}" id="loop-indicator">
                üîÑ LOOP MODE - Processes 1A, 1B, 1C
            </div>
            <div id="connection-status" class="connection-status">Connecting...</div>
        </div>

        <!-- Click Feedback Alert -->
        <div class="click-alert" id="click-alert">
            Action Completed!
        </div>
    </div>

    <script>
// COMPLETE FIXED SCRIPT - NO MORE PAGE REVERT ISSUE
class OptimizedVideoManager {
    constructor() {
        this.videoCache = new Map();
        this.preloadQueue = [];
        this.maxCacheSize = 3;
        this.videoBufferSize = 1;
    }

    createOptimizedVideoElement(media, index) {
        const video = document.createElement('video');
        video.src = media.url;
        video.className = 'media-element video-optimized';
        video.preload = index === 0 ? 'auto' : 'metadata';
        video.controls = false;
        video.loop = false;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        
        video.setAttribute('webkit-playsinline', 'true');
        video.setAttribute('playsinline', 'true');
        video.setAttribute('x-webkit-airplay', 'allow');
        
        video.addEventListener('loadstart', () => {
            console.log(`Video ${index} load started`);
        });
        
        video.addEventListener('canplaythrough', () => {
            console.log(`Video ${index} can play through`);
            this.videoCache.set(media.url, video);
            this.manageCacheSize();
        });
        
        video.addEventListener('loadedmetadata', () => {
            console.log(`Video ${index} metadata loaded - Duration: ${video.duration}s`);
        });
        
        video.addEventListener('error', (e) => {
            console.error(`Video ${index} error:`, e);
            this.handleVideoError(video, media, index);
        });
        
        video.addEventListener('stalled', () => {
            console.warn(`Video ${index} stalled, attempting recovery`);
            this.recoverStalledVideo(video);
        });
        
        video.addEventListener('waiting', () => {
            console.warn(`Video ${index} buffering...`);
        });
        
        return video;
    }
    
    preloadNextVideos(currentIndex, mediaElements) {
        const nextIndex = (currentIndex + 1) % mediaElements.length;
        const nextVideo = mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload !== 'auto') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'auto';
            nextVideo.load();
        }
    }
    
    manageCacheSize() {
        if (this.videoCache.size > this.maxCacheSize) {
            const oldestKey = this.videoCache.keys().next().value;
            const oldVideo = this.videoCache.get(oldestKey);
            if (oldVideo && !oldVideo.classList.contains('active')) {
                oldVideo.src = '';
                this.videoCache.delete(oldestKey);
                console.log(`Removed cached video: ${oldestKey}`);
            }
        }
    }
    
    handleVideoError(video, media, index, retryCount = 0) {
        const maxRetries = 2;
        
        if (retryCount < maxRetries) {
            console.log(`Retrying video ${index}, attempt ${retryCount + 1}`);
            setTimeout(() => {
                video.load();
                this.handleVideoError(video, media, index, retryCount + 1);
            }, 1000 * (retryCount + 1));
        } else {
            console.error(`Video ${index} failed after ${maxRetries} retries`);
            this.showVideoErrorPlaceholder(video, media);
        }
    }
    
    recoverStalledVideo(video) {
        const currentTime = video.currentTime;
        video.load();
        video.addEventListener('loadedmetadata', () => {
            video.currentTime = currentTime;
        }, { once: true });
    }
    
    showVideoErrorPlaceholder(video, media) {
        const container = video.parentElement;
        const errorDiv = document.createElement('div');
        errorDiv.className = 'video-error-placeholder';
        errorDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: #2c3e50; color: white; font-size: 24px;">
                <div style="font-size: 48px; margin-bottom: 20px;">üé•</div>
                <div>Video Unavailable</div>
                <div style="font-size: 16px; margin-top: 10px; opacity: 0.7;">
                    ${media.url.split('/').pop()}
                </div>
            </div>
        `;
        container.appendChild(errorDiv);
        video.style.display = 'none';
    }
    
    async playVideoOptimized(video) {
        try {
            if (video.readyState < 3) {
                console.log('Video not ready, waiting...');
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (video.readyState >= 3) {
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }
            
            await video.play();
            console.log('Video playing successfully');
            return true;
        } catch (error) {
            console.error('Video play error:', error);
            
            if (error.name === 'NotAllowedError') {
                video.muted = true;
                try {
                    await video.play();
                    return true;
                } catch (mutedError) {
                    console.error('Muted video play also failed:', mutedError);
                }
            }
            
            return false;
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.currentTime = 0;
            video.removeAttribute('src');
            video.load();
        }
    }
}

class VideoMemoryManager {
    constructor() {
        this.activeVideos = new Set();
        this.maxActiveVideos = 2;
    }
    
    registerVideo(video) {
        this.activeVideos.add(video);
        this.enforceMemoryLimits();
    }
    
    unregisterVideo(video) {
        this.activeVideos.delete(video);
        this.cleanupVideo(video);
    }
    
    enforceMemoryLimits() {
        if (this.activeVideos.size > this.maxActiveVideos) {
            const videosArray = Array.from(this.activeVideos);
            const oldestVideo = videosArray[0];
            this.unregisterVideo(oldestVideo);
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.removeAttribute('src');
            video.load();
        }
    }
    
    cleanup() {
        this.activeVideos.forEach(video => this.cleanupVideo(video));
        this.activeVideos.clear();
    }
}

// MAIN CLASS - COMPLETE REWRITE WITH FIXED PAGINATION
class BRGMediaSliderWithAutoLoop {
    constructor(stationId, displayNumber) {
        this.stationId = stationId;
        this.displayNumber = displayNumber;
        this.currentIndex = 0;
        this.mediaElements = [];
        this.slideshowTimer = null;
        this.pollingInterval = null;
        this.pollingDelay = 1000;
        this.lastDataHash = null;
        this.lastBomPaginationHash = null; // FIXED: Proper variable name
        this.pdfFullscreen = false;
        this.currentPdfZoom = 1.0;
        
        // Auto loop properties
        this.autoLoopMode = false;
        this.autoLoopTimer = null;
        this.autoLoopProgressTimer = null;
        this.loopProcessDurations = {
            'PROCESS 1A OF 6': 30000,
            'PROCESS 1B OF 6': 30000,
            'PROCESS 1C OF 6': 30000
        };

        // CRITICAL: BOM pagination properties - FIXED
        this.autoBomPaginationTimer = null;
        this.currentBomTotalPages = 1;
        this.isBomAutoPaginationActive = false;
        this.ignoreExternalBOMUpdates = false; // CRITICAL: Fixed missing semicolon
        this.isManualPaginationInProgress = false;
        this.currentBomPage = 1;
        this.manualPaginationCooldown = false; // NEW: Additional protection
        
        this.currentProcessName = null;
        this.isInLoopGroup = false;
        this.paginationMode = 'split';
        this.itemsPerScreen = 8;

        // DOM elements
        this.containerElement = document.getElementById('slider-container');
        this.statusElement = document.getElementById('connection-status');
        this.errorElement = document.getElementById('error-message');
        this.productCodeElement = document.getElementById('product-code');
        this.processInfoElement = document.getElementById('process-info');
        this.loopIndicatorElement = document.getElementById('loop-indicator');
        this.leftControlsElement = document.getElementById('left-controls');
        this.rightControlsElement = document.getElementById('right-controls');
        this.clickAlertElement = document.getElementById('click-alert');
        this.bomStatusElement = document.getElementById('bom-status');
        
        this.startPolling();
        this.setupKeyboardListeners();
        this.setupClickerListeners();
        this.logScreenInfo();
    }

    logScreenInfo() {
        console.log('Screen Information:', {
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            screenWidth: screen.width,
            screenHeight: screen.height,
            devicePixelRatio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.angle : 'unknown'
        });
    }

    async startPolling() {
        await this.pollForUpdates();
        this.pollingInterval = setInterval(async () => {
            await this.pollForUpdates();
        }, this.pollingDelay);
    }

async pollForUpdates() {
    try {
        let mediaEndpoint = `/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`;
        
        const mediaResponse = await fetch(mediaEndpoint);
        if (!mediaResponse.ok) {
            throw new Error(`HTTP ${mediaResponse.status}`);
        }
        const mediaData = await mediaResponse.json();
        
        // FIX 2: Check for process changes that should reset pagination
        const currentProcessName = mediaData.station_info?.current_process?.name;
        const processChanged = this.currentProcessName && (this.currentProcessName !== currentProcessName);
        
        if (processChanged) {
            console.log(`üîÑ Process changed from ${this.currentProcessName} to ${currentProcessName} - resetting pagination state`);
            
            // CRITICAL: Reset all manual pagination protection when process changes
            this.isManualPaginationInProgress = false;
            this.ignoreExternalBOMUpdates = false;
            this.manualPaginationCooldown = false;
            this.stopAutoBomPagination();
            
            // Force reset BOM to page 1 for new process
            if (this.isCurrentlyShowingBOM()) {
                try {
                    console.log('üîÑ Resetting BOM to page 1 for new process...');
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log('‚úÖ BOM pagination reset to page 1 for new process');
                            this.showClickAlert(`New Process: ${currentProcessName} - Reset to Page 1`, false);
                        }
                    }
                } catch (resetError) {
                    console.warn('‚ö†Ô∏è Could not reset BOM pagination for new process:', resetError);
                }
            }
        }
        
        // Get current BOM pagination state for sync detection
        let currentBomPage = 1;
        let totalBomPages = 1;
        let bomPaginationHash = '';
        
        try {
            const bomPaginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
            if (bomPaginationResponse.ok) {
                const bomPaginationData = await bomPaginationResponse.json();
                const mediaItem = bomPaginationData.media?.[0];
                currentBomPage = mediaItem?.pagination?.current_page ?? 1;
                totalBomPages = mediaItem?.pagination?.total_pages ?? 1;
                bomPaginationHash = `${currentBomPage}_${totalBomPages}_${this.paginationMode}_${this.itemsPerScreen}`;
            }
        } catch (bomError) {
            console.warn('Could not fetch BOM pagination state:', bomError);
        }
        
        // Create hash for change detection
        const mediaHash = JSON.stringify({
            media: mediaData.media ? mediaData.media.map(m => ({ 
                id: m.id, 
                url: m.url, 
                type: m.type,
                is_bom_data: m.is_bom_data,
                bom_type: m.bom_type,
                bom_hash: m.bom_hash
            })) : [],
            station: mediaData.station_info,
            bom_pagination: bomPaginationHash
        });
        
        // Check what changed
        const mediaChanged = mediaHash !== this.lastDataHash;
        const bomPaginationChanged = bomPaginationHash !== this.lastBomPaginationHash;
        
        // FIX 2: Allow updates when process changes, even during manual pagination
        if ((bomPaginationChanged || mediaChanged) && 
            (this.ignoreExternalBOMUpdates || this.isManualPaginationInProgress || this.manualPaginationCooldown) &&
            !processChanged) { // FIXED: Allow updates when process changes
            console.log(`Display ${this.displayNumber}: Ignoring external updates - manual pagination active (but not process change)`);
            return;
        }
        
        if (mediaChanged || bomPaginationChanged || processChanged) {
            console.log(`Display ${this.displayNumber} update detected:`, { 
                mediaChanged, 
                bomPaginationChanged,
                processChanged,
                currentBomPage,
                totalBomPages,
                displayNumber: this.displayNumber
            });
            
            // Handle pagination changes differently from media changes
            if (bomPaginationChanged && !mediaChanged && !processChanged) {
                console.log(`Display ${this.displayNumber}: BOM pagination changed externally - syncing to page ${currentBomPage}/${totalBomPages}`);
                
                if (this.isCurrentlyShowingBOM()) {
                    await this.refreshBOMContent();
                    this.showClickAlert(`Synced: Page ${currentBomPage}/${totalBomPages}`, false);
                } else {
                    await this.refreshBOMContent();
                }

                this.lastBomPaginationHash = bomPaginationHash;
            } 
            else {
                // Handle normal media changes or process changes
                this.checkAutoLoopMode(mediaData);
                this.updateAssemblyInfo(mediaData, null);
                this.updateMedia(mediaData, null, false);
                this.playCurrentMedia();
                
                if (this.isCurrentlyShowingBOM()) {
                    console.log('Detected BOM slide after media update, refreshing content...');
                    this.refreshCurrentBOMContent();
                }

                this.hideError();
                this.updateConnectionStatus('connected', 'Updated');
                
                this.lastDataHash = mediaHash;
                this.lastBomPaginationHash = bomPaginationHash;
            }
        }
        
    } catch (error) {
        console.error(`Display ${this.displayNumber} polling error:`, error);
        this.showError('Connection error. Retrying...');
        this.updateConnectionStatus('disconnected', 'Connection Lost');
    }
}

    async sendClickerAction(action, alertMessage) {
        try {
            if (this.autoLoopMode) {
                console.log('Manual action detected - stopping auto loop immediately');
                this.stopAutoLoop();
                this.showClickAlert('Manual Override - Auto Loop Stopped', false);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            const response = await fetch(`/station/${this.stationId}/clicker/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Clicker action result:', result);
                
                if (result.pagination_reset) {
                    console.log('Pagination was reset due to process change');
                    setTimeout(async () => {
                        console.log('Forcing media refresh after pagination reset...');
                        await this.pollForUpdates();
                    }, 300);
                }
                
                this.updateConnectionStatus('connected', 
                    `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
                
                if (result.exit_loop) {
                    this.updateLoopIndicator(false, false);
                }
                
                console.log('Manual action completed - auto loop will NOT restart automatically');
                
                if (!result.pagination_reset) {
                    setTimeout(async () => {
                        await this.pollForUpdates();
                    }, 200);
                }
                
            } else {
                this.showError(result.error || 'Clicker action failed');
                this.showClickAlert('Action Failed!', true);
                setTimeout(() => this.hideError(), 4000);
            }
        } catch (error) {
            console.error('Clicker action error:', error);
            this.showError('Clicker communication error');
            this.showClickAlert('Connection Error!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    }

    checkAutoLoopMode(data) {
        if (!data.station_info || !data.station_info.current_process) {
            this.stopAutoLoop();
            return;
        }
        
        const currentProcess = data.station_info.current_process;
        const isInLoopGroup = currentProcess.loop_group === 'final_assembly_1abc';
        const isLoopMode = data.station_info.loop_mode;
        const processChanged = this.currentProcessName !== currentProcess.name;
        
        console.log('Auto loop check:', {
            currentProcess: currentProcess.name,
            isInLoopGroup,
            isLoopMode,
            processChanged,
            autoLoopMode: this.autoLoopMode,
            previousProcess: this.currentProcessName
        });
        
        const previousProcessName = this.currentProcessName;
        this.currentProcessName = currentProcess.name;
        this.isInLoopGroup = isInLoopGroup;
        
        if (this.autoLoopMode && (!isInLoopGroup || !isLoopMode)) {
            console.log('Exiting auto loop - no longer in loop group or loop mode disabled');
            this.stopAutoLoop();
            
            if (!isInLoopGroup && previousProcessName) {
                this.showClickAlert(`Moved to ${currentProcess.display_name} - Loop Exited`, false);
            }
        }
        else if (isInLoopGroup && isLoopMode && currentProcess.name === 'PROCESS 1A OF 6') {
            if (!this.autoLoopMode || processChanged) {
                console.log('Starting auto loop - entered Process 1A');
                this.startAutoLoop(currentProcess.name);
            }
        }
        else if (isInLoopGroup && isLoopMode && this.autoLoopMode && processChanged) {
            console.log('Restarting auto loop for new process:', currentProcess.name);
            this.startAutoLoop(currentProcess.name);
        }
        else if (!isInLoopGroup || !isLoopMode) {
            if (this.autoLoopMode) {
                console.log('Stopping auto loop - conditions not met');
                this.stopAutoLoop();
            }
        }
        
        this.updateLoopIndicator(isInLoopGroup, isLoopMode);
    }

    updateLoopIndicator(isInLoopGroup, isLoopMode) {
        if (isInLoopGroup && isLoopMode && this.autoLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ AUTO LOOP ACTIVE - 1A ‚Üí 1B ‚Üí 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#27ae60';
            this.loopIndicatorElement.classList.add('auto-mode');
        } else if (isInLoopGroup && isLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ LOOP MODE (Manual) - 1A, 1B, 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#f39c12';
            this.loopIndicatorElement.classList.remove('auto-mode');
        } else {
            this.loopIndicatorElement.classList.add('hidden');
            this.loopIndicatorElement.classList.remove('auto-mode');
        }
    }

    startAutoLoop(processName) {
        console.log(`Starting auto loop mode for process: ${processName}`);
        
        this.stopAutoLoop();
        this.autoLoopMode = true;
        
        const duration = this.loopProcessDurations[processName] || 30000;
        
        console.log(`Auto loop timer set for ${duration}ms (${duration/1000}s) for ${processName}`);
        
        this.autoLoopProgressTimer = setTimeout(async () => {
            await this.autoProgressLoop();
        }, duration);
        
        this.showClickAlert(`Auto Loop: ${processName} (${duration/1000}s)`, false);
    }

    stopAutoLoop() {
        if (this.autoLoopProgressTimer) {
            clearTimeout(this.autoLoopProgressTimer);
            this.autoLoopProgressTimer = null;
            console.log('Auto loop timer cleared');
        }
        
        if (this.autoLoopTimer) {
            clearTimeout(this.autoLoopTimer);
            this.autoLoopTimer = null;
        }
        
        this.autoLoopMode = false;
        console.log('Auto loop mode stopped');
    }

    async autoProgressLoop() {
        try {
            console.log('Auto-progressing loop from:', this.currentProcessName);
            
            const response = await fetch(`/station/${this.stationId}/auto-loop-progress/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Auto loop progression successful:', result.current_process.name);
                this.showClickAlert(`Auto: ${result.current_process.display_name}`, false);
                
                setTimeout(async () => {
                    await this.pollForUpdates();
                }, 200);
                
            } else {
                console.error('Auto loop progression failed:', result.error);
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Error', true);
            }
        } catch (error) {
            console.error('Auto loop progression error:', error);
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Connection Error', true);
        }
    }

    setupKeyboardListeners() {
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowRight') {
                console.log('Manual forward key pressed');
                this.sendClickerAction('forward', 'Manual Forward ‚û§');
                event.preventDefault();
            } else if (event.code === 'ArrowLeft') {
                console.log('Manual backward key pressed');
                this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
                event.preventDefault();
            } else if (event.code === 'ArrowDown') {
                if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                    console.log('Manual BOM page navigation (down arrow) - next page');
                    this.navigateBOMPage('next_page');
                    event.preventDefault();
                } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                    console.log('Down arrow pressed but BOM auto-pagination is active - ignoring manual input');
                    this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                    event.preventDefault();
                } else {
                    console.log('Down arrow pressed but not on BOM slide - no action');
                }
            } else if (event.code === 'ArrowUp') {
                if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                    console.log('Manual BOM page navigation (up arrow) - previous page');
                    this.navigateBOMPage('previous_page');
                    event.preventDefault();
                } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                    console.log('Up arrow pressed but BOM auto-pagination is active - ignoring manual input');
                    this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                    event.preventDefault();
                } else {
                    console.log('Up arrow pressed but not on BOM slide - no action');
                }
            } else if (event.code === 'Space') {
                console.log('Space pressed - toggling loop mode');
                this.sendClickerAction('toggle_loop', 'Loop Mode Toggled');
                event.preventDefault();
            } else if (event.code === 'Escape') {
                if (this.autoLoopMode) {
                    console.log('ESC pressed - stopping auto loop');
                    this.stopAutoLoop();
                    this.showClickAlert('Auto Loop Stopped (Manual)', false);
                } else if (this.pdfFullscreen) {
                    this.togglePDFFullscreen();
                }
                event.preventDefault();
            }
            else if (event.code === 'PageDown' || (event.code === 'ArrowDown' && event.ctrlKey)) {
                console.log('Page Down pressed - next BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('next_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'PageUp' || (event.code === 'ArrowUp' && event.ctrlKey)) {
                console.log('Page Up pressed - previous BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('previous_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'KeyM' && event.ctrlKey) {
                console.log('Ctrl+M pressed - toggle pagination mode');
                this.togglePaginationMode();
                event.preventDefault();
            }
        });
    }

    isCurrentBOMDurationActive() {
        if (!this.isCurrentlyShowingBOM()) return false;
        
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement) return false;
        
        const isDurationActive = currentElement.dataset.isDurationActive === 'true';
        
        console.log('Checking current BOM duration status:', {
            is_duration_active: isDurationActive,
            dataset_value: currentElement.dataset.isDurationActive,
            is_auto_pagination_active: this.isBomAutoPaginationActive
        });
        
        return isDurationActive;
    }

    // CRITICAL FIX: Completely rewritten navigation method that prevents auto-refresh conflicts
// FIX 2: Enhanced navigateBOMPage with shorter cooldown for process changes
async navigateBOMPage(action) {
    // Prevent multiple simultaneous pagination calls
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Pagination already in progress or in cooldown, ignoring duplicate call');
        return;
    }
    
    console.log(`=== MANUAL BOM PAGINATION START: ${action} ===`);
    
    // Set STRONGER protection flags
    this.isManualPaginationInProgress = true;
    this.ignoreExternalBOMUpdates = true;
    this.manualPaginationCooldown = true;
    
    // CRITICAL: Stop ALL polling and timers immediately
    if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        console.log('üõë STOPPED polling during manual pagination');
    }
    
    try {
        // Stop ALL auto-refresh mechanisms
        this.stopAutoBomPagination();
        this.stopAllBOMRefreshTimers();
        
        console.log(`Manual BOM pagination: ${action} requested`);

        const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                action: action,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });

        const result = await response.json();

        if (result.success) {
            console.log('‚úÖ Manual BOM pagination SUCCESS:', result);

            // Update internal state IMMEDIATELY to prevent revert
            this.currentBomPage = result.current_page;
            this.currentBomTotalPages = result.pagination.total_pages;
            
            // CRITICAL: Update hash to prevent external interference
            const newBomHash = `${result.current_page}_${result.pagination.total_pages}_${this.paginationMode}_${this.itemsPerScreen}`;
            this.lastBomPaginationHash = newBomHash;

            // Show success message
            let message = `Page ${result.current_page}/${result.pagination.total_pages}`;
            if (action === 'next_page') {
                message = `Next: ${message}`;
            } else if (action === 'previous_page') {
                message = `Prev: ${message}`;
            }
            this.showClickAlert(message, false);

            // Find and update active BOM element WITHOUT auto-refresh
            const activeBOM = this.mediaElements.find(el => 
                el.classList.contains('active') && el.classList.contains('bom')
            );
            
            if (activeBOM) {
                console.log('üîÑ Updating active BOM element with new page data');
                
                // Create fresh media object with pagination data
                const freshBomData = {
                    url: activeBOM.dataset.url,
                    duration: parseInt(activeBOM.dataset.duration || 30000) / 1000,
                    is_duration_active: activeBOM.dataset.isDurationActive === 'true',
                    is_bom_data: true,
                    bom_type: activeBOM.dataset.mediaType || 'BOM',
                    is_split: true,
                    bom_items: result.pagination.total_items,
                    bom_data: result.bom_data,
                    pagination: result.pagination
                };
                
                // Load new content with auto-refresh DISABLED
                await this.loadSplitBOMContent(activeBOM, freshBomData, false, true);
                
                console.log(`‚úÖ BOM content updated: Page ${result.current_page}/${result.pagination.total_pages}`);
            }

        } else {
            console.error('‚ùå BOM pagination error:', result.error);
            this.showClickAlert('Pagination Error', true);
        }
    } catch (error) {
        console.error('‚ùå BOM pagination error:', error);
        this.showClickAlert('Pagination Connection Error', true);
    } finally {
        // CRITICAL: Extended protection period to prevent external interference
        setTimeout(() => {
            console.log('=== MANUAL PAGINATION COOLDOWN ENDING ===');
            this.isManualPaginationInProgress = false;
            this.manualPaginationCooldown = false;
        }, 2000); // Increased from 1000ms
        
        // Keep external updates disabled longer
        setTimeout(() => {
            console.log('=== RE-ENABLING EXTERNAL UPDATES ===');
            this.ignoreExternalBOMUpdates = false;
        }, 120000); // Increased from 5000ms
        
        // CRITICAL: Restart polling after protection period
        setTimeout(() => {
            console.log('üîÑ RESTARTING polling after manual pagination');
            this.startPolling();
        }, 4000); // Restart polling after 3 seconds
    }
}


    // CRITICAL: Method to stop all BOM refresh timers
    stopAllBOMRefreshTimers() {
        console.log(`=== STOPPING ALL BOM REFRESH TIMERS for display ${this.displayNumber} ===`);
        
        this.mediaElements.forEach((element, index) => {
            if (element.refreshTimer) {
                clearTimeout(element.refreshTimer);
                element.refreshTimer = null;
                console.log(`Cleared BOM refresh timer for element ${index}`);
            }
        });
    }

    togglePaginationMode() {
        this.paginationMode = this.paginationMode === 'split' ? 'single' : 'split';
        this.showClickAlert(`Pagination Mode: ${this.paginationMode.toUpperCase()}`, false);
        
        setTimeout(async () => {
            await this.pollForUpdates();
        }, 200);
    }

    setupClickerListeners() {
        document.getElementById('forward-btn').addEventListener('click', () => {
            this.sendClickerAction('forward', 'Manual Forward ‚û§');
        });

        document.getElementById('backward-btn').addEventListener('click', () => {
            this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
        });

        const autoLoopBtn = document.getElementById('auto-loop-btn');
        if (autoLoopBtn) {
            autoLoopBtn.addEventListener('click', () => {
                this.toggleAutoLoopMode();
            });
        }
    }

    async toggleAutoLoopMode() {
        if (!this.isInLoopGroup) {
            this.showClickAlert('Auto Loop only available in processes 1A, 1B, 1C', true);
            return;
        }

        if (this.autoLoopMode) {
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Disabled', false);
        } else {
            if (this.currentProcessName) {
                this.startAutoLoop(this.currentProcessName);
            }
        }
    }

    togglePDFFullscreen() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement || !currentElement.classList.contains('pdf')) {
            this.showClickAlert('Not a PDF document', true);
            return;
        }

        this.pdfFullscreen = !this.pdfFullscreen;
        
        if (this.pdfFullscreen) {
            currentElement.classList.add('fullscreen');
            this.showClickAlert('PDF Fullscreen Mode (ESC to exit)');
        } else {
            currentElement.classList.remove('fullscreen');
            this.showClickAlert('PDF Normal Mode');
        }
    }

    showClickAlert(message, isError = false) {
        this.clickAlertElement.textContent = message;
        this.clickAlertElement.className = isError ? 'click-alert error show' : 'click-alert show';
        
        setTimeout(() => {
            this.clickAlertElement.classList.remove('show');
        }, 3000);
    }

    updateConnectionStatus(status, message) {
        this.statusElement.className = `connection-status ${status} visible`;
        this.statusElement.textContent = message;
        
        if (status === 'connected') {
            setTimeout(() => {
                this.statusElement.classList.remove('visible');
            }, 2000);
        }
    }

    updateAssemblyInfo(data, bomData) {
        if (data.station_info) {
            const station = data.station_info;
            
            if (station.current_product) {
                this.productCodeElement.textContent = station.current_product.code;
            }
            
            if (station.current_stage && station.current_process) {
                this.processInfoElement.textContent = 
                    `${station.current_stage.name} - ${station.current_process.display_name}`;
            }
            
            if (station.clicker_enabled && this.displayNumber === 2) {
                this.leftControlsElement.classList.remove('hidden');
                this.rightControlsElement.classList.remove('hidden');
            } else {
                this.leftControlsElement.classList.add('hidden');
                this.rightControlsElement.classList.add('hidden');
            }
            
            if (bomData && bomData.bom_data && this.bomStatusElement) {
                const bomType = bomData.bom_template ? bomData.bom_template.bom_type : 'Unknown';
                this.bomStatusElement.textContent = `üìã BOM: ${bomData.bom_data.length} items (${bomType})`;
                this.bomStatusElement.classList.remove('hidden');
            } else if (this.bomStatusElement) {
                this.bomStatusElement.classList.add('hidden');
            }
        }
    }

    updateMedia(data, bomData, forceUpdate = false) {
        let allMedia = [];
        
        const bomMediaItems = data.media ? data.media.filter(m => 
            m.type === 'bom' && 
            m.is_bom_data && 
            m.bom_items > 0
        ) : [];
        
        if (bomMediaItems.length > 0) {
            bomMediaItems.forEach(bomMedia => {
                allMedia.push({
                    id: bomMedia.id,
                    url: bomMedia.url,
                    type: 'bom',
                    duration: bomMedia.duration || 30,
                    is_duration_active: bomMedia.is_duration_active,
                    media_type: bomMedia.media_type || 'Paginated BOM',
                    is_bom_data: true,
                    bom_items: bomMedia.bom_items || 0,
                    bom_type: bomMedia.bom_type,
                    display_info: bomMedia.display_info,
                    is_split: bomMedia.is_split,
                    bom_data: bomMedia.bom_data,
                    pagination: bomMedia.pagination,
                    bom_hash: bomMedia.bom_hash
                });
            });
        }
        
        if (data.media && data.media.length > 0) {
            const nonBomMedia = data.media.filter(m => 
                !(m.type === 'bom' && m.is_bom_data) && 
                m.media_type !== 'Bill of Material'
            );
            
            const processedNonBomMedia = nonBomMedia.map(media => ({
                ...media,
                is_duration_active: media.is_duration_active || false
            }));
            
            allMedia = allMedia.concat(nonBomMedia);
        }
        
        if (allMedia.length === 0) {
            console.warn('No media available for display', this.displayNumber);
            this.showError(`No media available for Display ${this.displayNumber}`);
            return;
        }

        const currentUrls = this.mediaElements.map(el => el.dataset.url);
        const newUrls = allMedia.map(m => m.url);
        
        const shouldUpdate = forceUpdate || JSON.stringify(currentUrls) !== JSON.stringify(newUrls);

        if (shouldUpdate) {
            console.log('Updating paginated media elements for display', this.displayNumber, '...');
            const wasPlayingBom = this.isCurrentlyShowingBOM();
            
            this.clearCurrentMedia();
            this.createNewMediaElements(allMedia);
            
            if (wasPlayingBom && this.hasBOMElement()) {
                this.currentIndex = 0;
            }
            
            this.playCurrentMedia();
        } else {
            console.log('No paginated media update needed for display', this.displayNumber);
        }
    }

    isCurrentlyShowingBOM() {
        if (this.mediaElements.length === 0 || this.currentIndex >= this.mediaElements.length) return false;
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'));
    }

    hasBOMElement() {
        return this.mediaElements.some(el => el.dataset.mediaType === 'Database BOM' || el.classList.contains('bom'));
    }

    clearCurrentMedia() {
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
        }
        this.stopCurrentMedia();
        
        // CRITICAL: Clean up ALL BOM refresh timers before clearing elements
        this.stopAllBOMRefreshTimers();
        
        const mediaChildren = Array.from(this.containerElement.children).filter(
            child => !child.classList.contains('clicker-controls') && 
                    !child.classList.contains('error-message')
        );
        mediaChildren.forEach(child => child.remove());
        this.mediaElements = [];
        this.currentIndex = 0;
        this.pdfFullscreen = false;
    }

    createNewMediaElements(mediaData) {
        mediaData.forEach((media, index) => {
            const mediaElement = this.createMediaElement(media, index);
            if (mediaElement) {
                this.containerElement.appendChild(mediaElement);
                this.mediaElements.push(mediaElement);
            }
        });
    }

    createMediaElement(media, index) {
        let element;
        let indicator;

        if (media.is_bom_data || media.type === 'bom') {
            console.log('Creating BOM element:', media);
            element = document.createElement('div');
            element.className = 'media-element bom';
            element.dataset.url = media.url;
            element.dataset.isDurationActive = media.is_duration_active || false;
            element.dataset.duration = media.duration * 1000;
            element.dataset.bomHash = media.bom_hash || '';

            let bomTypeDisplay = 'BOM';
            if (media.is_split) {
                bomTypeDisplay = 'Split BOM';
                element.dataset.mediaType = 'Split BOM';
            } else if (media.id === 'database_bom') {
                bomTypeDisplay = 'Real-time BOM';
                element.dataset.mediaType = 'Database BOM';
            } else {
                bomTypeDisplay = media.bom_type || 'BOM';
                element.dataset.mediaType = media.media_type || 'BOM';
            }
            
            console.log(`Creating BOM element for display ${this.displayNumber}:`, {
                bomType: bomTypeDisplay,
                mediaType: element.dataset.mediaType,
                url: media.url,
                is_split: media.is_split,
                bom_items: media.bom_items
            });
            
            if (media.is_split && media.bom_data) {
                console.log('Loading split BOM content');
                this.loadSplitBOMContent(element, media);
            } else {
                console.log('Loading database BOM content');
                this.loadBOMContent(element, media);
            }
            
            indicator = document.createElement('div');
            indicator.className = 'media-type-indicator bom-indicator';
            indicator.textContent = `üìã ${bomTypeDisplay}`;
            
        } else {
            const type = media.type.toLowerCase();
            
            if (['mp4', 'mov', 'webm', 'avi'].includes(type)) {
                console.log(`Creating video element ${index}:`, media.url);
                
                element = document.createElement('video');
                element.src = media.url;
                element.className = 'media-element video-optimized';
                element.controls = false;
                element.loop = false;
                element.muted = true;
                element.playsInline = true;
                
                element.preload = index === 0 ? 'metadata' : 'none';
                element.style.transform = 'translateZ(0)';
                element.style.willChange = 'opacity';
                element.style.backfaceVisibility = 'hidden';
                
                let loadTimeout;
                element.addEventListener('loadstart', () => {
                    console.log(`Video ${index} loading started`);
                    loadTimeout = setTimeout(() => {
                        console.warn(`Video ${index} load timeout - skipping`);
                    }, 10000);
                });
                
                element.addEventListener('canplay', () => {
                    console.log(`Video ${index} ready to play`);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                });
                
                element.addEventListener('ended', () => {
                    console.log(`Video ${index} ended naturally`);
                    this.switchMedia();
                });
                
                element.addEventListener('error', (e) => {
                    console.error(`Video ${index} error:`, e);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                    this.showClickAlert('Video Error - Skipping', true);
                    setTimeout(() => this.switchMedia(), 2000);
                });
                
                indicator = document.createElement('div');
                indicator.className = 'media-type-indicator video-indicator';
                indicator.textContent = 'üé• Video';
                
            } else if (type === 'pdf') {
                console.log(`Creating PDF element ${index}:`, media.url);
                element = this.createOptimizedPDFElement(media);
                
            } else {
                console.warn(`Unsupported media type: ${type}`);
                return null;
            }
        }

        if (element) {
            element.dataset.duration = media.duration * 1000;
            element.dataset.url = media.url;
            element.dataset.mediaType = element.dataset.mediaType || media.media_type;
            element.className += index === 0 ? ' active' : '';
            
            if (indicator) {
                element.appendChild(indicator);
            }
        }
        
        return element;
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

    // CRITICAL FIX: Modified loadSplitBOMContent with NO AUTO-REFRESH during manual pagination
async loadSplitBOMContent(element, media, forceResetToPage1 = false, disableAutoRefresh = false) {
    try {
        console.log(`Loading BOM content for display ${this.displayNumber}:`, {
            url: media.url,
            forceReset: forceResetToPage1,
            disableAutoRefresh: disableAutoRefresh,
            currentPagination: media.pagination,
            manualPaginationActive: this.isManualPaginationInProgress
        });

        let currentPage = 1;
        let totalPages = 1;
        
        // CRITICAL FIX: Proper pagination state handling
        if (media.pagination && !forceResetToPage1) {
            // Use pagination from media data if available and not forcing reset
            currentPage = media.pagination.current_page || 1;
            totalPages = media.pagination.total_pages || 1;
            console.log(`Using provided pagination data: Page ${currentPage}/${totalPages}`);
        } else if (!forceResetToPage1) {
            // FIXED: Get current pagination state from backend when not forcing reset
            try {
                console.log("Getting current pagination state from backend...");

                const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?t=${Date.now()}`);
                
                if (paginationResponse.ok) {
                    const paginationData = await paginationResponse.json();
                    const mediaItem = paginationData.media?.[0];

                    currentPage = mediaItem?.pagination?.current_page ?? 1;
                    totalPages = mediaItem?.pagination?.total_pages ?? 1;

                    console.log(`Display ${this.displayNumber}: Current BOM page from backend is ${currentPage}/${totalPages}`);
                } else {
                    console.log(`Display ${this.displayNumber}: Could not get pagination state, using page 1`);
                }
            } catch (paginationError) {
                console.warn(`Display ${this.displayNumber}: Error getting pagination state:`, paginationError);
            }
        }
        
        // Handle force reset to page 1
        if (forceResetToPage1 && currentPage > 1) {
            console.log(`Display ${this.displayNumber}: Force reset requested - resetting to page 1`);
            
            try {
                const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        action: 'set_page',
                        page: 1,
                        mode: this.paginationMode,
                        items_per_screen: this.itemsPerScreen
                    })
                });
                
                if (resetResponse.ok) {
                    const resetResult = await resetResponse.json();
                    if (resetResult.success) {
                        currentPage = 1;
                        console.log(`Display ${this.displayNumber}: Successfully reset to page 1`);
                    }
                }
            } catch (resetError) {
                console.warn(`Display ${this.displayNumber}: Could not reset pagination to page 1:`, resetError);
            }
        }
        
        const timestamp = new Date().getTime();
        const paginationParams = new URLSearchParams({
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // CRITICAL: Use the actual current page
            t: timestamp
        });
        
        console.log(`Loading BOM content with params:`, {
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // LOG the actual page being requested
            url: `${media.url}?${paginationParams}`,
            disableAutoRefresh: disableAutoRefresh,
            manualMode: this.isManualPaginationInProgress
        });
        
        const response = await fetch(`${media.url}?${paginationParams}`);
        
        if (response.ok) {
            const bomHTML = await response.text();
            element.innerHTML = bomHTML;
            console.log(`Paginated BOM content loaded for display ${this.displayNumber} - Page ${currentPage}/${totalPages}`);
            
            // FIXED: Update indicator with correct pagination info
            const indicator = element.querySelector('.media-type-indicator');
            if (indicator) {
                const statusText = this.isBomAutoPaginationActive ? 'Auto Paging' : 'Manual';
                indicator.textContent = `üìã ${media.bom_type || 'BOM'} (Page ${currentPage}/${totalPages} - ${statusText})`;
            }
            
            // CRITICAL: Store the current page in element for future reference
            element.dataset.currentPage = currentPage;
            element.dataset.totalPages = totalPages;
            
        } else {
            console.error(`Failed to load paginated BOM: ${response.status}`);
            element.innerHTML = `
                <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                    <div>Failed to load Paginated BOM data</div>
                    <div style="font-size: 16px; margin-top: 10px;">Status: ${response.status}</div>
                    <div style="font-size: 14px; margin-top: 10px;">URL: ${media.url}?${paginationParams}</div>
                </div>
            `;
        }
        
        // CRITICAL: NEVER set up auto-refresh if manual pagination is active or disabled
        if (!disableAutoRefresh && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
            this.setupBOMContentRefreshTimer(element, media);
        } else {
            console.log(`Auto-refresh DISABLED for display ${this.displayNumber} - manual pagination protection active`);
        }
        
    } catch (error) {
        console.error(`Error loading paginated BOM content for display ${this.displayNumber}:`, error);
        element.innerHTML = `
            <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                <div>Error loading Paginated BOM data</div>
                <div style="font-size: 16px; margin-top: 10px;">${error.message}</div>
            </div>
        `;
    }
}


    // CRITICAL: Modified refresh timer that respects manual pagination
    setupBOMContentRefreshTimer(element, media) {
        // CRITICAL: Never set up refresh timer if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
            console.log(`Skipping BOM refresh timer setup - manual pagination protection active`);
            return;
        }

        if (element.refreshTimer) {
            clearTimeout(element.refreshTimer);
            element.refreshTimer = null;
        }
        
        const isCurrentlyActive = element.classList.contains('active') && this.isCurrentlyShowingBOM();
        
        if (isCurrentlyActive) {
            console.log(`Setting up BOM refresh timer for display ${this.displayNumber} (with manual protection)`);
            
            element.refreshTimer = setTimeout(async () => {
                // Double-check protection flags before refreshing
                if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
                    console.log(`Skipping auto-refresh - manual pagination protection active`);
                    // Reschedule for later
                    this.setupBOMContentRefreshTimer(element, media);
                    return;
                }

                if (element.classList.contains('active') && this.isCurrentlyShowingBOM()) {
                    console.log(`Auto-refreshing BOM content for display ${this.displayNumber}`);
                    
                    try {
                        const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                        
                        if (response.ok) {
                            const freshData = await response.json();
                            
                            const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                                m.type === 'bom' && 
                                m.is_bom_data && 
                                m.bom_items > 0
                            ) : [];
                            
                            if (bomMediaItems.length > 0) {
                                const freshBomData = bomMediaItems.find(item => item.url === element.dataset.url) || bomMediaItems[0];

                                element.dataset.duration = (freshBomData.duration || 30) * 1000;
                                element.dataset.isDurationActive = freshBomData.is_duration_active || false;

                                // also update pagination info
                                const currentPage = freshBomData.pagination?.current_page ?? 1;
                                const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                                element.dataset.currentPage = currentPage;
                                element.dataset.totalPages  = totalPages;

                                // Refresh WITHOUT auto-refresh timer
                                await this.loadSplitBOMContent(element, freshBomData, false, true);
                                
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with fresh data`);
                            } else {
                                await this.loadSplitBOMContent(element, media, false, true);
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with existing data`);
                            }
                        } else {
                            await this.loadSplitBOMContent(element, media, false, true);
                            console.log(`BOM content auto-refreshed for display ${this.displayNumber} (fresh data fetch failed)`);
                        }
                    } catch (refreshError) {
                        console.error(`Error during BOM auto-refresh for display ${this.displayNumber}:`, refreshError);
                    }
                    
                    // Set up next refresh cycle
                    this.setupBOMContentRefreshTimer(element, media);
                } else {
                    console.log(`BOM refresh timer stopped for display ${this.displayNumber} - element no longer active`);
                }
            }, 25000); // Increased to 15 seconds to reduce conflicts
        } else {
            console.log(`No BOM refresh timer set for display ${this.displayNumber} - element not currently active`);
        }
    }

    async refreshBOMContent() {
        // Skip refresh if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
            console.log(`Skipping BOM refresh - manual pagination active`);
            
            return;
        }

        const bomElements = this.mediaElements.filter(el => 
            el.classList.contains('bom') || 
            el.dataset.mediaType === 'Paginated BOM' ||
            el.dataset.mediaType === 'Database BOM'
        );
        
        console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
        
        for (const bomElement of bomElements) {
            const mediaUrl = bomElement.dataset.url;
            if (mediaUrl) {
                console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
                
                try {
                    const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                    
                    if (response.ok) {
                        const freshData = await response.json();
                        
                        const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                            m.type === 'bom' && 
                            m.is_bom_data && 
                            m.bom_items > 0
                        ) : [];
                        
                        if (bomMediaItems.length > 0) {
                            const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                            bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                            bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                            // ‚úÖ add pagination info
                            const currentPage = freshBomData.pagination?.current_page ?? 1;
                            const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                            freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                            await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                            
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh data`);
                        } else {
                            const tempMedia = {
                                url: mediaUrl,
                                bom_type: bomElement.dataset.mediaType || 'BOM',
                                bom_items: 1,
                                pagination: { current_page: 1, total_pages: 1 }
                            };
                            
                            await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback data`);
                        }
                    } else {
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: 1, total_pages: 1 }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with temp data (API failed)`);
                    }
                } catch (error) {
                    console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
                }
            }
        }
    }

    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    createOptimizedPDFElement(media) {
        const container = document.createElement('div');
        container.className = 'media-element pdf';
        
        const iframe = document.createElement('iframe');
        
        const pdfUrl = media.url + '#toolbar=0&navpanes=0&scrollbar=0&view=FitH&zoom=page-width&page-mode=none';
        iframe.src = pdfUrl;
        iframe.className = 'pdf-iframe';
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        
        iframe.style.cssText = `
            width: 100% !important;
            height: 100% !important;
            border: none !important;
            margin: 0 !important;
            padding: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            background: white !important;
        `;
        
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'pdf-loading';
        loadingDiv.textContent = 'Loading PDF Document';
        
        const controlsDiv = this.createPDFControls();
        
        const zoomInfo = document.createElement('div');
        zoomInfo.className = 'pdf-zoom-info';
        zoomInfo.style.display = 'none';
        
        iframe.addEventListener('load', () => {
            console.log('PDF loaded successfully:', media.url);
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            zoomInfo.classList.add('visible');
            setTimeout(() => {
                zoomInfo.classList.remove('visible');
            }, 4000);
            
            this.optimizePDFZoom(iframe);
        });
        
        iframe.addEventListener('error', (e) => {
            console.error('PDF load error:', e);
            this.handlePDFError(container, media);
        });
        
        container.appendChild(iframe);
        container.appendChild(loadingDiv);
        container.appendChild(controlsDiv);
        container.appendChild(zoomInfo);
        
        return container;
    }

    optimizePDFZoom(iframe) {
        try {
            setTimeout(() => {
                const containerWidth = this.containerElement.offsetWidth;
                const containerHeight = this.containerElement.offsetHeight;
                
                console.log('PDF container dimensions:', {
                    width: containerWidth,
                    height: containerHeight,
                    screenRatio: containerWidth / containerHeight
                });
                
                if (iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        action: 'maximizeZoom',
                        containerWidth: containerWidth,
                        containerHeight: containerHeight
                    }, '*');
                }
            }, 1000);
        } catch (error) {
            console.log('Cannot access PDF iframe content (cross-origin):', error);
        }
    }

    createPDFControls() {
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'pdf-controls';
        controlsDiv.style.display = 'none';
        
        return controlsDiv;
    }

    refreshCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.classList.contains('pdf')) {
            const iframe = currentElement.querySelector('iframe');
            if (iframe) {
                const originalSrc = iframe.src;
                iframe.src = '';
                setTimeout(() => {
                    iframe.src = originalSrc + '&refresh=' + Date.now();
                    this.showClickAlert('PDF Refreshed');
                }, 100);
            }
        }
    }

    handlePDFError(pdfElement, media) {
        console.error('PDF failed to load:', media.url);
        
        const loadingDiv = pdfElement.querySelector('.pdf-loading');
        if (loadingDiv) {
            loadingDiv.remove();
        }
        
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(231, 76, 60, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            max-width: 80%;
        `;
        errorDiv.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px;">üìÑ PDF Load Error</div>
            <div style="font-size: 16px; margin-bottom: 15px;">
                Unable to display: ${media.url.split('/').pop()}
            </div>
            <div style="font-size: 14px; opacity: 0.9;">
                Check PDF file format and network connection
            </div>
        `;
        
        pdfElement.appendChild(errorDiv);
        
        setTimeout(() => {
            this.switchMedia();
        }, 8000);
    }

    async loadBOMContent(element, media) {
        try {
            console.log("Loading normal BOM content");
            const timestamp = new Date().getTime();
            const response = await fetch(`/station/${this.stationId}/bom-render-paginated/?t=${timestamp}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log('BOM content refreshed');
            } else {
                element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Failed to load BOM data</div>';
            }
        } catch (error) {
            console.error('Error loading BOM content:', error);
            element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Error loading BOM data</div>';
        }
    }

    async refreshCurrentBOMContent() {
    // Skip if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Skipping current BOM refresh - manual pagination active');
        return;
    }

    const currentElement = this.mediaElements[this.currentIndex];
    if (currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'))) {
        console.log('Refreshing current BOM content...');
        
        try {
            const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
            
            if (response.ok) {
                const freshData = await response.json();
                
                const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                    m.type === 'bom' && 
                    m.is_bom_data && 
                    m.bom_items > 0
                ) : [];
                
                if (bomMediaItems.length > 0) {
                    const freshBomData = bomMediaItems.find(item => item.url === currentElement.dataset.url) || bomMediaItems[0];

                    currentElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                    currentElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                    // CRITICAL: Use fresh pagination data from backend
                    const currentPage = freshBomData.pagination?.current_page ?? 1;
                    const totalPages = freshBomData.pagination?.total_pages ?? 1;
                    
                    // Store current pagination state
                    currentElement.dataset.currentPage = currentPage;
                    currentElement.dataset.totalPages = totalPages;
                    
                    // ENSURE pagination object exists and has correct values
                    freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                    console.log('Current BOM content refreshed with updated pagination data:', {
                        duration: currentElement.dataset.duration,
                        is_duration_active: currentElement.dataset.isDurationActive,
                        current_page: currentPage,
                        total_pages: totalPages
                    });

                    await this.loadSplitBOMContent(currentElement, freshBomData, false, true);
                } else {
                    await this.loadBOMContent(currentElement, {});
                }
            } else {
                await this.loadBOMContent(currentElement, {});
            }
        } catch (error) {
            console.error('Error refreshing current BOM with fresh data:', error);
            await this.loadBOMContent(currentElement, {});
        }
    }
}

// CRITICAL FIX: Enhanced refreshBOMContent to preserve pagination state
async refreshBOMContent() {
    // Skip refresh if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log(`Skipping BOM refresh - manual pagination active`);
        return;
    }

    const bomElements = this.mediaElements.filter(el => 
        el.classList.contains('bom') || 
        el.dataset.mediaType === 'Paginated BOM' ||
        el.dataset.mediaType === 'Database BOM'
    );
    
    console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
    
    for (const bomElement of bomElements) {
        const mediaUrl = bomElement.dataset.url;
        if (mediaUrl) {
            console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
            
            try {
                // CRITICAL: Get fresh pagination state from backend
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];
                    
                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                        bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                        bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                        // CRITICAL: Use fresh pagination data from backend
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages = freshBomData.pagination?.total_pages ?? 1;
                        
                        // ENSURE pagination object exists and has correct values
                        freshBomData.pagination = { 
                            current_page: currentPage, 
                            total_pages: totalPages 
                        };

                        console.log(`Display ${this.displayNumber}: Refreshing BOM with fresh pagination: Page ${currentPage}/${totalPages}`);

                        // Load content with correct pagination state
                        await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                        
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh pagination data`);
                    } else {
                        // Fallback with stored pagination state
                        const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                        const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                        
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: storedPage, total_pages: storedTotal }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with stored pagination data`);
                    }
                } else {
                    // Fallback with stored pagination state
                    const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                    const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                    
                    const tempMedia = {
                        url: mediaUrl,
                        bom_type: bomElement.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        pagination: { current_page: storedPage, total_pages: storedTotal }
                    };
                    
                    await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                    console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback pagination data`);
                }
            } catch (error) {
                console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
            }
        }
    }
}

    async playCurrentMedia() {
        console.log("Starting playCurrentMedia...");
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        let duration = parseInt(currentMedia.dataset.duration) || 15000;
        let isDurationActive = currentMedia.dataset.isDurationActive === 'true';
        
        if (currentMedia.classList.contains('bom')) {
            try {
                console.log('BOM detected - fetching fresh duration data from server...');
                
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];

                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === currentMedia.dataset.url) || bomMediaItems[0];
                        
                        duration = (freshBomData.duration || 30) * 1000;
                        isDurationActive = freshBomData.is_duration_active || false;
                        
                        currentMedia.dataset.duration = duration;
                        currentMedia.dataset.isDurationActive = isDurationActive;

                        // ‚úÖ normalize pagination
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                        freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                        console.log('Fresh BOM duration + pagination data retrieved and updated', {
                            duration,
                            isDurationActive,
                            currentPage,
                            totalPages
                        });
                        
                        // Only set up refresh timer if NOT in manual mode
                        if (!this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                            this.setupBOMContentRefreshTimer(currentMedia, freshBomData);
                        }
                    }

                }
            } catch (error) {
                console.error('Error fetching fresh duration data:', error);
            }
        }

        if (currentMedia.tagName === 'VIDEO') {
            console.log('Playing video with optimizations...');
            
            if (!currentMedia.paused && currentMedia.currentTime > 0) {
                console.log('Video is already playing, not restarting');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                return;
            }
            
            try {
                if (currentMedia.preload === 'none') {
                    console.log('Loading video on-demand...');
                    currentMedia.preload = 'metadata';
                    currentMedia.load();
                }
                
                const videoReady = await Promise.race([
                    new Promise((resolve) => {
                        if (currentMedia.readyState >= 3) {
                            resolve(true);
                        } else {
                            const checkReady = () => {
                                if (currentMedia.readyState >= 3) {
                                    resolve(true);
                                } else {
                                    setTimeout(checkReady, 200);
                                }
                            };
                            checkReady();
                        }
                    }),
                    new Promise((resolve) => {
                        setTimeout(() => resolve(false), 5000);
                    })
                ]);
                
                if (!videoReady) {
                    console.warn('Video not ready after timeout, trying anyway...');
                }
                
                await currentMedia.play();
                console.log('Video playing successfully');
                
                this.preloadNextVideo();
                
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                
            } catch (error) {
                console.error('Video play error:', error.message);
                
                try {
                    currentMedia.muted = true;
                    await currentMedia.play();
                    console.log('Video playing with muted fallback');
                    this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                } catch (mutedError) {
                    console.error('All video playback failed, skipping...');
                    setTimeout(() => this.switchMedia(), 1000);
                }
            }
            
        } else if (currentMedia.classList.contains('pdf')) {
            console.log(`Displaying PDF: ${currentMedia.dataset.url}`);
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            
        } else if (currentMedia.classList.contains('bom')) {
            console.log('Displaying BOM with duration info');
            
            this.stopAutoBomPagination();

            if (isDurationActive) {
                console.log('BOM duration IS active - starting auto pagination');
                this.startAutoBomPagination(duration);
            } else {
                console.log('BOM duration is NOT active - will stay until manual advance');
                this.isBomAutoPaginationActive = false;
                this.stopAutoBomPagination();
                
                // Only set up refresh timer if NOT in manual mode
                if (!currentMedia.refreshTimer && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                    const tempMedia = {
                        url: currentMedia.dataset.url,
                        bom_type: currentMedia.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        duration: duration / 1000,
                        is_duration_active: isDurationActive
                    };
                    this.setupBOMContentRefreshTimer(currentMedia, tempMedia);
                }
            }

        } else {
            console.log('Displaying other media type');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

async startAutoBomPagination(duration) {
    this.stopAutoBomPagination(); // This will now properly clear the timer
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;
            
            this.currentBomTotalPages = totalPages;
            
            console.log(`Starting auto BOM pagination: Page ${currentPage}/${totalPages}, Duration: ${duration}ms`);
            
            if (totalPages > 1) {
                this.isBomAutoPaginationActive = true;
                this.scheduleNextBomPage(duration);
                this.showClickAlert(`Auto BOM: Page ${currentPage}/${totalPages} (${duration/1000}s)`, false);
            } else {
                console.log('BOM has only 1 page, no auto pagination needed');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('Failed to get BOM pagination info');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    } catch (error) {
        console.error('Error starting auto BOM pagination:', error);
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

scheduleNextBomPage(duration) {
    console.log(`üîÑ Scheduling next BOM page in ${duration}ms`);
    
    // FIXED: Clear the correct timer variable
    if (this.autoBomPaginationTimer) {
        console.log(`üîÑ Clearing existing auto BOM pagination timer`);
        clearTimeout(this.autoBomPaginationTimer);
    }
    
    // FIXED: Use consistent variable name
    this.autoBomPaginationTimer = setTimeout(() => {
        console.log(`‚è∞ Auto BOM pagination timer fired after ${duration}ms`);
        this.advanceAutoBomPage(duration);
    }, duration);
    
    console.log(`üîÑ Auto BOM pagination timer set with ID: ${this.autoBomPaginationTimer}`);
}

async advanceAutoBomPage(duration) {
    if (!this.isBomAutoPaginationActive) {
        console.log('üö´ Auto BOM pagination not active, skipping advance');
        return;
    }
    
    console.log(`üîÑ Advancing auto BOM page with duration: ${duration}ms`);
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;

            console.log(`üîÑ Auto BOM pagination: Currently on page ${currentPage}/${totalPages}`);
            
            let nextAction;
            let nextPage;
            
            if (currentPage < totalPages) {
                nextAction = 'next_page';
                nextPage = currentPage + 1;
                console.log(`üìÑ Moving to next page: ${nextPage}`);
            } else {
                // CRITICAL FIX: Reset to page 1 before completing cycle
                console.log(`üîÑ Completed full BOM cycle (page ${currentPage}/${totalPages}), resetting to page 1 for next cycle`);
                
                try {
                    // Reset pagination to page 1
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log(`‚úÖ Successfully reset BOM pagination to page 1 for next cycle`);
                            
                            // Update pagination state immediately
                            this.currentBomPage = 1;
                            
                            // Refresh BOM content to show page 1
                            await this.refreshBOMContent();
                            
                            console.log(`üîÑ BOM content refreshed to page 1, cycle complete`);
                        }
                    }
                } catch (resetError) {
                    console.error('‚ùå Error resetting BOM pagination to page 1:', resetError);
                }
                
                // Now move to next media after reset
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), 1000);
                return;
            }

            console.log(`üîÑ Auto BOM pagination: Moving from page ${currentPage} to page ${nextPage}`);
            
            const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    action: nextAction,
                    page: nextPage,
                    mode: this.paginationMode,
                    items_per_screen: this.itemsPerScreen
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Update the current page state
                this.currentBomPage = result.current_page;
                
                console.log(`‚úÖ Auto BOM pagination successful: Page ${result.current_page}/${result.pagination.total_pages}`);
                
                this.showClickAlert(`Auto: Page ${result.current_page}/${result.pagination.total_pages}`, false);
                
                // Always refresh BOM content after pagination change
                await this.refreshBOMContent();
                
                // Continue to next page with same duration
                this.scheduleNextBomPage(duration);
                
            } else {
                console.error('‚ùå Auto BOM pagination failed:', result.error);
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('‚ùå Failed to get current BOM pagination state');
            this.stopAutoBomPagination();
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
        
    } catch (error) {
        console.error('‚ùå Error in auto BOM pagination:', error);
        this.stopAutoBomPagination();
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}
stopAutoBomPagination() {
    // FIXED: Use the correct timer variable name
    if (this.autoBomPaginationTimer) {
        clearTimeout(this.autoBomPaginationTimer);
        this.autoBomPaginationTimer = null;
        console.log('Auto BOM pagination timer cleared');
    }
    this.isBomAutoPaginationActive = false;
    console.log('Auto BOM pagination stopped');
}

    isCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && currentElement.classList.contains('pdf');
    }

    stopCurrentMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        if (currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (currentMedia.classList.contains('pdf')) {
            currentMedia.classList.remove('fullscreen');
            this.pdfFullscreen = false;
        }
        
        if (currentMedia.classList.contains('bom')) {
            this.stopAutoBomPagination();
        }
        clearTimeout(this.slideshowTimer);
    }

    switchMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (currentMedia && currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (this.mediaElements.length === 1) {
            if (this.isCurrentlyShowingBOM()) {
                this.refreshCurrentBOMContent();
            }
            this.stopCurrentMedia();
            this.playCurrentMedia();
            return;
        }

        if (currentMedia) {
            currentMedia.classList.add('fade-out');
            currentMedia.classList.remove('active');
        }
        
        this.stopCurrentMedia();
        this.currentIndex = (this.currentIndex + 1) % this.mediaElements.length;
        
        const nextMedia = this.mediaElements[this.currentIndex];
        if (nextMedia) {
            nextMedia.classList.remove('fade-out');
            nextMedia.classList.add('active');
            
            if (nextMedia.dataset.mediaType === 'Database BOM' || nextMedia.classList.contains('bom')) {
                this.loadBOMContent(nextMedia, {});
            }
            
            this.playCurrentMedia();
        }
    }

    handleMediaError(error) {
        console.error('Media error:', error);
        this.showError('Media playback error');
        setTimeout(() => this.switchMedia(), 3000);
    }

    showError(message) {
        this.errorElement.textContent = message;
        this.errorElement.classList.remove('hidden');
    }

    hideError() {
        this.errorElement.classList.add('hidden');
    }

    setAutoLoopDurations(durations) {
        this.loopProcessDurations = { ...this.loopProcessDurations, ...durations };
        console.log('Auto loop durations updated:', this.loopProcessDurations);
    }

    getAutoLoopStatus() {
        return {
            autoLoopMode: this.autoLoopMode,
            isInLoopGroup: this.isInLoopGroup,
            currentProcessName: this.currentProcessName,
            loopProcessDurations: this.loopProcessDurations,
            timeRemaining: this.autoLoopProgressTimer ? 'active' : 'inactive'
        };
    }

    async forceAutoLoopProgress() {
        if (this.autoLoopMode) {
            await this.autoProgressLoop();
        } else {
            console.warn('Auto loop is not active');
        }
    }

    destroy() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
            this.slideshowTimer = null;
        }
        
        this.stopAllBOMRefreshTimers();
        this.stopAutoBomPagination();
        this.stopAutoLoop();
        this.stopCurrentMedia();
        
        console.log(`BRG Media Slider Display ${this.displayNumber} destroyed`);
    }
}

// Initialize the enhanced slider when page loads
document.addEventListener('DOMContentLoaded', () => {
    const stationId = {{ station.id }};
    const displayNumber = {{ station.display_number }};
    
    window.mediaSlider = new BRGMediaSliderWithAutoLoop(stationId, displayNumber);
    
    // Add global keyboard shortcuts for debugging
    document.addEventListener('keydown', (event) => {
        if (event.ctrlKey && event.shiftKey) {
            switch(event.code) {
                case 'KeyA':
                    if (window.mediaSlider) {
                        window.mediaSlider.toggleAutoLoopMode();
                    }
                    event.preventDefault();
                    break;
                case 'KeyS':
                    if (window.mediaSlider) {
                        const status = window.mediaSlider.getAutoLoopStatus();
                        console.log('Auto Loop Status:', status);
                        window.mediaSlider.showClickAlert(`Auto Loop: ${status.autoLoopMode ? 'ON' : 'OFF'}`, false);
                    }
                    event.preventDefault();
                    break;
                case 'KeyF':
                    if (window.mediaSlider) {
                        window.mediaSlider.forceAutoLoopProgress();
                    }
                    event.preventDefault();
                    break;
            }
        }
    });
});

window.addEventListener('beforeunload', () => {
    if (window.mediaSlider) {
        window.mediaSlider.destroy();
    }
});

window.getSliderStatus = () => {
    if (window.mediaSlider) {
        return {
            displayNumber: window.mediaSlider.displayNumber,
            currentIndex: window.mediaSlider.currentIndex,
            mediaCount: window.mediaSlider.mediaElements.length,
            autoLoopStatus: window.mediaSlider.getAutoLoopStatus(),
            currentProcessName: window.mediaSlider.currentProcessName,
            isInLoopGroup: window.mediaSlider.isInLoopGroup,
            manualPaginationActive: window.mediaSlider.isManualPaginationInProgress,
            ignoreExternalUpdates: window.mediaSlider.ignoreExternalBOMUpdates,
            manualCooldown: window.mediaSlider.manualPaginationCooldown
        };
    }
    return null;
};
</script>
</body>
</html>



tmkc 2

<!-- templates/brg_station_slider_enhanced.html - OPTIMIZED FOR LARGE ROTATED DISPLAYS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRG Assembly 40K - Display {{ station.display_number }}</title>
    <style>

body, html {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background-color: #ffffff !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* ENHANCED: Better rotation for portrait monitors */
body {
    transform: rotate(90deg);
    transform-origin: center center;
    width: 100vh;
    height: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    margin-top: -50vw;
    margin-left: -50vh;
    background-color: #ffffff !important;
}

.main-container {
    display: flex;
    flex-direction: column;
    height: 102vw;
    width: 100vh;
    position: relative;
}

/* COMPACT: Reduced header height to maximize content area */
.assembly-header {
    background: #DF2427;
    color: white;
    padding: 18px 30px; /* Increased from 12px 25px */
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 80px; /* Increased from 60px */
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    flex-shrink: 0;
}

.product-info {
    display: flex;
    flex-direction: column;
}

.product-code {
    font-size: 36px; /* Increased from 28px */
    font-weight: bold;
    margin-bottom: 10px; /* Increased from 8px */
    margin-bottom: 8px;
        line-height: 1.2;

}

.process-info {
    font-size: 22px; /* Increased from 18px */
    opacity: 0.9;
        line-height: 1.3;

}

.display-badge {
    background: #DF2427;
    padding: 15px 25px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 24px;
}
.display-badge div {
    font-size: 16px !important; /* Increased from 14px */
    margin-top: 5px !important; /* Increased from 3px */
}

.display-1 { border-left: 5px solid #FF6B6B; }
.display-2 { border-left: 5px solid #4ECDC4; }
.display-3 { border-left: 5px solid #45B7D1; }

/* ENHANCED: Media slider with better flex management */
.slider-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: rgb(255, 255, 255);
    overflow: hidden;
    min-height: 0; /* Important for flex children */
}

.media-element {
    height: 100%;
    width: 100%;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: contain;
    transition: opacity 0.5s ease-in-out;
}

/* COMPLETELY REWRITTEN: PDF styling for large rotated displays */
.media-element.pdf {
    /* MAXIMIZED: Use every pixel available */
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    
    position: absolute;
    top: 62%;
    left: 54%;

    /* ENHANCED: Better PDF rendering */
    object-fit: cover;
    border: none;
    background-color: white;
    
    /* CRITICAL: Force PDF to use full space */
    box-sizing: border-box;
    
    /* ENHANCED: High quality rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    
    /* REMOVE: Any margins or padding that might interfere */
    margin: 0 0 0 0 !important;
    padding: 0 !important;
    /* Centered zoom */
    transform: scale(1.088) translate(-50%, -50%);
    transform-origin: center center;

}

/* ALTERNATIVE: PDF iframe for better control */
.media-element.pdf-iframe {
    width: 100% !important;
    height: 100% !important;
    position: absolute;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    border: none;
    background-color: white;
    overflow: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* ENHANCED: PDF controls with better visibility */
.pdf-controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 150;
    display: flex;
    gap: 15px;
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.pdf-controls:hover {
    opacity: 1;
}
.media-element video {
    /* Hardware acceleration */
    transform: translateZ(0);
    will-change: opacity;
    backface-visibility: hidden;
    
    /* Smooth transitions */
    transition: opacity 0.3s ease;
}

.media-element.video-optimized {
    /* Reduce repaints */
    image-rendering: optimizeSpeed;
}
.pdf-control-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.pdf-control-btn:hover {
    background: rgba(0,0,0,1);
    transform: scale(1.1);
}

/* ENHANCED: Fullscreen PDF mode */
.media-element.pdf.fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    z-index: 1000;
    background: white;
    position: fixed !important;
}

.media-element.bom {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
}

.media-element.active {
    display: block;
    opacity: 1;
}

.media-element.fade-out {
    opacity: 0;
}

/* ENHANCED: Better clicker controls for large screens */
.clicker-controls {
    position: absolute;
    bottom: -25px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.clicker-left {
    left: 30px;
}

.clicker-right {
    right: 30px;
}

.clicker-btn {
    background: rgba(52, 152, 219, 0.9);
    border: none;
    border-radius: 50%;
    width: 90px;
    height: 90px;
    color: white;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
}

.clicker-btn:hover {
    background: rgba(52, 152, 219, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.clicker-btn:active {
    transform: scale(0.95);
    background: rgba(41, 128, 185, 1);
}

.clicker-hint {
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    margin-top: 8px;
    white-space: nowrap;
}

.clicker-controls.hidden {
    display: none;
}

/* Enhanced click feedback */
.click-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(46, 204, 113, 0.95);
    color: white;
    padding: 25px 50px;
    border-radius: 30px;
    font-size: 22px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
    transition: all 0.3s ease;
}

.click-alert.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.click-alert.error {
    background: rgba(231, 76, 60, 0.95);
}

/* COMPACT: Reduced status bar height to reclaim space */
.status-bar {
    background: rgba(246, 246, 246, 0.9);
    color: white;
    padding: 4px 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
    flex-shrink: 0;
    font-size: 14px;
}

.loop-indicator {
    background: #f39c12;
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 2s infinite;
}

.loop-indicator.hidden {
    display: none;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.connection-status {
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.connection-status.visible { opacity: 1; }
.connection-status.connected { background-color: #27ae60; color: white; }
.connection-status.disconnected { background-color: #e74c3c; color: white; }
.connection-status.reconnecting { background-color: #f39c12; color: white; }

/* Navigation hints */
.navigation-hints {
    background: rgba(52, 152, 219, 0.2);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    text-align: center;
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.navigation-hints.hidden {
    display: none;
}

/* ENHANCED: Media type indicators */
.media-type-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    backdrop-filter: blur(5px);
}

.bom-indicator { background: rgba(52, 152, 219, 0.8); }
.video-indicator { background: rgba(231, 76, 60, 0.8); }
.doc-indicator { 
    background: rgba(46, 204, 113, 0.8);
    font-size: 18px;
    padding: 15px 25px;
}

/* Error states */
.error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    font-size: 20px;
    z-index: 1000;
}

.error-message.hidden {
    display: none;
}

/* BOM indicator in status bar */
.bom-status {
    background: rgba(52, 152, 219, 0.8);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
}

/* CRITICAL: Responsive scaling for different large monitor sizes */
@media screen and (min-width: 1920px) {
    .product-code { font-size: 42px; }
    .process-info { font-size: 26px; }
    .display-badge { font-size: 28px; padding: 18px 30px; }
    .assembly-header { padding: 20px 35px; min-height: 70px; }
    .status-bar { padding: 10px 30px; font-size: 16px; min-height: 40px; }
    
    .media-element.pdf {
        /* FORCE: Maximum utilization on large screens */
        width: 100% !important;
        height: 100% !important;
    }
}

@media screen and (min-width: 2560px) {
    .product-code { 
        font-size: 50px; /* Increased from 36px */
        margin-bottom: 15px;
    }
    .process-info { font-size: 30px; }
    .display-badge { font-size: 32x; padding: 18px 30px; }
    .assembly-header { padding: 25px 40px; min-height: 100px; }
    .status-bar { padding: 12px 35px; font-size: 18px; min-height: 45px; }
    
    .pdf-control-btn { width: 70px; height: 70px; font-size: 24px; }
    .clicker-btn { width: 100px; height: 100px; font-size: 32px; }
    
    .media-type-indicator { font-size: 18px; padding: 15px 25px; }
    .doc-indicator { font-size: 20px; padding: 18px 30px; }
}

@media screen and (min-width: 3440px) {
    .assembly-header { 
        padding: 30px 45px; 
        min-height: 130px; /* Increased from 90px */
    }
    .product-code { 
        font-size: 58px; /* Increased from 40px */
        margin-bottom: 18px;
    }
    .process-info { 
        font-size: 34px; /* Increased from 24px */
    }
    .display-badge { 
        font-size: 36px; /* Increased from 26px */
        padding: 25px 40px; /* Increased from 20px 35px */
    }

    .status-bar { padding: 15px 40px; font-size: 20px; min-height: 50px; }
    
    .pdf-control-btn { width: 80px; height: 80px; font-size: 28px; }
    .clicker-btn { width: 110px; height: 110px; font-size: 36px; }
    
    .media-type-indicator { font-size: 20px; padding: 18px 30px; }
    .doc-indicator { font-size: 24px; padding: 20px 35px; }
}

/* ULTRA-WIDE: 4K and above optimizations */
@media screen and (min-width: 4096px) {
    .assembly-header { 
        padding: 35px 50px; 
        min-height: 150px; /* Increased from 100px */
    }
    .product-code { 
        font-size: 66px; /* Increased from 44px */
        margin-bottom: 20px;
    }
    .process-info { 
        font-size: 38px; /* Increased from 26px */
    }
    .display-badge { 
        font-size: 40px; /* Increased from 28px */
        padding: 28px 45px; /* Increased from 25px 40px */
    }
    .status-bar { padding: 18px 45px; font-size: 22px; min-height: 55px; }
    
    .pdf-control-btn { width: 90px; height: 90px; font-size: 32px; }
    .clicker-btn { width: 120px; height: 120px; font-size: 40px; }
    
    .media-type-indicator { font-size: 22px; padding: 20px 35px; }
    .doc-indicator { font-size: 26px; padding: 25px 40px; }
}

/* PDF LOADING INDICATOR */
.pdf-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #333;
    font-size: 24px;
    z-index: 50;
    background: rgba(255, 255, 255, 0.9);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.pdf-loading::after {
    content: "...";
    animation: dots 2s infinite;
}

@keyframes dots {
    0%, 20% { content: ""; }
    40% { content: "."; }
    60% { content: ".."; }
    80%, 100% { content: "..."; }
}

/* ZOOM ENHANCEMENT: Better PDF zoom controls */
.pdf-zoom-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 120;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pdf-zoom-info.visible {
    opacity: 1;
}

/* DEBUG: Temporary border to see PDF boundaries (remove in production) */
.media-element.pdf.debug {
    border: 3px solid red !important;
}

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Assembly Header -->
        <div class="assembly-header display-{{ station.display_number }}">
            <div class="product-info">
                <div class="product-code" id="product-code">
                    {% if current_product %}{{ current_product.code }}{% else %}No Product Selected{% endif %}
                </div>
                <div class="process-info" id="process-info">
                    {% if current_process %}
                        {{ current_stage.display_name }} - {{ current_process.display_name }}
                    {% else %}
                        No Process Selected
                    {% endif %}
                </div>
            </div>
            <div class="display-badge">
                Display {{ station.display_number }}
                <div style="font-size: 14px; margin-top: 3px;">
                    {% if station.display_number == 1 %}BOMs & Reference
                    {% elif station.display_number == 2 %}Process Instructions  
                    {% else %}Instructional Videos{% endif %}
                </div>
            </div>
        </div>

        <!-- Media Slider -->
        <div class="slider-container" id="slider-container">
            <!-- Left Clicker Controls -->
<div class="clicker-controls clicker-left {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="left-controls">
    <button class="clicker-btn" id="backward-btn" title="Previous Process">
        &#8592;
    </button>
    <div class="clicker-hint">‚Üê Previous</div>
</div>

            <!-- Right Clicker Controls -->
<div class="clicker-controls clicker-right {% if not clicker_enabled or station.display_number != 2 %}hidden{% endif %}" id="right-controls">
    <button class="clicker-btn" id="forward-btn" title="Next Process">
        &#8594;
    </button>
    <div class="clicker-hint">Next ‚Üí</div>
</div>

            <div class="error-message hidden" id="error-message">
                <div>‚ö†Ô∏è Connection Error</div>
                <div style="font-size: 16px; margin-top: 15px;">
                    Please check network connection or contact supervisor
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            {% if has_bom_data %}
            <div class="bom-status" id="bom-status">
                üìã BOM: {{ bom_item_count }} items
            </div>
            {% endif %}
            
            <div class="loop-indicator {% if not loop_mode %}hidden{% endif %}" id="loop-indicator">
                üîÑ LOOP MODE - Processes 1A, 1B, 1C
            </div>
            <div id="connection-status" class="connection-status">Connecting...</div>
        </div>

        <!-- Click Feedback Alert -->
        <div class="click-alert" id="click-alert">
            Action Completed!
        </div>
    </div>

    <script>
// COMPLETE FIXED SCRIPT - NO MORE PAGE REVERT ISSUE
class OptimizedVideoManager {
    constructor() {
        this.videoCache = new Map();
        this.preloadQueue = [];
        this.maxCacheSize = 3;
        this.videoBufferSize = 1;
    }

    createOptimizedVideoElement(media, index) {
        const video = document.createElement('video');
        video.src = media.url;
        video.className = 'media-element video-optimized';
        video.preload = index === 0 ? 'auto' : 'metadata';
        video.controls = false;
        video.loop = false;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        
        video.setAttribute('webkit-playsinline', 'true');
        video.setAttribute('playsinline', 'true');
        video.setAttribute('x-webkit-airplay', 'allow');
        
        video.addEventListener('loadstart', () => {
        });
        
        video.addEventListener('canplaythrough', () => {
            this.videoCache.set(media.url, video);
            this.manageCacheSize();
        });
        
        video.addEventListener('loadedmetadata', () => {
        });
        
        video.addEventListener('error', (e) => {
            this.handleVideoError(video, media, index);
        });
        
        video.addEventListener('stalled', () => {
            this.recoverStalledVideo(video);
        });
        
        video.addEventListener('waiting', () => {
        });
        
        return video;
    }
    
    preloadNextVideos(currentIndex, mediaElements) {
        const nextIndex = (currentIndex + 1) % mediaElements.length;
        const nextVideo = mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload !== 'auto') {
            nextVideo.preload = 'auto';
            nextVideo.load();
        }
    }
    
    manageCacheSize() {
        if (this.videoCache.size > this.maxCacheSize) {
            const oldestKey = this.videoCache.keys().next().value;
            const oldVideo = this.videoCache.get(oldestKey);
            if (oldVideo && !oldVideo.classList.contains('active')) {
                oldVideo.src = '';
                this.videoCache.delete(oldestKey);
            }
        }
    }
    
    handleVideoError(video, media, index, retryCount = 0) {
        const maxRetries = 2;
        
        if (retryCount < maxRetries) {
            setTimeout(() => {
                video.load();
                this.handleVideoError(video, media, index, retryCount + 1);
            }, 1000 * (retryCount + 1));
        } else {
            console.error(`Video ${index} failed after ${maxRetries} retries`);
            this.showVideoErrorPlaceholder(video, media);
        }
    }
    
    recoverStalledVideo(video) {
        const currentTime = video.currentTime;
        video.load();
        video.addEventListener('loadedmetadata', () => {
            video.currentTime = currentTime;
        }, { once: true });
    }
    
    showVideoErrorPlaceholder(video, media) {
        const container = video.parentElement;
        const errorDiv = document.createElement('div');
        errorDiv.className = 'video-error-placeholder';
        errorDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: #2c3e50; color: white; font-size: 24px;">
                <div style="font-size: 48px; margin-bottom: 20px;">üé•</div>
                <div>Video Unavailable</div>
                <div style="font-size: 16px; margin-top: 10px; opacity: 0.7;">
                    ${media.url.split('/').pop()}
                </div>
            </div>
        `;
        container.appendChild(errorDiv);
        video.style.display = 'none';
    }
    
    async playVideoOptimized(video) {
        try {
            if (video.readyState < 3) {
                console.log('Video not ready, waiting...');
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (video.readyState >= 3) {
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }
            
            await video.play();
            console.log('Video playing successfully');
            return true;
        } catch (error) {
            console.error('Video play error:', error);
            
            if (error.name === 'NotAllowedError') {
                video.muted = true;
                try {
                    await video.play();
                    return true;
                } catch (mutedError) {
                    console.error('Muted video play also failed:', mutedError);
                }
            }
            
            return false;
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.currentTime = 0;
            video.removeAttribute('src');
            video.load();
        }
    }
}

class VideoMemoryManager {
    constructor() {
        this.activeVideos = new Set();
        this.maxActiveVideos = 2;
    }
    
    registerVideo(video) {
        this.activeVideos.add(video);
        this.enforceMemoryLimits();
    }
    
    unregisterVideo(video) {
        this.activeVideos.delete(video);
        this.cleanupVideo(video);
    }
    
    enforceMemoryLimits() {
        if (this.activeVideos.size > this.maxActiveVideos) {
            const videosArray = Array.from(this.activeVideos);
            const oldestVideo = videosArray[0];
            this.unregisterVideo(oldestVideo);
        }
    }
    
    cleanupVideo(video) {
        if (video && video.tagName === 'VIDEO') {
            video.pause();
            video.removeAttribute('src');
            video.load();
        }
    }
    
    cleanup() {
        this.activeVideos.forEach(video => this.cleanupVideo(video));
        this.activeVideos.clear();
    }
}

// MAIN CLASS - COMPLETE REWRITE WITH FIXED PAGINATION
class BRGMediaSliderWithAutoLoop {
    constructor(stationId, displayNumber) {
        this.stationId = stationId;
        this.displayNumber = displayNumber;
        this.currentIndex = 0;
        this.mediaElements = [];
        this.slideshowTimer = null;
        this.pollingInterval = null;
        this.pollingDelay = 1000;
        this.lastDataHash = null;
        this.lastBomPaginationHash = null; // FIXED: Proper variable name
        this.pdfFullscreen = false;
        this.currentPdfZoom = 1.0;
        
        // Auto loop properties
        this.autoLoopMode = false;
        this.autoLoopTimer = null;
        this.autoLoopProgressTimer = null;
        this.loopProcessDurations = {
            'PROCESS 1A OF 6': 30000,
            'PROCESS 1B OF 6': 30000,
            'PROCESS 1C OF 6': 30000
        };

        // CRITICAL: BOM pagination properties - FIXED
        this.autoBomPaginationTimer = null;
        this.currentBomTotalPages = 1;
        this.isBomAutoPaginationActive = false;
        this.ignoreExternalBOMUpdates = false; // CRITICAL: Fixed missing semicolon
        this.isManualPaginationInProgress = false;
        this.currentBomPage = 1;
        this.manualPaginationCooldown = false; // NEW: Additional protection
        
        this.currentProcessName = null;
        this.isInLoopGroup = false;
        this.paginationMode = 'split';
        this.itemsPerScreen = 8;

        // DOM elements
        this.containerElement = document.getElementById('slider-container');
        this.statusElement = document.getElementById('connection-status');
        this.errorElement = document.getElementById('error-message');
        this.productCodeElement = document.getElementById('product-code');
        this.processInfoElement = document.getElementById('process-info');
        this.loopIndicatorElement = document.getElementById('loop-indicator');
        this.leftControlsElement = document.getElementById('left-controls');
        this.rightControlsElement = document.getElementById('right-controls');
        this.clickAlertElement = document.getElementById('click-alert');
        this.bomStatusElement = document.getElementById('bom-status');
        
        this.startPolling();
        this.setupKeyboardListeners();
        this.setupClickerListeners();
        this.logScreenInfo();
    }
async triggerOtherStationsReload() {
    try {
        console.log('Station 1: Triggering reload on other stations...');
        
        const response = await fetch(`/station/${this.stationId}/trigger-stations-reload/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                source_station: this.displayNumber,
                target_stations: [2, 3]
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            this.showClickAlert('Triggered reload on Stations 2 & 3', false);
            console.log('Stations reload triggered successfully');
        } else {
            console.error('Failed to trigger stations reload:', result.error);
        }
    } catch (error) {
        console.error('Error triggering stations reload:', error);
    }
}

async checkForReloadSignal() {
    // Only stations 2 and 3 should check for reload signals
    if (this.displayNumber === 2 || this.displayNumber === 3) {
        try {
            const response = await fetch(`/station/${this.stationId}/check-reload-signal/?display_number=${this.displayNumber}`);
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.success && result.should_reload) {
                    console.log(`Station ${this.displayNumber} received reload signal:`, result.signal_data);
                    this.showClickAlert(`Reload triggered by Station ${result.signal_data.triggered_by}`, false);
                    
                    // Wait 1 second then reload
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                }
            }
        } catch (error) {
            console.error('Error checking reload signal:', error);
        }
    }
}
    logScreenInfo() {
        console.log('Screen Information:', {
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            screenWidth: screen.width,
            screenHeight: screen.height,
            devicePixelRatio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.angle : 'unknown'
        });
    }

    async startPolling() {
        await this.pollForUpdates();
        this.pollingInterval = setInterval(async () => {
            await this.pollForUpdates();
                await this.checkForReloadSignal(); // NEW: Check for reload signals

        }, this.pollingDelay);
    }

async pollForUpdates() {
    try {
        let mediaEndpoint = `/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}`;
        
        const mediaResponse = await fetch(mediaEndpoint);
        if (!mediaResponse.ok) {
            throw new Error(`HTTP ${mediaResponse.status}`);
        }
        const mediaData = await mediaResponse.json();
        
        // FIX 2: Check for process changes that should reset pagination
        const currentProcessName = mediaData.station_info?.current_process?.name;
        const processChanged = this.currentProcessName && (this.currentProcessName !== currentProcessName);
        
        if (processChanged) {
            console.log(`üîÑ Process changed from ${this.currentProcessName} to ${currentProcessName} - resetting pagination state`);
            
            // CRITICAL: Reset all manual pagination protection when process changes
            this.isManualPaginationInProgress = false;
            this.ignoreExternalBOMUpdates = false;
            this.manualPaginationCooldown = false;
            this.stopAutoBomPagination();
            
            // Force reset BOM to page 1 for new process
            if (this.isCurrentlyShowingBOM()) {
                try {
                    console.log('üîÑ Resetting BOM to page 1 for new process...');
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log('‚úÖ BOM pagination reset to page 1 for new process');
                            this.showClickAlert(`New Process: ${currentProcessName} - Reset to Page 1`, false);
                        }
                    }
                } catch (resetError) {
                    console.warn('‚ö†Ô∏è Could not reset BOM pagination for new process:', resetError);
                }
            }
        }
        
        // Get current BOM pagination state for sync detection
        let currentBomPage = 1;
        let totalBomPages = 1;
        let bomPaginationHash = '';
        
        try {
            const bomPaginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
            if (bomPaginationResponse.ok) {
                const bomPaginationData = await bomPaginationResponse.json();
                const mediaItem = bomPaginationData.media?.[0];
                currentBomPage = mediaItem?.pagination?.current_page ?? 1;
                totalBomPages = mediaItem?.pagination?.total_pages ?? 1;
                bomPaginationHash = `${currentBomPage}_${totalBomPages}_${this.paginationMode}_${this.itemsPerScreen}`;
            }
        } catch (bomError) {
            console.warn('Could not fetch BOM pagination state:', bomError);
        }
        
        // Create hash for change detection
        const mediaHash = JSON.stringify({
            media: mediaData.media ? mediaData.media.map(m => ({ 
                id: m.id, 
                url: m.url, 
                type: m.type,
                is_bom_data: m.is_bom_data,
                bom_type: m.bom_type,
                bom_hash: m.bom_hash
            })) : [],
            station: mediaData.station_info,
            bom_pagination: bomPaginationHash
        });
        
        // Check what changed
        const mediaChanged = mediaHash !== this.lastDataHash;
        const bomPaginationChanged = bomPaginationHash !== this.lastBomPaginationHash;
        
        // FIX 2: Allow updates when process changes, even during manual pagination
        if ((bomPaginationChanged || mediaChanged) && 
            (this.ignoreExternalBOMUpdates || this.isManualPaginationInProgress || this.manualPaginationCooldown) &&
            !processChanged) { // FIXED: Allow updates when process changes
            console.log(`Display ${this.displayNumber}: Ignoring external updates - manual pagination active (but not process change)`);
            return;
        }
        
        if (mediaChanged || bomPaginationChanged || processChanged) {
            console.log(`Display ${this.displayNumber} update detected:`, { 
                mediaChanged, 
                bomPaginationChanged,
                processChanged,
                currentBomPage,
                totalBomPages,
                displayNumber: this.displayNumber
            });
            
            // Handle pagination changes differently from media changes
            if (bomPaginationChanged && !mediaChanged && !processChanged) {
                console.log(`Display ${this.displayNumber}: BOM pagination changed externally - syncing to page ${currentBomPage}/${totalBomPages}`);
                
                if (this.isCurrentlyShowingBOM()) {
                    await this.refreshBOMContent();
                    this.showClickAlert(`Synced: Page ${currentBomPage}/${totalBomPages}`, false);
                } else {
                    await this.refreshBOMContent();
                }

                this.lastBomPaginationHash = bomPaginationHash;
            } 
            else {
                // Handle normal media changes or process changes
                this.checkAutoLoopMode(mediaData);
                this.updateAssemblyInfo(mediaData, null);
                this.updateMedia(mediaData, null, false);
                this.playCurrentMedia();
                
                if (this.isCurrentlyShowingBOM()) {
                    console.log('Detected BOM slide after media update, refreshing content...');
                    this.refreshCurrentBOMContent();
                }

                this.hideError();
                this.updateConnectionStatus('connected', 'Updated');
                
                this.lastDataHash = mediaHash;
                this.lastBomPaginationHash = bomPaginationHash;
            }
        }
        
    } catch (error) {
        console.error(`Display ${this.displayNumber} polling error:`, error);
        this.showError('Connection error. Retrying...');
        this.updateConnectionStatus('disconnected', 'Connection Lost');
    }
}

    async sendClickerAction(action, alertMessage) {
        try {
            if (this.autoLoopMode) {
                console.log('Manual action detected - stopping auto loop immediately');
                this.stopAutoLoop();
                this.showClickAlert('Manual Override - Auto Loop Stopped', false);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            const response = await fetch(`/station/${this.stationId}/clicker/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Clicker action result:', result);
                
                if (result.pagination_reset) {
                    console.log('Pagination was reset due to process change');
                    setTimeout(async () => {
                        console.log('Forcing media refresh after pagination reset...');
                        await this.pollForUpdates();
                    }, 300);
                }
                
                this.updateConnectionStatus('connected', 
                    `${action.charAt(0).toUpperCase() + action.slice(1)} - Success`);
                
                if (result.exit_loop) {
                    this.updateLoopIndicator(false, false);
                }
                
                console.log('Manual action completed - auto loop will NOT restart automatically');
                
                if (!result.pagination_reset) {
                    setTimeout(async () => {
                        await this.pollForUpdates();
                    }, 200);
                }
                
            } else {
                this.showError(result.error || 'Clicker action failed');
                this.showClickAlert('Action Failed!', true);
                setTimeout(() => this.hideError(), 4000);
            }
        } catch (error) {
            console.error('Clicker action error:', error);
            this.showError('Clicker communication error');
            this.showClickAlert('Connection Error!', true);
            setTimeout(() => this.hideError(), 4000);
        }
    }

    checkAutoLoopMode(data) {
        if (!data.station_info || !data.station_info.current_process) {
            this.stopAutoLoop();
            return;
        }
        
        const currentProcess = data.station_info.current_process;
        const isInLoopGroup = currentProcess.loop_group === 'final_assembly_1abc';
        const isLoopMode = data.station_info.loop_mode;
        const processChanged = this.currentProcessName !== currentProcess.name;
        
        console.log('Auto loop check:', {
            currentProcess: currentProcess.name,
            isInLoopGroup,
            isLoopMode,
            processChanged,
            autoLoopMode: this.autoLoopMode,
            previousProcess: this.currentProcessName
        });
        
        const previousProcessName = this.currentProcessName;
        this.currentProcessName = currentProcess.name;
        this.isInLoopGroup = isInLoopGroup;
        
        if (this.autoLoopMode && (!isInLoopGroup || !isLoopMode)) {
            console.log('Exiting auto loop - no longer in loop group or loop mode disabled');
            this.stopAutoLoop();
            
            if (!isInLoopGroup && previousProcessName) {
                this.showClickAlert(`Moved to ${currentProcess.display_name} - Loop Exited`, false);
            }
        }
        else if (isInLoopGroup && isLoopMode && currentProcess.name === 'PROCESS 1A OF 6') {
            if (!this.autoLoopMode || processChanged) {
                console.log('Starting auto loop - entered Process 1A');
                this.startAutoLoop(currentProcess.name);
            }
        }
        else if (isInLoopGroup && isLoopMode && this.autoLoopMode && processChanged) {
            console.log('Restarting auto loop for new process:', currentProcess.name);
            this.startAutoLoop(currentProcess.name);
        }
        else if (!isInLoopGroup || !isLoopMode) {
            if (this.autoLoopMode) {
                console.log('Stopping auto loop - conditions not met');
                this.stopAutoLoop();
            }
        }
        
        this.updateLoopIndicator(isInLoopGroup, isLoopMode);
    }

    updateLoopIndicator(isInLoopGroup, isLoopMode) {
        if (isInLoopGroup && isLoopMode && this.autoLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ AUTO LOOP ACTIVE - 1A ‚Üí 1B ‚Üí 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#27ae60';
            this.loopIndicatorElement.classList.add('auto-mode');
        } else if (isInLoopGroup && isLoopMode) {
            this.loopIndicatorElement.innerHTML = 'üîÑ LOOP MODE (Manual) - 1A, 1B, 1C';
            this.loopIndicatorElement.classList.remove('hidden');
            this.loopIndicatorElement.style.background = '#f39c12';
            this.loopIndicatorElement.classList.remove('auto-mode');
        } else {
            this.loopIndicatorElement.classList.add('hidden');
            this.loopIndicatorElement.classList.remove('auto-mode');
        }
    }

    startAutoLoop(processName) {
        console.log(`Starting auto loop mode for process: ${processName}`);
        
        this.stopAutoLoop();
        this.autoLoopMode = true;
        
        const duration = this.loopProcessDurations[processName] || 30000;
        
        console.log(`Auto loop timer set for ${duration}ms (${duration/1000}s) for ${processName}`);
        
        this.autoLoopProgressTimer = setTimeout(async () => {
            await this.autoProgressLoop();
        }, duration);
        
        this.showClickAlert(`Auto Loop: ${processName} (${duration/1000}s)`, false);
    }

    stopAutoLoop() {
        if (this.autoLoopProgressTimer) {
            clearTimeout(this.autoLoopProgressTimer);
            this.autoLoopProgressTimer = null;
            console.log('Auto loop timer cleared');
        }
        
        if (this.autoLoopTimer) {
            clearTimeout(this.autoLoopTimer);
            this.autoLoopTimer = null;
        }
        
        this.autoLoopMode = false;
        console.log('Auto loop mode stopped');
    }

    async autoProgressLoop() {
        try {
            console.log('Auto-progressing loop from:', this.currentProcessName);
            
            const response = await fetch(`/station/${this.stationId}/auto-loop-progress/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Auto loop progression successful:', result.current_process.name);
                this.showClickAlert(`Auto: ${result.current_process.display_name}`, false);
                
                setTimeout(async () => {
                    await this.pollForUpdates();
                }, 200);
                
            } else {
                console.error('Auto loop progression failed:', result.error);
                this.stopAutoLoop();
                this.showClickAlert('Auto Loop Error', true);
            }
        } catch (error) {
            console.error('Auto loop progression error:', error);
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Connection Error', true);
        }
    }

    setupKeyboardListeners() {
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowRight') {
                console.log('Manual forward key pressed');
                this.sendClickerAction('forward', 'Manual Forward ‚û§');
                event.preventDefault();
            } else if (event.code === 'ArrowLeft') {
                console.log('Manual backward key pressed');
                this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
                    if (this.displayNumber === 1) {
        this.triggerOtherStationsReload();
    }

                event.preventDefault();
            } else if (event.code === 'ArrowDown') {
                if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                    console.log('Manual BOM page navigation (down arrow) - next page');
                    this.navigateBOMPage('next_page');
                    event.preventDefault();
                } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                    console.log('Down arrow pressed but BOM auto-pagination is active - ignoring manual input');
                    this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                    event.preventDefault();
                } else {
                    console.log('Down arrow pressed but not on BOM slide - no action');
                }
            } else if (event.code === 'ArrowUp') {
                if (this.isCurrentlyShowingBOM() && !this.isCurrentBOMDurationActive()) {
                    console.log('Manual BOM page navigation (up arrow) - previous page');
                    this.navigateBOMPage('previous_page');
                    event.preventDefault();
                } else if (this.isCurrentlyShowingBOM() && this.isCurrentBOMDurationActive()) {
                    console.log('Up arrow pressed but BOM auto-pagination is active - ignoring manual input');
                    this.showClickAlert('Auto Pagination Active - Manual Control Disabled', true);
                    event.preventDefault();
                } else {
                    console.log('Up arrow pressed but not on BOM slide - no action');
                }
            } else if (event.code === 'Space') {
                console.log('Space pressed - toggling loop mode');
                this.sendClickerAction('toggle_loop', 'Loop Mode Toggled');
                event.preventDefault();
            } else if (event.code === 'Escape') {
                if (this.autoLoopMode) {
                    console.log('ESC pressed - stopping auto loop');
                    this.stopAutoLoop();
                    this.showClickAlert('Auto Loop Stopped (Manual)', false);
                } else if (this.pdfFullscreen) {
                    this.togglePDFFullscreen();
                }
                event.preventDefault();
            }
            else if (event.code === 'PageDown' || (event.code === 'ArrowDown' && event.ctrlKey)) {
                console.log('Page Down pressed - next BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('next_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'PageUp' || (event.code === 'ArrowUp' && event.ctrlKey)) {
                console.log('Page Up pressed - previous BOM page');
                if (this.isCurrentlyShowingBOM()) {
                    this.navigateBOMPage('previous_page');
                } else {
                    this.showClickAlert('Not on BOM slide', true);
                }
                event.preventDefault();
            } else if (event.code === 'KeyM' && event.ctrlKey) {
                console.log('Ctrl+M pressed - toggle pagination mode');
                this.togglePaginationMode();
                event.preventDefault();
            }
        });
    }

    isCurrentBOMDurationActive() {
        if (!this.isCurrentlyShowingBOM()) return false;
        
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement) return false;
        
        const isDurationActive = currentElement.dataset.isDurationActive === 'true';
        
        console.log('Checking current BOM duration status:', {
            is_duration_active: isDurationActive,
            dataset_value: currentElement.dataset.isDurationActive,
            is_auto_pagination_active: this.isBomAutoPaginationActive
        });
        
        return isDurationActive;
    }

    // CRITICAL FIX: Completely rewritten navigation method that prevents auto-refresh conflicts
// FIX 2: Enhanced navigateBOMPage with shorter cooldown for process changes
async navigateBOMPage(action) {
    // Prevent multiple simultaneous pagination calls
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Pagination already in progress or in cooldown, ignoring duplicate call');
        return;
    }
    
    console.log(`=== MANUAL BOM PAGINATION START: ${action} ===`);
    
    // Set STRONGER protection flags
    this.isManualPaginationInProgress = true;
    this.ignoreExternalBOMUpdates = true;
    this.manualPaginationCooldown = true;
    
    // CRITICAL: Stop ALL polling and timers immediately
    if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        console.log('üõë STOPPED polling during manual pagination');
    }
    
    try {
        // Stop ALL auto-refresh mechanisms
        this.stopAutoBomPagination();
        this.stopAllBOMRefreshTimers();
        
        console.log(`Manual BOM pagination: ${action} requested`);

        const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.getCookie('csrftoken')
            },
            body: JSON.stringify({
                action: action,
                mode: this.paginationMode,
                items_per_screen: this.itemsPerScreen
            })
        });

        const result = await response.json();

        if (result.success) {
            console.log('‚úÖ Manual BOM pagination SUCCESS:', result);

            // Update internal state IMMEDIATELY to prevent revert
            this.currentBomPage = result.current_page;
            this.currentBomTotalPages = result.pagination.total_pages;
            
            // CRITICAL: Update hash to prevent external interference
            const newBomHash = `${result.current_page}_${result.pagination.total_pages}_${this.paginationMode}_${this.itemsPerScreen}`;
            this.lastBomPaginationHash = newBomHash;

            // Show success message
            let message = `Page ${result.current_page}/${result.pagination.total_pages}`;
            if (action === 'next_page') {
                message = `Next: ${message}`;
            } else if (action === 'previous_page') {
                message = `Prev: ${message}`;
            }
            this.showClickAlert(message, false);

            // Find and update active BOM element WITHOUT auto-refresh
            const activeBOM = this.mediaElements.find(el => 
                el.classList.contains('active') && el.classList.contains('bom')
            );
            
            if (activeBOM) {
                console.log('üîÑ Updating active BOM element with new page data');
                
                // Create fresh media object with pagination data
                const freshBomData = {
                    url: activeBOM.dataset.url,
                    duration: parseInt(activeBOM.dataset.duration || 30000) / 1000,
                    is_duration_active: activeBOM.dataset.isDurationActive === 'true',
                    is_bom_data: true,
                    bom_type: activeBOM.dataset.mediaType || 'BOM',
                    is_split: true,
                    bom_items: result.pagination.total_items,
                    bom_data: result.bom_data,
                    pagination: result.pagination
                };
                
                // Load new content with auto-refresh DISABLED
                await this.loadSplitBOMContent(activeBOM, freshBomData, false, true);
                
                console.log(`‚úÖ BOM content updated: Page ${result.current_page}/${result.pagination.total_pages}`);
            }

        } else {
            console.error('‚ùå BOM pagination error:', result.error);
            this.showClickAlert('Pagination Error', true);
        }
    } catch (error) {
        console.error('‚ùå BOM pagination error:', error);
        this.showClickAlert('Pagination Connection Error', true);
    } finally {
        // CRITICAL: Extended protection period to prevent external interference
        setTimeout(() => {
            console.log('=== MANUAL PAGINATION COOLDOWN ENDING ===');
            this.isManualPaginationInProgress = false;
            this.manualPaginationCooldown = false;
        }, 2000); // Increased from 1000ms
        
        // Keep external updates disabled longer
        setTimeout(() => {
            console.log('=== RE-ENABLING EXTERNAL UPDATES ===');
            this.ignoreExternalBOMUpdates = false;
        }, 120000); // Increased from 5000ms
        
        // CRITICAL: Restart polling after protection period
        setTimeout(() => {
            console.log('üîÑ RESTARTING polling after manual pagination');
            this.startPolling();
        }, 4000); // Restart polling after 3 seconds
    }
}


    // CRITICAL: Method to stop all BOM refresh timers
    stopAllBOMRefreshTimers() {
        console.log(`=== STOPPING ALL BOM REFRESH TIMERS for display ${this.displayNumber} ===`);
        
        this.mediaElements.forEach((element, index) => {
            if (element.refreshTimer) {
                clearTimeout(element.refreshTimer);
                element.refreshTimer = null;
                console.log(`Cleared BOM refresh timer for element ${index}`);
            }
        });
    }

    togglePaginationMode() {
        this.paginationMode = this.paginationMode === 'split' ? 'single' : 'split';
        this.showClickAlert(`Pagination Mode: ${this.paginationMode.toUpperCase()}`, false);
        
        setTimeout(async () => {
            await this.pollForUpdates();
        }, 200);
    }

    setupClickerListeners() {
        document.getElementById('forward-btn').addEventListener('click', () => {
            this.sendClickerAction('forward', 'Manual Forward ‚û§');
        });

        document.getElementById('backward-btn').addEventListener('click', () => {
            this.sendClickerAction('backward', 'Manual Backward ‚óÄ');
        });

        const autoLoopBtn = document.getElementById('auto-loop-btn');
        if (autoLoopBtn) {
            autoLoopBtn.addEventListener('click', () => {
                this.toggleAutoLoopMode();
            });
        }
    }

    async toggleAutoLoopMode() {
        if (!this.isInLoopGroup) {
            this.showClickAlert('Auto Loop only available in processes 1A, 1B, 1C', true);
            return;
        }

        if (this.autoLoopMode) {
            this.stopAutoLoop();
            this.showClickAlert('Auto Loop Disabled', false);
        } else {
            if (this.currentProcessName) {
                this.startAutoLoop(this.currentProcessName);
            }
        }
    }

    togglePDFFullscreen() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (!currentElement || !currentElement.classList.contains('pdf')) {
            this.showClickAlert('Not a PDF document', true);
            return;
        }

        this.pdfFullscreen = !this.pdfFullscreen;
        
        if (this.pdfFullscreen) {
            currentElement.classList.add('fullscreen');
            this.showClickAlert('PDF Fullscreen Mode (ESC to exit)');
        } else {
            currentElement.classList.remove('fullscreen');
            this.showClickAlert('PDF Normal Mode');
        }
    }

    showClickAlert(message, isError = false) {
        this.clickAlertElement.textContent = message;
        this.clickAlertElement.className = isError ? 'click-alert error show' : 'click-alert show';
        
        setTimeout(() => {
            this.clickAlertElement.classList.remove('show');
        }, 3000);
    }

    updateConnectionStatus(status, message) {
        this.statusElement.className = `connection-status ${status} visible`;
        this.statusElement.textContent = message;
        
        if (status === 'connected') {
            setTimeout(() => {
                this.statusElement.classList.remove('visible');
            }, 2000);
        }
    }

    updateAssemblyInfo(data, bomData) {
        if (data.station_info) {
            const station = data.station_info;
            
            if (station.current_product) {
                this.productCodeElement.textContent = station.current_product.code;
            }
            
            if (station.current_stage && station.current_process) {
                this.processInfoElement.textContent = 
                    `${station.current_stage.name} - ${station.current_process.display_name}`;
            }
            
            if (station.clicker_enabled && this.displayNumber === 2) {
                this.leftControlsElement.classList.remove('hidden');
                this.rightControlsElement.classList.remove('hidden');
            } else {
                this.leftControlsElement.classList.add('hidden');
                this.rightControlsElement.classList.add('hidden');
            }
            
            if (bomData && bomData.bom_data && this.bomStatusElement) {
                const bomType = bomData.bom_template ? bomData.bom_template.bom_type : 'Unknown';
                this.bomStatusElement.textContent = `üìã BOM: ${bomData.bom_data.length} items (${bomType})`;
                this.bomStatusElement.classList.remove('hidden');
            } else if (this.bomStatusElement) {
                this.bomStatusElement.classList.add('hidden');
            }
        }
    }

    updateMedia(data, bomData, forceUpdate = false) {
        let allMedia = [];
        
        const bomMediaItems = data.media ? data.media.filter(m => 
            m.type === 'bom' && 
            m.is_bom_data && 
            m.bom_items > 0
        ) : [];
        
        if (bomMediaItems.length > 0) {
            bomMediaItems.forEach(bomMedia => {
                allMedia.push({
                    id: bomMedia.id,
                    url: bomMedia.url,
                    type: 'bom',
                    duration: bomMedia.duration || 30,
                    is_duration_active: bomMedia.is_duration_active,
                    media_type: bomMedia.media_type || 'Paginated BOM',
                    is_bom_data: true,
                    bom_items: bomMedia.bom_items || 0,
                    bom_type: bomMedia.bom_type,
                    display_info: bomMedia.display_info,
                    is_split: bomMedia.is_split,
                    bom_data: bomMedia.bom_data,
                    pagination: bomMedia.pagination,
                    bom_hash: bomMedia.bom_hash
                });
            });
        }
        
        if (data.media && data.media.length > 0) {
            const nonBomMedia = data.media.filter(m => 
                !(m.type === 'bom' && m.is_bom_data) && 
                m.media_type !== 'Bill of Material'
            );
            
            const processedNonBomMedia = nonBomMedia.map(media => ({
                ...media,
                is_duration_active: media.is_duration_active || false
            }));
            
            allMedia = allMedia.concat(nonBomMedia);
        }
        
        if (allMedia.length === 0) {
            console.warn('No media available for display', this.displayNumber);
            this.showError(`No media available for Display ${this.displayNumber}`);
            return;
        }

        const currentUrls = this.mediaElements.map(el => el.dataset.url);
        const newUrls = allMedia.map(m => m.url);
        
        const shouldUpdate = forceUpdate || JSON.stringify(currentUrls) !== JSON.stringify(newUrls);

        if (shouldUpdate) {
            console.log('Updating paginated media elements for display', this.displayNumber, '...');
            const wasPlayingBom = this.isCurrentlyShowingBOM();
            
            this.clearCurrentMedia();
            this.createNewMediaElements(allMedia);
            
            if (wasPlayingBom && this.hasBOMElement()) {
                this.currentIndex = 0;
            }
            
            this.playCurrentMedia();
        } else {
            console.log('No paginated media update needed for display', this.displayNumber);
        }
    }

    isCurrentlyShowingBOM() {
        if (this.mediaElements.length === 0 || this.currentIndex >= this.mediaElements.length) return false;
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'));
    }

    hasBOMElement() {
        return this.mediaElements.some(el => el.dataset.mediaType === 'Database BOM' || el.classList.contains('bom'));
    }

    clearCurrentMedia() {
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
        }
        this.stopCurrentMedia();
        
        // CRITICAL: Clean up ALL BOM refresh timers before clearing elements
        this.stopAllBOMRefreshTimers();
        
        const mediaChildren = Array.from(this.containerElement.children).filter(
            child => !child.classList.contains('clicker-controls') && 
                    !child.classList.contains('error-message')
        );
        mediaChildren.forEach(child => child.remove());
        this.mediaElements = [];
        this.currentIndex = 0;
        this.pdfFullscreen = false;
    }

    createNewMediaElements(mediaData) {
        mediaData.forEach((media, index) => {
            const mediaElement = this.createMediaElement(media, index);
            if (mediaElement) {
                this.containerElement.appendChild(mediaElement);
                this.mediaElements.push(mediaElement);
            }
        });
    }

    createMediaElement(media, index) {
        let element;
        let indicator;

        if (media.is_bom_data || media.type === 'bom') {
            console.log('Creating BOM element:', media);
            element = document.createElement('div');
            element.className = 'media-element bom';
            element.dataset.url = media.url;
            element.dataset.isDurationActive = media.is_duration_active || false;
            element.dataset.duration = media.duration * 1000;
            element.dataset.bomHash = media.bom_hash || '';

            let bomTypeDisplay = 'BOM';
            if (media.is_split) {
                bomTypeDisplay = 'Split BOM';
                element.dataset.mediaType = 'Split BOM';
            } else if (media.id === 'database_bom') {
                bomTypeDisplay = 'Real-time BOM';
                element.dataset.mediaType = 'Database BOM';
            } else {
                bomTypeDisplay = media.bom_type || 'BOM';
                element.dataset.mediaType = media.media_type || 'BOM';
            }
            
            console.log(`Creating BOM element for display ${this.displayNumber}:`, {
                bomType: bomTypeDisplay,
                mediaType: element.dataset.mediaType,
                url: media.url,
                is_split: media.is_split,
                bom_items: media.bom_items
            });
            
            if (media.is_split && media.bom_data) {
                console.log('Loading split BOM content');
                this.loadSplitBOMContent(element, media);
            } else {
                console.log('Loading database BOM content');
                this.loadBOMContent(element, media);
            }
            
            indicator = document.createElement('div');
            indicator.className = 'media-type-indicator bom-indicator';
            indicator.textContent = `üìã ${bomTypeDisplay}`;
            
        } else {
            const type = media.type.toLowerCase();
            
            if (['mp4', 'mov', 'webm', 'avi'].includes(type)) {
                console.log(`Creating video element ${index}:`, media.url);
                
                element = document.createElement('video');
                element.src = media.url;
                element.className = 'media-element video-optimized';
                element.controls = false;
                element.loop = false;
                element.muted = true;
                element.playsInline = true;
                
                element.preload = index === 0 ? 'metadata' : 'none';
                element.style.transform = 'translateZ(0)';
                element.style.willChange = 'opacity';
                element.style.backfaceVisibility = 'hidden';
                
                let loadTimeout;
                element.addEventListener('loadstart', () => {
                    console.log(`Video ${index} loading started`);
                    loadTimeout = setTimeout(() => {
                        console.warn(`Video ${index} load timeout - skipping`);
                    }, 10000);
                });
                
                element.addEventListener('canplay', () => {
                    console.log(`Video ${index} ready to play`);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                });
                
                element.addEventListener('ended', () => {
                    console.log(`Video ${index} ended naturally`);
                    this.switchMedia();
                });
                
                element.addEventListener('error', (e) => {
                    console.error(`Video ${index} error:`, e);
                    if (loadTimeout) {
                        clearTimeout(loadTimeout);
                        loadTimeout = null;
                    }
                    this.showClickAlert('Video Error - Skipping', true);
                    setTimeout(() => this.switchMedia(), 2000);
                });
                
                indicator = document.createElement('div');
                indicator.className = 'media-type-indicator video-indicator';
                indicator.textContent = 'üé• Video';
                
            } else if (type === 'pdf') {
                console.log(`Creating PDF element ${index}:`, media.url);
                element = this.createOptimizedPDFElement(media);
                
            } else {
                console.warn(`Unsupported media type: ${type}`);
                return null;
            }
        }

        if (element) {
            element.dataset.duration = media.duration * 1000;
            element.dataset.url = media.url;
            element.dataset.mediaType = element.dataset.mediaType || media.media_type;
            element.className += index === 0 ? ' active' : '';
            
            if (indicator) {
                element.appendChild(indicator);
            }
        }
        
        return element;
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

    // CRITICAL FIX: Modified loadSplitBOMContent with NO AUTO-REFRESH during manual pagination
async loadSplitBOMContent(element, media, forceResetToPage1 = false, disableAutoRefresh = false) {
    try {
        console.log(`Loading BOM content for display ${this.displayNumber}:`, {
            url: media.url,
            forceReset: forceResetToPage1,
            disableAutoRefresh: disableAutoRefresh,
            currentPagination: media.pagination,
            manualPaginationActive: this.isManualPaginationInProgress
        });

        let currentPage = 1;
        let totalPages = 1;
        
        // CRITICAL FIX: Proper pagination state handling
        if (media.pagination && !forceResetToPage1) {
            // Use pagination from media data if available and not forcing reset
            currentPage = media.pagination.current_page || 1;
            totalPages = media.pagination.total_pages || 1;
            console.log(`Using provided pagination data: Page ${currentPage}/${totalPages}`);
        } else if (!forceResetToPage1) {
            // FIXED: Get current pagination state from backend when not forcing reset
            try {
                console.log("Getting current pagination state from backend...");

                const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?t=${Date.now()}`);
                
                if (paginationResponse.ok) {
                    const paginationData = await paginationResponse.json();
                    const mediaItem = paginationData.media?.[0];

                    currentPage = mediaItem?.pagination?.current_page ?? 1;
                    totalPages = mediaItem?.pagination?.total_pages ?? 1;

                    console.log(`Display ${this.displayNumber}: Current BOM page from backend is ${currentPage}/${totalPages}`);
                } else {
                    console.log(`Display ${this.displayNumber}: Could not get pagination state, using page 1`);
                }
            } catch (paginationError) {
                console.warn(`Display ${this.displayNumber}: Error getting pagination state:`, paginationError);
            }
        }
        
        // Handle force reset to page 1
        if (forceResetToPage1 && currentPage > 1) {
            console.log(`Display ${this.displayNumber}: Force reset requested - resetting to page 1`);
            
            try {
                const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        action: 'set_page',
                        page: 1,
                        mode: this.paginationMode,
                        items_per_screen: this.itemsPerScreen
                    })
                });
                
                if (resetResponse.ok) {
                    const resetResult = await resetResponse.json();
                    if (resetResult.success) {
                        currentPage = 1;
                        console.log(`Display ${this.displayNumber}: Successfully reset to page 1`);
                    }
                }
            } catch (resetError) {
                console.warn(`Display ${this.displayNumber}: Could not reset pagination to page 1:`, resetError);
            }
        }
        
        const timestamp = new Date().getTime();
        const paginationParams = new URLSearchParams({
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // CRITICAL: Use the actual current page
            t: timestamp
        });
        
        console.log(`Loading BOM content with params:`, {
            mode: this.paginationMode,
            items_per_screen: this.itemsPerScreen,
            page: currentPage, // LOG the actual page being requested
            url: `${media.url}?${paginationParams}`,
            disableAutoRefresh: disableAutoRefresh,
            manualMode: this.isManualPaginationInProgress
        });
        
        const response = await fetch(`${media.url}?${paginationParams}`);
        
        if (response.ok) {
            const bomHTML = await response.text();
            element.innerHTML = bomHTML;
            console.log(`Paginated BOM content loaded for display ${this.displayNumber} - Page ${currentPage}/${totalPages}`);
            
            // FIXED: Update indicator with correct pagination info
            const indicator = element.querySelector('.media-type-indicator');
            if (indicator) {
                const statusText = this.isBomAutoPaginationActive ? 'Auto Paging' : 'Manual';
                indicator.textContent = `üìã ${media.bom_type || 'BOM'} (Page ${currentPage}/${totalPages} - ${statusText})`;
            }
            
            // CRITICAL: Store the current page in element for future reference
            element.dataset.currentPage = currentPage;
            element.dataset.totalPages = totalPages;
            
        } else {
            console.error(`Failed to load paginated BOM: ${response.status}`);
            element.innerHTML = `
                <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                    <div>Failed to load Paginated BOM data</div>
                    <div style="font-size: 16px; margin-top: 10px;">Status: ${response.status}</div>
                    <div style="font-size: 14px; margin-top: 10px;">URL: ${media.url}?${paginationParams}</div>
                </div>
            `;
        }
        
        // CRITICAL: NEVER set up auto-refresh if manual pagination is active or disabled
        if (!disableAutoRefresh && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
            this.setupBOMContentRefreshTimer(element, media);
        } else {
            console.log(`Auto-refresh DISABLED for display ${this.displayNumber} - manual pagination protection active`);
        }
        
    } catch (error) {
        console.error(`Error loading paginated BOM content for display ${this.displayNumber}:`, error);
        element.innerHTML = `
            <div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">
                <div>Error loading Paginated BOM data</div>
                <div style="font-size: 16px; margin-top: 10px;">${error.message}</div>
            </div>
        `;
    }
}


    // CRITICAL: Modified refresh timer that respects manual pagination
    setupBOMContentRefreshTimer(element, media) {
        // CRITICAL: Never set up refresh timer if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
            console.log(`Skipping BOM refresh timer setup - manual pagination protection active`);
            return;
        }

        if (element.refreshTimer) {
            clearTimeout(element.refreshTimer);
            element.refreshTimer = null;
        }
        
        const isCurrentlyActive = element.classList.contains('active') && this.isCurrentlyShowingBOM();
        
        if (isCurrentlyActive) {
            console.log(`Setting up BOM refresh timer for display ${this.displayNumber} (with manual protection)`);
            
            element.refreshTimer = setTimeout(async () => {
                // Double-check protection flags before refreshing
                if (this.isManualPaginationInProgress || this.manualPaginationCooldown || this.ignoreExternalBOMUpdates) {
                    console.log(`Skipping auto-refresh - manual pagination protection active`);
                    // Reschedule for later
                    this.setupBOMContentRefreshTimer(element, media);
                    return;
                }

                if (element.classList.contains('active') && this.isCurrentlyShowingBOM()) {
                    console.log(`Auto-refreshing BOM content for display ${this.displayNumber}`);
                    
                    try {
                        const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                        
                        if (response.ok) {
                            const freshData = await response.json();
                            
                            const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                                m.type === 'bom' && 
                                m.is_bom_data && 
                                m.bom_items > 0
                            ) : [];
                            
                            if (bomMediaItems.length > 0) {
                                const freshBomData = bomMediaItems.find(item => item.url === element.dataset.url) || bomMediaItems[0];

                                element.dataset.duration = (freshBomData.duration || 30) * 1000;
                                element.dataset.isDurationActive = freshBomData.is_duration_active || false;

                                // also update pagination info
                                const currentPage = freshBomData.pagination?.current_page ?? 1;
                                const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                                element.dataset.currentPage = currentPage;
                                element.dataset.totalPages  = totalPages;

                                // Refresh WITHOUT auto-refresh timer
                                await this.loadSplitBOMContent(element, freshBomData, false, true);
                                
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with fresh data`);
                            } else {
                                await this.loadSplitBOMContent(element, media, false, true);
                                console.log(`BOM content auto-refreshed for display ${this.displayNumber} with existing data`);
                            }
                        } else {
                            await this.loadSplitBOMContent(element, media, false, true);
                            console.log(`BOM content auto-refreshed for display ${this.displayNumber} (fresh data fetch failed)`);
                        }
                    } catch (refreshError) {
                        console.error(`Error during BOM auto-refresh for display ${this.displayNumber}:`, refreshError);
                    }
                    
                    // Set up next refresh cycle
                    this.setupBOMContentRefreshTimer(element, media);
                } else {
                    console.log(`BOM refresh timer stopped for display ${this.displayNumber} - element no longer active`);
                }
            }, 25000); // Increased to 15 seconds to reduce conflicts
        } else {
            console.log(`No BOM refresh timer set for display ${this.displayNumber} - element not currently active`);
        }
    }

    async refreshBOMContent() {
        // Skip refresh if manual pagination is active
        if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
            console.log(`Skipping BOM refresh - manual pagination active`);
            
            return;
        }

        const bomElements = this.mediaElements.filter(el => 
            el.classList.contains('bom') || 
            el.dataset.mediaType === 'Paginated BOM' ||
            el.dataset.mediaType === 'Database BOM'
        );
        
        console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
        
        for (const bomElement of bomElements) {
            const mediaUrl = bomElement.dataset.url;
            if (mediaUrl) {
                console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
                
                try {
                    const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                    
                    if (response.ok) {
                        const freshData = await response.json();
                        
                        const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                            m.type === 'bom' && 
                            m.is_bom_data && 
                            m.bom_items > 0
                        ) : [];
                        
                        if (bomMediaItems.length > 0) {
                            const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                            bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                            bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                            // ‚úÖ add pagination info
                            const currentPage = freshBomData.pagination?.current_page ?? 1;
                            const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                            freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                            await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                            
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh data`);
                        } else {
                            const tempMedia = {
                                url: mediaUrl,
                                bom_type: bomElement.dataset.mediaType || 'BOM',
                                bom_items: 1,
                                pagination: { current_page: 1, total_pages: 1 }
                            };
                            
                            await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                            console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback data`);
                        }
                    } else {
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: 1, total_pages: 1 }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with temp data (API failed)`);
                    }
                } catch (error) {
                    console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
                }
            }
        }
    }

    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    createOptimizedPDFElement(media) {
        const container = document.createElement('div');
        container.className = 'media-element pdf';
        
        const iframe = document.createElement('iframe');
        
        const pdfUrl = media.url + '#toolbar=0&navpanes=0&scrollbar=0&view=FitH&zoom=page-width&page-mode=none';
        iframe.src = pdfUrl;
        iframe.className = 'pdf-iframe';
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        
        iframe.style.cssText = `
            width: 100% !important;
            height: 100% !important;
            border: none !important;
            margin: 0 !important;
            padding: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            background: white !important;
        `;
        
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'pdf-loading';
        loadingDiv.textContent = 'Loading PDF Document';
        
        const controlsDiv = this.createPDFControls();
        
        const zoomInfo = document.createElement('div');
        zoomInfo.className = 'pdf-zoom-info';
        zoomInfo.style.display = 'none';
        
        iframe.addEventListener('load', () => {
            console.log('PDF loaded successfully:', media.url);
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            zoomInfo.classList.add('visible');
            setTimeout(() => {
                zoomInfo.classList.remove('visible');
            }, 4000);
            
            this.optimizePDFZoom(iframe);
        });
        
        iframe.addEventListener('error', (e) => {
            console.error('PDF load error:', e);
            this.handlePDFError(container, media);
        });
        
        container.appendChild(iframe);
        container.appendChild(loadingDiv);
        container.appendChild(controlsDiv);
        container.appendChild(zoomInfo);
        
        return container;
    }

    optimizePDFZoom(iframe) {
        try {
            setTimeout(() => {
                const containerWidth = this.containerElement.offsetWidth;
                const containerHeight = this.containerElement.offsetHeight;
                
                console.log('PDF container dimensions:', {
                    width: containerWidth,
                    height: containerHeight,
                    screenRatio: containerWidth / containerHeight
                });
                
                if (iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        action: 'maximizeZoom',
                        containerWidth: containerWidth,
                        containerHeight: containerHeight
                    }, '*');
                }
            }, 1000);
        } catch (error) {
            console.log('Cannot access PDF iframe content (cross-origin):', error);
        }
    }

    createPDFControls() {
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'pdf-controls';
        controlsDiv.style.display = 'none';
        
        return controlsDiv;
    }

    refreshCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        if (currentElement && currentElement.classList.contains('pdf')) {
            const iframe = currentElement.querySelector('iframe');
            if (iframe) {
                const originalSrc = iframe.src;
                iframe.src = '';
                setTimeout(() => {
                    iframe.src = originalSrc + '&refresh=' + Date.now();
                    this.showClickAlert('PDF Refreshed');
                }, 100);
            }
        }
    }

    handlePDFError(pdfElement, media) {
        console.error('PDF failed to load:', media.url);
        
        const loadingDiv = pdfElement.querySelector('.pdf-loading');
        if (loadingDiv) {
            loadingDiv.remove();
        }
        
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(231, 76, 60, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            max-width: 80%;
        `;
        errorDiv.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px;">üìÑ PDF Load Error</div>
            <div style="font-size: 16px; margin-bottom: 15px;">
                Unable to display: ${media.url.split('/').pop()}
            </div>
            <div style="font-size: 14px; opacity: 0.9;">
                Check PDF file format and network connection
            </div>
        `;
        
        pdfElement.appendChild(errorDiv);
        
        setTimeout(() => {
            this.switchMedia();
        }, 8000);
    }

    async loadBOMContent(element, media) {
        try {
            console.log("Loading normal BOM content");
            const timestamp = new Date().getTime();
            const response = await fetch(`/station/${this.stationId}/bom-render-paginated/?t=${timestamp}`);
            
            if (response.ok) {
                const bomHTML = await response.text();
                element.innerHTML = bomHTML;
                console.log('BOM content refreshed');
            } else {
                element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Failed to load BOM data</div>';
            }
        } catch (error) {
            console.error('Error loading BOM content:', error);
            element.innerHTML = '<div class="bom-error" style="color: white; text-align: center; padding: 50px; font-size: 20px;">Error loading BOM data</div>';
        }
    }

    async refreshCurrentBOMContent() {
    // Skip if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log('Skipping current BOM refresh - manual pagination active');
        return;
    }

    const currentElement = this.mediaElements[this.currentIndex];
    if (currentElement && (currentElement.dataset.mediaType === 'Database BOM' || currentElement.classList.contains('bom'))) {
        console.log('Refreshing current BOM content...');
        
        try {
            const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
            
            if (response.ok) {
                const freshData = await response.json();
                
                const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                    m.type === 'bom' && 
                    m.is_bom_data && 
                    m.bom_items > 0
                ) : [];
                
                if (bomMediaItems.length > 0) {
                    const freshBomData = bomMediaItems.find(item => item.url === currentElement.dataset.url) || bomMediaItems[0];

                    currentElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                    currentElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                    // CRITICAL: Use fresh pagination data from backend
                    const currentPage = freshBomData.pagination?.current_page ?? 1;
                    const totalPages = freshBomData.pagination?.total_pages ?? 1;
                    
                    // Store current pagination state
                    currentElement.dataset.currentPage = currentPage;
                    currentElement.dataset.totalPages = totalPages;
                    
                    // ENSURE pagination object exists and has correct values
                    freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                    console.log('Current BOM content refreshed with updated pagination data:', {
                        duration: currentElement.dataset.duration,
                        is_duration_active: currentElement.dataset.isDurationActive,
                        current_page: currentPage,
                        total_pages: totalPages
                    });

                    await this.loadSplitBOMContent(currentElement, freshBomData, false, true);
                } else {
                    await this.loadBOMContent(currentElement, {});
                }
            } else {
                await this.loadBOMContent(currentElement, {});
            }
        } catch (error) {
            console.error('Error refreshing current BOM with fresh data:', error);
            await this.loadBOMContent(currentElement, {});
        }
    }
}

// CRITICAL FIX: Enhanced refreshBOMContent to preserve pagination state
async refreshBOMContent() {
    // Skip refresh if manual pagination is active
    if (this.isManualPaginationInProgress || this.manualPaginationCooldown) {
        console.log(`Skipping BOM refresh - manual pagination active`);
        return;
    }

    const bomElements = this.mediaElements.filter(el => 
        el.classList.contains('bom') || 
        el.dataset.mediaType === 'Paginated BOM' ||
        el.dataset.mediaType === 'Database BOM'
    );
    
    console.log(`Display ${this.displayNumber}: Refreshing ${bomElements.length} BOM elements`);
    
    for (const bomElement of bomElements) {
        const mediaUrl = bomElement.dataset.url;
        if (mediaUrl) {
            console.log(`Display ${this.displayNumber}: Refreshing BOM content from ${mediaUrl}`);
            
            try {
                // CRITICAL: Get fresh pagination state from backend
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];
                    
                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === mediaUrl) || bomMediaItems[0];

                        bomElement.dataset.duration = (freshBomData.duration || 30) * 1000;
                        bomElement.dataset.isDurationActive = freshBomData.is_duration_active || false;

                        // CRITICAL: Use fresh pagination data from backend
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages = freshBomData.pagination?.total_pages ?? 1;
                        
                        // ENSURE pagination object exists and has correct values
                        freshBomData.pagination = { 
                            current_page: currentPage, 
                            total_pages: totalPages 
                        };

                        console.log(`Display ${this.displayNumber}: Refreshing BOM with fresh pagination: Page ${currentPage}/${totalPages}`);

                        // Load content with correct pagination state
                        await this.loadSplitBOMContent(bomElement, freshBomData, false, true);
                        
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with fresh pagination data`);
                    } else {
                        // Fallback with stored pagination state
                        const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                        const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                        
                        const tempMedia = {
                            url: mediaUrl,
                            bom_type: bomElement.dataset.mediaType || 'BOM',
                            bom_items: 1,
                            pagination: { current_page: storedPage, total_pages: storedTotal }
                        };
                        
                        await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                        console.log(`Display ${this.displayNumber}: BOM content refreshed with stored pagination data`);
                    }
                } else {
                    // Fallback with stored pagination state
                    const storedPage = parseInt(bomElement.dataset.currentPage) || 1;
                    const storedTotal = parseInt(bomElement.dataset.totalPages) || 1;
                    
                    const tempMedia = {
                        url: mediaUrl,
                        bom_type: bomElement.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        pagination: { current_page: storedPage, total_pages: storedTotal }
                    };
                    
                    await this.loadSplitBOMContent(bomElement, tempMedia, false, true);
                    console.log(`Display ${this.displayNumber}: BOM content refreshed with fallback pagination data`);
                }
            } catch (error) {
                console.error(`Display ${this.displayNumber}: Error refreshing BOM content:`, error);
            }
        }
    }
}

    async playCurrentMedia() {
        console.log("Starting playCurrentMedia...");
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        let duration = parseInt(currentMedia.dataset.duration) || 15000;
        let isDurationActive = currentMedia.dataset.isDurationActive === 'true';
        
        if (currentMedia.classList.contains('bom')) {
            try {
                console.log('BOM detected - fetching fresh duration data from server...');
                
                const response = await fetch(`/station/${this.stationId}/media-with-bom-pagination/?mode=${this.paginationMode}&items_per_screen=${this.itemsPerScreen}&t=${Date.now()}`);
                
                if (response.ok) {
                    const freshData = await response.json();
                    
                    const bomMediaItems = freshData.media ? freshData.media.filter(m => 
                        m.type === 'bom' && 
                        m.is_bom_data && 
                        m.bom_items > 0
                    ) : [];

                    if (bomMediaItems.length > 0) {
                        const freshBomData = bomMediaItems.find(item => item.url === currentMedia.dataset.url) || bomMediaItems[0];
                        
                        duration = (freshBomData.duration || 30) * 1000;
                        isDurationActive = freshBomData.is_duration_active || false;
                        
                        currentMedia.dataset.duration = duration;
                        currentMedia.dataset.isDurationActive = isDurationActive;

                        // ‚úÖ normalize pagination
                        const currentPage = freshBomData.pagination?.current_page ?? 1;
                        const totalPages  = freshBomData.pagination?.total_pages ?? 1;
                        freshBomData.pagination = { current_page: currentPage, total_pages: totalPages };

                        console.log('Fresh BOM duration + pagination data retrieved and updated', {
                            duration,
                            isDurationActive,
                            currentPage,
                            totalPages
                        });
                        
                        // Only set up refresh timer if NOT in manual mode
                        if (!this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                            this.setupBOMContentRefreshTimer(currentMedia, freshBomData);
                        }
                    }

                }
            } catch (error) {
                console.error('Error fetching fresh duration data:', error);
            }
        }

        if (currentMedia.tagName === 'VIDEO') {
            console.log('Playing video with optimizations...');
            
            if (!currentMedia.paused && currentMedia.currentTime > 0) {
                console.log('Video is already playing, not restarting');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                return;
            }
            
            try {
                if (currentMedia.preload === 'none') {
                    console.log('Loading video on-demand...');
                    currentMedia.preload = 'metadata';
                    currentMedia.load();
                }
                
                const videoReady = await Promise.race([
                    new Promise((resolve) => {
                        if (currentMedia.readyState >= 3) {
                            resolve(true);
                        } else {
                            const checkReady = () => {
                                if (currentMedia.readyState >= 3) {
                                    resolve(true);
                                } else {
                                    setTimeout(checkReady, 200);
                                }
                            };
                            checkReady();
                        }
                    }),
                    new Promise((resolve) => {
                        setTimeout(() => resolve(false), 5000);
                    })
                ]);
                
                if (!videoReady) {
                    console.warn('Video not ready after timeout, trying anyway...');
                }
                
                await currentMedia.play();
                console.log('Video playing successfully');
                
                this.preloadNextVideo();
                
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                
            } catch (error) {
                console.error('Video play error:', error.message);
                
                try {
                    currentMedia.muted = true;
                    await currentMedia.play();
                    console.log('Video playing with muted fallback');
                    this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
                } catch (mutedError) {
                    console.error('All video playback failed, skipping...');
                    setTimeout(() => this.switchMedia(), 1000);
                }
            }
            
        } else if (currentMedia.classList.contains('pdf')) {
            console.log(`Displaying PDF: ${currentMedia.dataset.url}`);
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            
        } else if (currentMedia.classList.contains('bom')) {
            console.log('Displaying BOM with duration info');
            
            this.stopAutoBomPagination();

            if (isDurationActive) {
                console.log('BOM duration IS active - starting auto pagination');
                this.startAutoBomPagination(duration);
            } else {
                console.log('BOM duration is NOT active - will stay until manual advance');
                this.isBomAutoPaginationActive = false;
                this.stopAutoBomPagination();
                
                // Only set up refresh timer if NOT in manual mode
                if (!currentMedia.refreshTimer && !this.isManualPaginationInProgress && !this.manualPaginationCooldown) {
                    const tempMedia = {
                        url: currentMedia.dataset.url,
                        bom_type: currentMedia.dataset.mediaType || 'BOM',
                        bom_items: 1,
                        duration: duration / 1000,
                        is_duration_active: isDurationActive
                    };
                    this.setupBOMContentRefreshTimer(currentMedia, tempMedia);
                }
            }

        } else {
            console.log('Displaying other media type');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    }

    preloadNextVideo() {
        if (this.mediaElements.length <= 1) return;
        
        const nextIndex = (this.currentIndex + 1) % this.mediaElements.length;
        const nextVideo = this.mediaElements[nextIndex];
        
        if (nextVideo && nextVideo.tagName === 'VIDEO' && nextVideo.preload === 'none') {
            console.log(`Preloading next video: ${nextIndex}`);
            nextVideo.preload = 'metadata';
            nextVideo.load();
        }
    }

async startAutoBomPagination(duration) {
    this.stopAutoBomPagination(); // This will now properly clear the timer
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;
            
            this.currentBomTotalPages = totalPages;
            
            console.log(`Starting auto BOM pagination: Page ${currentPage}/${totalPages}, Duration: ${duration}ms`);
            
            if (totalPages > 1) {
                this.isBomAutoPaginationActive = true;
                this.scheduleNextBomPage(duration);
                this.showClickAlert(`Auto BOM: Page ${currentPage}/${totalPages} (${duration/1000}s)`, false);
            } else {
                console.log('BOM has only 1 page, no auto pagination needed');
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('Failed to get BOM pagination info');
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
    } catch (error) {
        console.error('Error starting auto BOM pagination:', error);
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}

scheduleNextBomPage(duration) {
    console.log(`üîÑ Scheduling next BOM page in ${duration}ms`);
    
    // FIXED: Clear the correct timer variable
    if (this.autoBomPaginationTimer) {
        console.log(`üîÑ Clearing existing auto BOM pagination timer`);
        clearTimeout(this.autoBomPaginationTimer);
    }
    
    // FIXED: Use consistent variable name
    this.autoBomPaginationTimer = setTimeout(() => {
        console.log(`‚è∞ Auto BOM pagination timer fired after ${duration}ms`);
        this.advanceAutoBomPage(duration);
    }, duration);
    
    console.log(`üîÑ Auto BOM pagination timer set with ID: ${this.autoBomPaginationTimer}`);
}

async advanceAutoBomPage(duration) {
    if (!this.isBomAutoPaginationActive) {
        console.log('üö´ Auto BOM pagination not active, skipping advance');
        return;
    }
    
    console.log(`üîÑ Advancing auto BOM page with duration: ${duration}ms`);
    
    try {
        const paginationResponse = await fetch(`/station/${this.stationId}/media-with-bom-pagination/`);
        
        if (paginationResponse.ok) {
            const paginationData = await paginationResponse.json();
            const mediaItem = paginationData.media?.[0];
            const currentPage = mediaItem?.pagination?.current_page ?? 1;
            const totalPages = mediaItem?.pagination?.total_pages ?? 1;

            console.log(`üîÑ Auto BOM pagination: Currently on page ${currentPage}/${totalPages}`);
            
            let nextAction;
            let nextPage;
            
            if (currentPage < totalPages) {
                nextAction = 'next_page';
                nextPage = currentPage + 1;
                console.log(`üìÑ Moving to next page: ${nextPage}`);
            } else {
                // CRITICAL FIX: Reset to page 1 before completing cycle
                console.log(`üîÑ Completed full BOM cycle (page ${currentPage}/${totalPages}), resetting to page 1 for next cycle`);
                
                try {
                    // Reset pagination to page 1
                    const resetResponse = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            action: 'set_page',
                            page: 1,
                            mode: this.paginationMode,
                            items_per_screen: this.itemsPerScreen
                        })
                    });
                    
                    if (resetResponse.ok) {
                        const resetResult = await resetResponse.json();
                        if (resetResult.success) {
                            console.log(`‚úÖ Successfully reset BOM pagination to page 1 for next cycle`);
                            
                            // Update pagination state immediately
                            this.currentBomPage = 1;
                            
                            // Refresh BOM content to show page 1
                            await this.refreshBOMContent();
                            
                            console.log(`üîÑ BOM content refreshed to page 1, cycle complete`);
                        }
                    }
                } catch (resetError) {
                    console.error('‚ùå Error resetting BOM pagination to page 1:', resetError);
                }
                
                // Now move to next media after reset
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), 1000);
                return;
            }

            console.log(`üîÑ Auto BOM pagination: Moving from page ${currentPage} to page ${nextPage}`);
            
            const response = await fetch(`/station/${this.stationId}/bom-pagination-control/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    action: nextAction,
                    page: nextPage,
                    mode: this.paginationMode,
                    items_per_screen: this.itemsPerScreen
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Update the current page state
                this.currentBomPage = result.current_page;
                
                console.log(`‚úÖ Auto BOM pagination successful: Page ${result.current_page}/${result.pagination.total_pages}`);
                
                this.showClickAlert(`Auto: Page ${result.current_page}/${result.pagination.total_pages}`, false);
                
                // Always refresh BOM content after pagination change
                await this.refreshBOMContent();
                
                // Continue to next page with same duration
                this.scheduleNextBomPage(duration);
                
            } else {
                console.error('‚ùå Auto BOM pagination failed:', result.error);
                this.stopAutoBomPagination();
                this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
            }
        } else {
            console.error('‚ùå Failed to get current BOM pagination state');
            this.stopAutoBomPagination();
            this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
        }
        
    } catch (error) {
        console.error('‚ùå Error in auto BOM pagination:', error);
        this.stopAutoBomPagination();
        this.slideshowTimer = setTimeout(() => this.switchMedia(), duration);
    }
}
stopAutoBomPagination() {
    // FIXED: Use the correct timer variable name
    if (this.autoBomPaginationTimer) {
        clearTimeout(this.autoBomPaginationTimer);
        this.autoBomPaginationTimer = null;
        console.log('Auto BOM pagination timer cleared');
    }
    this.isBomAutoPaginationActive = false;
    console.log('Auto BOM pagination stopped');
}

    isCurrentPDF() {
        const currentElement = this.mediaElements[this.currentIndex];
        return currentElement && currentElement.classList.contains('pdf');
    }

    stopCurrentMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (!currentMedia) return;

        if (currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (currentMedia.classList.contains('pdf')) {
            currentMedia.classList.remove('fullscreen');
            this.pdfFullscreen = false;
        }
        
        if (currentMedia.classList.contains('bom')) {
            this.stopAutoBomPagination();
        }
        clearTimeout(this.slideshowTimer);
    }

    switchMedia() {
        if (this.mediaElements.length === 0) return;
        
        const currentMedia = this.mediaElements[this.currentIndex];
        if (currentMedia && currentMedia.tagName === 'VIDEO') {
            currentMedia.pause();
            currentMedia.currentTime = 0;
        }
        
        if (this.mediaElements.length === 1) {
            if (this.isCurrentlyShowingBOM()) {
                this.refreshCurrentBOMContent();
            }
            this.stopCurrentMedia();
            this.playCurrentMedia();
            return;
        }

        if (currentMedia) {
            currentMedia.classList.add('fade-out');
            currentMedia.classList.remove('active');
        }
        
        this.stopCurrentMedia();
        this.currentIndex = (this.currentIndex + 1) % this.mediaElements.length;
        
        const nextMedia = this.mediaElements[this.currentIndex];
        if (nextMedia) {
            nextMedia.classList.remove('fade-out');
            nextMedia.classList.add('active');
            
            if (nextMedia.dataset.mediaType === 'Database BOM' || nextMedia.classList.contains('bom')) {
                this.loadBOMContent(nextMedia, {});
            }
            
            this.playCurrentMedia();
        }
    }

    handleMediaError(error) {
        console.error('Media error:', error);
        this.showError('Media playback error');
        setTimeout(() => this.switchMedia(), 3000);
    }

    showError(message) {
        this.errorElement.textContent = message;
        this.errorElement.classList.remove('hidden');
    }

    hideError() {
        this.errorElement.classList.add('hidden');
    }

    setAutoLoopDurations(durations) {
        this.loopProcessDurations = { ...this.loopProcessDurations, ...durations };
        console.log('Auto loop durations updated:', this.loopProcessDurations);
    }

    getAutoLoopStatus() {
        return {
            autoLoopMode: this.autoLoopMode,
            isInLoopGroup: this.isInLoopGroup,
            currentProcessName: this.currentProcessName,
            loopProcessDurations: this.loopProcessDurations,
            timeRemaining: this.autoLoopProgressTimer ? 'active' : 'inactive'
        };
    }

    async forceAutoLoopProgress() {
        if (this.autoLoopMode) {
            await this.autoProgressLoop();
        } else {
            console.warn('Auto loop is not active');
        }
    }

    destroy() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
        if (this.slideshowTimer) {
            clearTimeout(this.slideshowTimer);
            this.slideshowTimer = null;
        }
        
        this.stopAllBOMRefreshTimers();
        this.stopAutoBomPagination();
        this.stopAutoLoop();
        this.stopCurrentMedia();
        
        console.log(`BRG Media Slider Display ${this.displayNumber} destroyed`);
    }
}

// Initialize the enhanced slider when page loads
document.addEventListener('DOMContentLoaded', () => {
    const stationId = {{ station.id }};
    const displayNumber = {{ station.display_number }};
    
    window.mediaSlider = new BRGMediaSliderWithAutoLoop(stationId, displayNumber);
    
    // Add global keyboard shortcuts for debugging
    document.addEventListener('keydown', (event) => {
        if (event.ctrlKey && event.shiftKey) {
            switch(event.code) {
                case 'KeyA':
                    if (window.mediaSlider) {
                        window.mediaSlider.toggleAutoLoopMode();
                    }
                    event.preventDefault();
                    break;
                case 'KeyS':
                    if (window.mediaSlider) {
                        const status = window.mediaSlider.getAutoLoopStatus();
                        console.log('Auto Loop Status:', status);
                        window.mediaSlider.showClickAlert(`Auto Loop: ${status.autoLoopMode ? 'ON' : 'OFF'}`, false);
                    }
                    event.preventDefault();
                    break;
                case 'KeyF':
                    if (window.mediaSlider) {
                        window.mediaSlider.forceAutoLoopProgress();
                    }
                    event.preventDefault();
                    break;
            }
        }
    });
});

window.addEventListener('beforeunload', () => {
    if (window.mediaSlider) {
        window.mediaSlider.destroy();
    }
});

window.getSliderStatus = () => {
    if (window.mediaSlider) {
        return {
            displayNumber: window.mediaSlider.displayNumber,
            currentIndex: window.mediaSlider.currentIndex,
            mediaCount: window.mediaSlider.mediaElements.length,
            autoLoopStatus: window.mediaSlider.getAutoLoopStatus(),
            currentProcessName: window.mediaSlider.currentProcessName,
            isInLoopGroup: window.mediaSlider.isInLoopGroup,
            manualPaginationActive: window.mediaSlider.isManualPaginationInProgress,
            ignoreExternalUpdates: window.mediaSlider.ignoreExternalBOMUpdates,
            manualCooldown: window.mediaSlider.manualPaginationCooldown
        };
    }
    return null;
};
</script>
</body>
</html>
